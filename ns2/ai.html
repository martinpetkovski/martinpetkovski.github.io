<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StoryEngine Script Format Guide</title>
    <link rel="icon" type="image/png" href="icon_transparent.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="tab-content">
        <div class="section">
            <div id="guide-content">
                <h1>StoryEngine Script Format Guide</h1>
                <p>This guide describes the format for creating interactive stories using the StoryEngine system. StoryEngine is a text-based adventure game engine that parses scripts to create branching narratives with variables, conditions, effects, and dynamic content. Scripts are written in a custom indented format similar to YAML, with keys and values separated by ':', and specific sections for metadata, start state, variables, and states. Lines are processed sequentially, with blank lines and leading/trailing whitespace ignored via trimming. Indentation uses spaces or tabs, but consistency is not strictly enforced as parsing relies on line content and colons.</p>
                <p>The engine processes the script as follows:</p>
                <ul>
                    <li>Loads the story title, description, start state, variables (with types, initials, and optional constraints), and states (with titles, descriptions, contexts, scripts, requires, actions, properties, and choices).</li>
                    <li>Variables can be of type "float", "bool", or "string", with optional constraints in parentheses after the initial value (ranges for floats as min,max; enums for strings as "enum1","enum2",...).</li>
                    <li>States define locations or scenes with titles and descriptions (which can include dynamic [expressions] for variable substitution and calculations), contexts (optional prefixed display string, processed and shown as [context] before description), scripts (optional string for external script content or path, not executed or processed by the engine; intended for loading in external software unrelated to the story), requires ([cond1; cond2; ...] semicolon-separated conditions to enter), actions ([stmt1; stmt2; ...] semicolon-separated statements executed on entry), properties ([prop1; prop2; ...] semicolon-separated string properties that modify state behavior), and choices (listed on new lines starting with "- ", formatted as "- text [cond] -> target [effect] [hide]" where [cond], [effect], and [hide] are optional).</li>
                    <li>Supported properties (string literals, no quotes needed in list):
                        <ul>
                            <li>"start_visited": Marks the state as visited at game start, preventing initial access unless reset.</li>
                            <li>"always_available": Allows choices leading to this state to be available even if visited.</li>
                            <li>"dont_mark_visited": Prevents marking the state as visited when entered, allowing repeated access without reset.</li>
                        </ul>
                    </li>
                    <li>Choices lead to new states if conditions are met and (the target hasn't been visited or has "always_available"). Effects are semicolon-separated statements executed on selection.</li>
                    <li>The [hide] flag suppresses the automatic generation of effect descriptions (e.g., "You will gain X") in the choice menu.</li>
                    <li>Expressions support variable access via get(var), state visitation checks via visited(state), randomness via dice(min_expr, max_expr) (returns integer from min to max-1 inclusive), chance(prob_expr) (returns true with prob_expr% probability, where prob_expr is 0-100), conditional via if(cond_expr, true_expr, false_expr) (evaluates cond to bool, returns true_expr if true else false_expr; types can vary), math operations (+, -, *, / with precedence via parentheses), comparisons (==, !=, >, <, >=, <=, or = as alias for ==), logical operators (and, or, not(expr)), functions (min(a,b), max(a,b), abs(x), sqrt(x)), string literals in "double quotes", numeric literals (integers or floats like 10 or 3.14), and boolean literals (true, false). Expressions fully support infinite nesting with parentheses for grouping, allowing complex structures like (get(value) < 40 and get(some_other_value) > 60) or (chance(60) and get(other) != 50), evaluated recursively with proper precedence.</li>
                    <li>Multiple conditions in requires or choice [cond] are semicolon-separated and AND-ed together.</li>
                    <li>Dynamic text in titles, descriptions, and contexts evaluates expressions in [square brackets] and inserts the result as string (numbers formatted to two decimal places with fixed precision, booleans as "true"/"false").</li>
                    <li>The engine tracks visited states to prevent revisiting unless reset(state) is called in an effect or action, or modified by properties ("always_available" allows selection even if visited; "dont_mark_visited" skips marking on entry; "start_visited" pre-marks at start).</li>
                    <li>Variable sets enforce constraints: floats clamped if out of min-max range (no error, just clamp), strings default to first enum if mismatch (no error).</li>
                    <li>Player stats query formats booleans as "You have/lack a Var" (grouped with commas and "and/or"), strings as "Your var is value." (special case for "name": "Your name is value."), floats as "Your var is value." with two decimal places.</li>
                    <li>Games start at the specified Start state, mark it visited (unless "dont_mark_visited"), pre-mark all states with "start_visited", execute its actions, display processed title and description (prefixed with processed [context] if defined, and "{ERROR: msgs;} " if errors occurred), show available choices (filtered by condition true and (target not visited or "always_available"), appending "(effect desc)" unless [hide]), and advance by executing effect, checking target requires, setting current to target, marking visited (unless "dont_mark_visited"), and executing target actions.</li>
                    <li>Errors from evaluations or executions are collected in LastError and shown in descriptions.</li>
                </ul>

                <h2>Script Structure</h2>
                <p>The script is a plain text file with lines in the following order:</p>
                <ul>
                    <li>Metadata lines (Title:, Description:, Start:).</li>
                    <li>Then a line "Variables" (no colon, signals start of variables section).</li>
                    <li>Then variable declaration lines, each indented (optional, but typically 0 indent after section header).</li>
                    <li>Then a line "States" (no colon, signals start of states section).</li>
                    <li>Then state blocks: state_name: (no value), followed by indented properties (title:, description:, context:, script:, requires:, actions:, properties:), then choice lines starting with "- " (indented similarly to properties).</li>
                </ul>

                <h3>Metadata</h3>
                <ul>
                    <li>Title: &lt;string&gt;  # Exact format: "Title: " followed by the title string. Can include [expressions], but they are not processed here.</li>
                    <li>Description: &lt;string&gt;  # Exact format: "Description: " followed by the description string. Can include [expressions], but they are not processed here.</li>
                    <li>Start: &lt;state_name&gt;  # Exact format: "Start: " followed by the starting state name (must match a defined state).</li>
                </ul>

                <h3>Variables Section</h3>
                <ul>
                    <li>Variables  # Exact line: "Variables" (no colon, empty value).</li>
                    <li>Then one line per variable, format: &lt;type&gt; &lt;var_name&gt;: &lt;initial_value&gt; (&lt;constraint&gt;)  # Note: space between type and var_name, colon after, then initial_value, optional space then (constraint).</li>
                    <ul>
                        <li>&lt;type&gt; is one of: float, bool, string (lowercase).</li>
                        <li>&lt;var_name&gt; is alphanumeric string, typically lowercase with words like "health" or "has_torch".</li>
                        <li>&lt;initial_value&gt;:</li>
                        <ul>
                            <li>For float: numeric string like "100" or "50.75".</li>
                            <li>For bool: "true" or "false" (no quotes in script).</li>
                            <li>For string: "\"quoted string\"" (must include double quotes).</li>
                        </ul>
                        <li>&lt;constraint&gt; optional, in parentheses immediately after initial_value (with or without space):</li>
                        <ul>
                            <li>For float: min,max like "0,100" (no spaces around comma).</li>
                            <li>For string: "enum1","enum2",... (each enum in double quotes, comma-separated, no spaces around commas).</li>
                        </ul>
                    </ul>
                    <li>Example lines:</li>
                    <ul>
                        <li>float health: 100 (0,100)</li>
                        <li>bool torch: false</li>
                        <li>string profession: "Explorer" ("Explorer","Thief","Mage")</li>
                    </ul>
                </ul>

                <h3>States Section</h3>
                <ul>
                    <li>States  # Exact line: "States" (no colon, empty value).</li>
                    <li>Then for each state:</li>
                    <ul>
                        <li>&lt;state_name&gt;:  # State name followed by colon, no value. State name is alphanumeric, typically lowercase with underscores like "start_room".</li>
                        <li>Then indented lines for properties (indentation at least 1 space/tab, but parsing uses trim so exact indent not critical):</li>
                        <ul>
                            <li>title: &lt;string&gt;  # Exact: "title: " followed by title string, can include [expressions] like "Room [get(room_number)]".</li>
                            <li>description: &lt;string&gt;  # Exact: "description: " followed by description string, can include [expressions] like "Your health is [get(health)].".</li>
                            <li>context: &lt;string&gt;  # Exact: "context: " followed by context string, can include [expressions] like "[get(name)]'s Quarters". Processed and displayed as [context] prefix before description. Omit entire line if no context.</li>
                            <li>script: &lt;string&gt;  # Exact: "script: " followed by script string (content or path). Not executed or processed by the engine; intended for loading in external software unrelated to the story. Omit entire line if no script.</li>
                            <li>requires: [&lt;cond1&gt;; &lt;cond2&gt;; ...]  # Exact: "requires: [" then semicolon-separated conditions, then "]". Omit entire line if no requires. Conditions are expressions like "get(health) > 50; visited(entrance)".</li>
                            <li>actions: [&lt;stmt1&gt;; &lt;stmt2&gt;; ...]  # Exact: "actions: [" then semicolon-separated statements, then "]". Omit if no actions. Statements like "set(health, get(health) + 10); reset(entrance)".</li>
                            <li>properties: [&lt;prop1&gt;; &lt;prop2&gt;; ...]  # Exact: "properties: [" then semicolon-separated property strings, then "]". Omit if no properties. Properties like "start_visited; always_available; dont_mark_visited" (no quotes, exact strings).</li>
                        </ul>
                        <li>Then choice lines, each starting with "- " (hyphen space), at same indent as properties:</li>
                        <ul>
                            <li>- &lt;text&gt; [&lt;cond&gt;] -> &lt;target&gt; [&lt;effect&gt;] [&lt;flag&gt;]  # Exact symbols: square brackets for cond/effect/flag, -> for arrow (space around ->).</li>
                            <ul>
                                <li>&lt;text&gt;: Display text for choice, plain string (no quotes).</li>
                                <li>[&lt;cond&gt;]: Optional, expression like [get(torch) == true].</li>
                                <li>-> &lt;target&gt;: Required, space before/after ->, &lt;target&gt; is state name.</li>
                                <li>[&lt;effect&gt;]: Optional, semicolon-separated statements like [set(gold, get(gold) + dice(1,11))].</li>
                                <li>[&lt;flag&gt;]: Optional, only [hide] supported (must be exactly "hide", hides effect desc in menu).</li>
                            </ul>
                            <li>Example choice lines:</li>
                            <ul>
                                <li>- Light the torch [get(torch) == false] -> dark_room [set(torch, true)]</li>
                                <li>- Go north -> north_room [set(health, get(health) - 5)] [hide]</li>
                            </ul>
                        </ul>
                    </ul>
                </ul>

                <h2>Expressions and Statements</h2>
                <ul>
                    <li><strong>Expressions</strong> (used in [brackets] for dynamic text, in &lt;cond&gt; for requires/choices, in stmt exprs):</li>
                    <ul>
                        <li>Must be valid, trimmed, and parsable without extra spaces except where needed.</li>
                        <li>Logical: &lt;expr&gt; or &lt;expr&gt;, &lt;expr&gt; and &lt;expr&gt; (spaces around "or"/"and", uppercase OR not supported). Supports infinite nesting with parentheses for grouping and precedence, e.g., (get(value) < 40 and get(some_other_value) > 60) or (chance(60) and get(other) != 50).</li>
                        <li>Not: not(&lt;expr&gt;) (no space after not).</li>
                        <li>Comparisons: &lt;expr&gt; &lt;op&gt; &lt;expr&gt;, where &lt;op&gt; is >, <, >=, <=, !=, ==, or = (space around ops).</li>
                        <li>Math: &lt;expr&gt; &lt;op&gt; &lt;expr&gt;, where &lt;op&gt; is +, -, *, / (space around ops, no ** or other ops).</li>
                        <li>Functions:</li>
                        <ul>
                            <li>get(&lt;var&gt;)  # Retrieves variable value (typed: float as double, bool as bool, string as string).</li>
                            <li>visited(&lt;state&gt;)  # Bool if state visited.</li>
                            <li>dice(&lt;min_expr&gt;,&lt;max_expr&gt;)  # Integer random from floor(min) to floor(max)-1.</li>
                            <li>chance(&lt;prob_expr&gt;)  # Bool true with prob_expr% chance (prob_expr evaluates to 0-100).</li>
                            <li>if(&lt;cond_expr&gt;,&lt;true_expr&gt;,&lt;false_expr&gt;)  # Evaluates cond to bool, returns true_expr if true else false_expr (types can vary).</li>
                            <li>min(&lt;expr&gt;,&lt;expr&gt;), max(&lt;expr&gt;,&lt;expr&gt;)  # Numeric min/max.</li>
                            <li>abs(&lt;expr&gt;), sqrt(&lt;expr&gt;)  # Numeric absolute/square root (sqrt errors on negative).</li>
                        </ul>
                        <li>Literals: true, false (bool); "string" (string, double quotes); 10 or 3.14 (double).</li>
                        <li>Parentheses for grouping: (&lt;expr&gt;). Supports recursive, infinite nesting for complex logical, mathematical, and functional combinations.</li>
                        <li>Errors on type mismatches or invalid syntax.</li>
                    </ul>
                    <li><strong>Statements</strong> (used in actions and [effect], semicolon-separated):</li>
                    <ul>
                        <li>set(&lt;var&gt;,&lt;expr&gt;)  # Sets var to expr result, enforcing type and constraints (errors if invalid).</li>
                        <li>reset(&lt;state&gt;)  # Removes state from visited, allowing revisit.</li>
                        <li>No trailing ; on last statement, but parsing trims them if present.</li>
                    </ul>
                </ul>

                <h2>Examples</h2>
                <ul>
                    <li>Full script snippet:</li>
<pre>Title: My Adventure
Description: A simple quest.
Start: begin

Variables
float gold: 0 (0,999)
bool sword: false
string name: "Hero"

States
begin:
  title: Starting Point
  description: Welcome, [get(name)]. You have [get(gold)] gold.
  context: [get(name)]'s Journey Begins
  script: print("External script loaded for state: begin")
  actions: [set(gold, get(gold) + 10)]
  properties: [always_available]
  - Pick up sword -> armory [set(sword, true)]
  - Go to town [get(gold) > 5] -> town [set(gold, get(gold) - dice(1,6))] [hide]

armory:
  title: Armory
  description: You got a sword!
  requires: [get(sword) == false]
  properties: [dont_mark_visited; start_visited]
</pre>
                </ul>
                <p>Use this format exactly to avoid parsing errors; all keys are case-sensitive, and extra spaces in function args may cause issues due to trimming.</p>
            </div>
        </div>
    </div>
    <script>
        function htmlToMarkdown(node, level = 0) {
            if (node.nodeType === 3) {
                return node.textContent;
            }
            if (node.nodeType !== 1) return '';
            const tag = node.tagName.toLowerCase();
            const childrenMd = Array.from(node.childNodes).map(child => htmlToMarkdown(child, level)).join('');
            switch (tag) {
                case 'h1':
                    return '# ' + childrenMd.trim() + '\n\n';
                case 'h2':
                    return '## ' + childrenMd.trim() + '\n\n';
                case 'h3':
                    return '### ' + childrenMd.trim() + '\n\n';
                case 'p':
                    return childrenMd.trim() + '\n\n';
                case 'ul':
                    return Array.from(node.querySelectorAll(':scope > li')).map(li => htmlToMarkdown(li, level)).join('') + '\n';
                case 'li':
                    let textParts = [];
                    let subUls = [];
                    node.childNodes.forEach(child => {
                        if (child.nodeType === 1 && child.tagName.toLowerCase() === 'ul') {
                            subUls.push(htmlToMarkdown(child, level + 1));
                        } else {
                            textParts.push(htmlToMarkdown(child, level).trim());
                        }
                    });
                    const indent = '  '.repeat(level);
                    return indent + '- ' + textParts.join(' ') + '\n' + subUls.join('\n');
                case 'pre':
                    return '```\n' + node.textContent + '\n```\n\n';
                case 'strong':
                    return '**' + childrenMd + '**';
                case 'em':
                    return '*' + childrenMd + '*';
                case 'code':
                    return '`' + childrenMd + '`';
                default:
                    return childrenMd;
            }
        }
    </script>
</body>
</html>