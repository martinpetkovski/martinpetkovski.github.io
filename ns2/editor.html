<!-- ...existing code... -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NS2 Editor</title>
    <link rel="icon" type="image/png" href="icon_transparent.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://unpkg.com/panzoom@9.4.3/dist/panzoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.51.0/min/vs/loader.min.js"></script>
    <script type="text/javascript" src="NSE2.js"></script>
    <style>
    body {
        font-family: 'Noto Sans JP', sans-serif;
        margin: 0;
        padding: 0;
        background-color: #1E1E1E;
        color: #D4D4D4;
        font-size: 13px;
        height: 100vh;
        box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
    }

    /* Disable text selection by default across the UI; re-enable only for
       form controls and the Monaco editor so users can select code and form text */
    * {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    input, textarea, select, option, button {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
    }
    [contenteditable], .monaco-editor, .monaco-editor * {
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
    }

    #splash-screen {
        position: fixed;
        inset: 0;
        background-color: #0C0C0C;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        transition: opacity 0.08s ease-out;
    }
    #splash-screen img {
        height: 140px;
        width: auto;
        filter: drop-shadow(0 0 30px #00AbC0);
        animation: pulse 1.5s infinite alternate;
    }
    #splash-screen h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 26px;
        font-weight: 900;
        letter-spacing: 4px;
        color: #D4D4D4;
        margin: 30px 0 50px;
    }
    #loading-bar-container {
        width: 40%;
        max-width: 500px;
        height: 6px;
        background-color: #2a2a2a;
        overflow: hidden;
    }
    #loading-bar {
        height: 100%;
        width: 0;
        background: linear-gradient(to right, #00ffc0, #00AbC0, #007bb0);
        animation: fill 1s linear forwards;
    }
    @keyframes fill {
        0%   { width: 0%; }
        12%  { width: 8%; }
        25%  { width: 22%; }
        38%  { width: 28%; }
        55%  { width: 58%; }
        70%  { width: 62%; }
        85%  { width: 88%; }
        94%  { width: 94%; }
        100% { width: 100%; }
    }
    @keyframes pulse {
        from { filter: drop-shadow(0 0 20px #00AbC0); }
        to { filter: drop-shadow(0 0 40px #00AbC0); }
    }
    #splash-screen.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .header {
        display: grid;
        grid-template-columns: auto 1fr auto; /* left / center (toolbar) / right (window-controls) */
        align-items: center;
        background: linear-gradient(0deg, #0C0C0C, #161616);
        padding: 0 10px; /* remove vertical padding from title bar */
        border-bottom: 1px solid #2a2a2a;
        position: sticky;
        top: 0;
        z-index: 100;
        gap: 10px;
        min-height: 34px; /* previous header height — restore to previous look */
        height: auto;
        flex-shrink: 0;
        box-sizing: border-box;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 2px 0 rgba(255,255,255,0.05);
    }
    /* Make header draggable in frameless Electron; interactive controls must opt-out with no-drag */
    .header { -webkit-app-region: drag; }
    .no-drag { -webkit-app-region: no-drag; }
    /* Ensure interactive controls are clickable inside draggable header */
    .icon-button, .menu-button, button, a, input, select, textarea { -webkit-app-region: no-drag; }

    /* Layout helpers for the three header columns when using CSS grid */
    .header-left { display:flex; align-items:center; gap:8px; min-width:0; }
    .header-center { display:flex; align-items:center; gap:8px; flex-wrap:wrap; min-width:0; }
    .header-right { display:flex; align-items:center; gap:6px; justify-self:end; flex:0 0 auto; }

    /* remove the forced small title-line rule so compact header rules take effect */

    /* Ensure toolbar group labels are explicitly non-selectable */
    .toolbar-group .group-label,
    .toolbar .group-label {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
    }

    h1 {
        font-size: 20px;
        color: #D4D4D4;
        font-weight: bold;
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 1px;
        margin: 0;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    /* UNIFORM BUTTON STYLING */
    button {
        padding: 5px 8px;
        background: linear-gradient(0deg, #111, #222 );
        color: #999;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease, color 0.3s ease;
        display: flex;
        align-items: center;
        gap: 3px;
        font-size: 12px;
        margin: 0;
        border: 1px outset #FFF2;
        font-weight: bold;
    }

    button:hover {
        color: #FFF;
        background: transparent;
        background-color: rgba(0,123,176,0.2);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    button:active,
    button.active {
        color: #00AbC0;
        border-bottom: 2px solid #00AbC0;
        box-shadow: inset 16px 0px 20px rgba(0,123,176,0.4);
        background-color: rgba(0,123,176,0.2) !important;
        background: rgba(0,123,176,0.2) !important;
    }

    .tab-button.active {
        background-color: rgba(0,123,176,0.4);
    }

    input[type="file"] {
        padding: 5px;
        font-size: 12px;
        background-color: #2D2D2D;
        color: #D4D4D4;
        border: 1px solid #3C3C3C;
        border-radius: 3px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    input[type="file"]::file-selector-button {
        background: none;
        color: #999;
        border: none;
        padding: 5px 8px;
        border-radius: 0;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: inset 0 -2px 0 rgba(255,255,255,0.05);
        border-bottom: 2px solid transparent;
        font-weight: bold;
    }

    input[type="file"]::file-selector-button:hover {
        color: #00AbC0;
        background: linear-gradient(0deg,rgba(15, 15, 15, 1) 0%, rgba(25, 25, 25, 1) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    .tabs {
        display: flex;
        border-bottom: 1px solid #2a2a2a;
        overflow-x: auto;
        white-space: nowrap;
        position: sticky;
        top: 40px;
        z-index: 99;
        background-color: #111;
        background: linear-gradient(0deg,rgba(17, 17, 17, 1) 0%, rgba(30, 30, 30, 1) 100%);
        padding: 0;
        height: 30px;
        flex-shrink: 0;
        box-sizing: border-box;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    /* Ensure toolbar is always visible in the header */
    #global-toolbar {
        opacity: 1 !important;
        visibility: visible !important;
        max-height: none !important;
    }

    .tab-button {
        flex: 1;
        min-width: 80px;
        padding: 0 10px;
        height: 100%;
        justify-content: center;
        border: 0 !important;
        border-radius: 0px;
    }

    .tab-content {
        flex: 1;
        flex-direction: column;
        opacity: 0;
        padding: 0;
        box-sizing: border-box;
        position: relative;
        z-index: 1;
        display: none;
        width: 100%;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
    }

    .tab-content.active {
        display: flex;
        opacity: 1;
        z-index: 10;
    }

    #tab-graph {
        padding: 0;
    }

    #tab-graph .toolbar {
        flex-shrink: 0;
        margin-bottom: 0;
        padding: 0;
    }

    #graph-container {
        flex: 1;
        position: relative;
        background-color: #252526;
        box-shadow: 0 6px 16px rgba(0,0,0,0.5), inset 0 2px 4px rgba(0,0,0,0.3), inset 0 -2px 0 rgba(255,255,255,0.05);
        transition: all 0.5s ease;
        z-index: 1;
        width: 100%;
    }

    #graph-container svg {
        background-color: transparent;
        pointer-events: auto;
        display: block;
        width: 100%;
        height: 100%;
        max-width: none;
        max-height: none;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }

    #tab-graph:not(.active) #graph-container svg {
        pointer-events: none !important;
    }

    .section {
        background-color: #252526;
        box-shadow: 0 6px 16px rgba(0,0,0,0.5), inset 0 2px 0 rgba(255,255,255,0.05), inset 0 -2px 0 rgba(0,0,0,0.3);
        padding: 8px;
        transition: all 0.3s ease;
    }

    .section:hover {
        box-shadow: 0 8px 20px rgba(0,0,0,0.6), inset 0 3px 0 rgba(255,255,255,0.1), inset 0 -3px 0 rgba(0,0,0,0.4);
    }

    details {
        margin-bottom: 8px;
        transition: all 0.3s ease;
    }

    summary {
        cursor: pointer;
        font-weight: 500;
        padding: 5px;
        background-color: #2D2D2D;
        border-radius: 3px;
        color: #D4D4D4;
        list-style: none;
        transition: all 0.3s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1), inset 0 -1px 0 rgba(0,0,0,0.2);
    }

    summary:hover {
        background-color: #3C3C3D;
        box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 2px 0 rgba(255,255,255,0.15), inset 0 -2px 0 rgba(0,0,0,0.3);
    }

    details[open] summary ~ * {
        animation: fadeIn 0.5s ease-in-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
        border: inset 1px #333;
    }

    th, td {
        padding: 5px;
        text-align: left;
        border-bottom: 1px solid #3C3C3C;
        transition: all 0.3s;
        vertical-align: middle;
        height: auto;
    }

    th {
        background-color: #2D2D2D;
        font-weight: 500;
        color: #D4D4D4;
        box-shadow: inset 0 2px 0 rgba(255,255,255,0.05), inset 0 -1px 0 rgba(0,0,0,0.2);
        text-align: center;
    }

    tr:hover td {
        background-color: #2D2D2D;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
    }

    input, textarea, select {
        width: 100%;
        box-sizing: border-box;
        padding: 5px;
        border: 1px inset #3C3C3C;
        border-radius: 0;
        font-size: 12px;
        background-color: #1E1E1E;
        color: #D4D4D4;
        font-family: 'Consolas', 'Monaco', monospace;
        box-shadow: inset 0 4px 8px rgba(0,0,0,0.3), inset 0 2px 0 rgba(255,255,255,0.05), inset 0 -1px 0 rgba(0,0,0,0.2);
        transition: all 0.3s;
        margin: 0;
    }

    input:focus, textarea:focus, select:focus {
        border: 1px solid #007bb0;
        box-shadow: 0 0 8px rgba(0, 122, 204, 0.6), 0 4px 8px rgba(0,0,0,0.3), inset 0 2px 0 rgba(0,123,176,0.5);
    }

    input[type="checkbox"] {
        width: auto;
        height: 16px;
        accent-color: #007bb0;
        margin-right: 5px;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
    }

    input[type="checkbox"]:hover {
        box-shadow: 0 3px 6px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
    }

    textarea {
        min-height: 40px;
        resize: vertical;
    }

    #story-description {
        min-height: 100px;
    }

    #tab-text {
        font-family: 'Consolas', 'Courier New', monospace;
        background-color: #1E1E1E;
        padding: 8px;
        font-size: 12px;
        line-height: 1.2;
        color: #D4D4D4;
    }

    #text-editor {
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), inset 0 -2px 0 rgba(255,255,255,0.05);
        height: 100%;
        width: 100%;
    }

    .flex-row {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .flex-row button {
        flex-shrink: 0;
    }

    .grid-form {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        align-items: center;
    }

    .grid-form label {
        text-align: right;
        font-weight: 500;
        color: #D4D4D4;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    #state-search {
        /* Use flexbox sizing so search inputs fill available toolbar space */
        background-color: #1E1E1E;
        color: #D4D4D4;
        border: 1px solid #3C3C3C;
        box-sizing: border-box;
        height: 26px !important;
        padding: 0 8px;
        width: auto;
        flex: 1 1 auto;
        min-width: 0;
    }

    /* Make text inputs inside toolbars expand to fill available area */
    .toolbar input[type="text"], .play-choices-toolbar input[type="text"], .play-vars-toolbar input[type="text"] {
        flex: 1 1 auto;
        min-width: 0;
        width: auto;
        box-sizing: border-box;
        height: 26px !important;
        padding: 0 8px;
        background-color: #1E1E1E;
        color: #D4D4D4;
        border: 1px solid #3C3C3C;
    }

    .target-group {
        display: flex;
        align-items: center;
        gap: 4px;
        width: 100%;
    }

    .target-group input {
        flex: 1;
        width: auto;
        box-sizing: border-box;
        height: 26px !important;
        margin: 0 !important;
    }

    /* Icon buttons - using uniform style similar to tab-buttons */
    .target-group button,
    .icon-button {
        padding: 0;
        font-size: 12px;
        border-radius: 0;
        width: 22px;
        height: 22px;
        justify-content: center;
        color: #999;
        background: linear-gradient(135deg, rgba(0,123,176,0.38) 0%, rgba(0,123,176,0.56) 100%);
        border: none;
        box-shadow: inset 0 -2px 0 rgba(255,255,255,0.05);
        border-bottom: 2px solid transparent;
        transition: background-color 0.22s ease, box-shadow 0.22s ease, color 0.22s ease, transform 0.12s ease;
        cursor: pointer;
    }

    .target-group button:hover,
    .icon-button:hover {
        color: #FFF;
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    /* Restore colored icon buttons inside the toolbar (keeps toolbar background transparent) */
    #global-toolbar .icon-button,
    #global-toolbar .toolbar-group .icon-button {
        padding: 0;
        font-size: 12px;
        border-radius: 0;
        width: 22px;
        height: 22px;
        justify-content: center;
        color: #999;
        background: linear-gradient(135deg, rgba(0,123,176,0.38) 0%, rgba(0,123,176,0.56) 100%);
        border: none;
        box-shadow: inset 0 -2px 0 rgba(255,255,255,0.05);
        border-bottom: 2px solid transparent;
        transition: background-color 0.22s ease, box-shadow 0.22s ease, color 0.22s ease, transform 0.12s ease;
        cursor: pointer;
    }

     /* window controls styling (min/max/close) - keep static inside the header-right column
         so they never overlap toolbar and will not use absolute positioning */
     .window-controls { display:flex; gap:6px; align-items:center; z-index: 120; }
     .window-controls .icon-button { width:28px; height:22px; padding:0; display:flex; align-items:center; justify-content:center; }
     .window-controls .icon-button:hover { background-color: rgba(255,255,255,0.03); color:#fff; }
     .window-controls #win-close:hover { background: linear-gradient(90deg, rgba(220,60,60,0.95), rgba(200,30,30,0.95)); color: #fff; }
     .window-controls { -webkit-app-region: no-drag; flex: 0 0 auto; }

    #global-toolbar .icon-button:hover,
    #global-toolbar .toolbar-group .icon-button:hover {
        color: #FFF;
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }


    /* Story title displayed in the toolbar */
    .toolbar-story-title {
        color: #D4D4D4;
        font-size: 13px;
        font-weight: 600;
        margin-right: 8px;
        padding: 2px 6px;
        background: transparent;
        border-radius: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1 1 auto;
        min-width: 0; /* allow ellipsis to work inside flex */
        align-self: center;
        font-family: 'Orbitron', sans-serif;
    }

    /* Sci‑fi scrollbar styling (WebKit/Blink) */
    *::-webkit-scrollbar {
        width: 10px;
        height: 10px;
    }
    *::-webkit-scrollbar-track {
        background: linear-gradient(180deg, rgba(10,10,12,0.6), rgba(20,20,24,0.6));
        border-left: 1px solid rgba(255,255,255,0.02);
        box-shadow: inset 0 0 8px rgba(0,170,200,0.03);
        border-radius: 0;
    }
    *::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, rgba(0,170,200,0.9), rgba(0,100,140,0.9));
        border-radius: 0;
        box-shadow: 0 0 8px rgba(0,170,200,0.18), inset 0 -2px 0 rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.03);
    }
    *::-webkit-scrollbar-thumb:hover {
        transform: scale(1.02);
        box-shadow: 0 0 14px rgba(0,170,200,0.28), inset 0 -2px 0 rgba(255,255,255,0.06);
    }

    /* Firefox scrollbar support */
    html, body, .section, .tab-content, .states-list-panel, .play-content {
        scrollbar-width: thin;
        scrollbar-color: rgba(0,170,200,0.9) rgba(20,20,24,0.6);
    }

    /* Compact header elements */
    .header h1 { font-size: 15px; margin-left: 6px; line-height: 20px; }
    .header { padding: 3px 8px; }
    button { padding: 3px 5px; font-size: 12px; }
    .toolbar .icon-button { width:20px; height:20px; }

    /* Responsive compaction: reduce spacing and sizes on narrow windows */
    @media (max-width: 1100px) {
        .toolbar { gap: 4px; }
        .toolbar-group { padding: 6px 4px; }
        .toolbar .group-label { display: none; }
        .icon-button, .window-controls .icon-button { width: 20px; height: 20px; }
        .toolbar-story-title { font-size: 12px; padding: 0 6px; }
    }
    @media (max-width: 720px) {
        .header h1 { font-size: 14px; }
        .icon-button { width: 18px; height: 18px; }
        .window-controls .icon-button { width: 22px; }
    }
    /* Base node body */
    .mermaid .node rect,
    .mermaid .node polygon,
    .mermaid .node circle {
        fill: #0f394a; /* deep body color */
        stroke: rgba(0,0,0,0.5);
        stroke-width: 1.5px;
        transition: all 0.18s ease;
        /* Softer, more subtle shadow and an inset hint */
        filter: drop-shadow(0 2px 6px rgba(0,0,0,0.25));
        box-shadow: inset 0 3px 6px rgba(0,0,0,0.12);
        rx: 8; ry: 8;
    }

    /* Hover/active visual similar to UE Blueprint nodes */
    .mermaid .node:hover rect,
    .mermaid .node:hover polygon,
    .mermaid .node:hover circle {
        transform: translateY(-2px) scale(1.01);
        filter: drop-shadow(0 3px 8px rgba(0,0,0,0.28));
        box-shadow: inset 0 4px 8px rgba(0,0,0,0.14);
    }

    /* Node label / title */
    .mermaid .node text {
        fill: #FFFFFF;
        font-weight: 700;
        font-family: 'Segoe UI', Roboto, 'Noto Sans JP', sans-serif;
        font-size: 12px;
        pointer-events: none; /* text shouldn't block pointer events */
        text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }

    /* Subtle body inset for the label group created by mermaid */
    .mermaid .node .label rect { fill-opacity: 0.02; }
    .mermaid .node .label { pointer-events: none; }

    /* Small pins used as connection ports (we insert these via JS) */
    .mermaid .node .bp-pin { fill: #ffd166; stroke: #ff9f1c; stroke-width: 1px; }
    .mermaid .node .bp-pin.in { fill: #7ed6ff; stroke: #00a3d1; }
    .mermaid .node .bp-pin.out { fill: #ffd166; stroke: #ff9f1c; }

    /* Blueprint-style header band (inserted via JS) */
    .mermaid .node .bp-header,
    svg .node .bp-header,
    .node .bp-header {
        fill: #0b66a1; /* header default */
        stroke: rgba(0,0,0,0.4);
        stroke-width: 1px;
        rx: 6; ry: 6;
        opacity: 1;
    }

    /* When node hovered/selected, brighten header */
    .mermaid .node.graph-hover .bp-header,
    svg .node.graph-hover .bp-header,
    .node.graph-hover .bp-header { fill: #0d78b0; filter: drop-shadow(0 2px 6px rgba(0,0,0,0.18)); }
    .mermaid .node.graph-selected .bp-header,
    svg .node.graph-selected .bp-header,
    .node.graph-selected .bp-header { fill: #007bb0; filter: drop-shadow(0 3px 8px rgba(0,123,176,0.16)); }

    /* Small helper class so inserted foreignObject icons don't steal pointer events */
    .graph-icon-fo { pointer-events: none; }

    /* Highlight & selection visuals */
    .mermaid .node.graph-hover rect,
    .mermaid .node.graph-hover polygon,
    .mermaid .node.graph-hover circle {
        stroke: #ffd166;
        stroke-width: 3px;
        /* subtle highlight shadow (very faint) */
        filter: drop-shadow(0 2px 6px rgba(255,209,102,0.06));
        box-shadow: inset 0 2px 6px rgba(255,209,102,0.03);
    }

    .mermaid .node.graph-selected rect,
    .mermaid .node.graph-selected polygon,
    .mermaid .node.graph-selected circle {
        stroke: #ff8c42;
        stroke-width: 3px;
        filter: drop-shadow(0 3px 8px rgba(255,140,66,0.08));
        transform: translateY(-2px) scale(1.01);
    }

    .graph-icon-fo { pointer-events: none; }

    .mermaid .edgePath .path {
        stroke: #99e6ff;
        stroke-width: 2.5px;
        transition: all 0.18s ease;
        filter: drop-shadow(0 2px 6px rgba(0,0,0,0.35));
        stroke-linecap: round;
    }

    .mermaid .edgeLabel {
        fill: #dff9ff; color: #012a36; background: rgba(255,255,255,0.02);
    }

    .mermaid .edgeLabel {
        background-color: #333333;
        color: #FFFFFF;
        padding: 2px 4px;
        font-size: 11px;
        transition: all 0.3s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1), inset 0 -1px 0 rgba(0,0,0,0.2);
    }

    .dropdown {
        position: relative;
        width: 100%;
    }

    .dropdown-list {
        position: absolute;
        background: rgba(45,45,45,0.7);
        -webkit-backdrop-filter: blur(6px);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(60,60,60,0.6);
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 50vh;
        overflow: auto;
        z-index: 1000;
        width: 100%;
        max-width: calc(100vw - 16px);
        display: none;
        box-shadow: 0 8px 22px rgba(0,0,0,0.28);
        transition: opacity 0.12s ease, transform 0.12s ease;
        transform: translateY(-6px);
        opacity: 0;
        border-radius: 0;
    }

    .dropdown-list.visible {
        display: block;
        opacity: 1;
        transform: translateY(0);
    }

    .dropdown-list li {
        padding: 4px 8px;
        cursor: pointer;
        transition: background-color 0.12s ease, color 0.12s ease;
        box-shadow: none;
        color: #e4f3fb;
        font-size: 12px;
    }

    /* Only hover rows that contain child elements (guards against empty/placeholder LIs) */
    .dropdown-list li:has(*):hover {
        color: #00AbC0;
        background: rgba(15,15,15,0.15);
    }

    .toolbar {
        display: flex;
        gap: 8px;
        margin: 0;
        padding: 5px;
        align-items: center;
        background-color: #252526;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05), inset 0 -1px 0 rgba(0,0,0,0.2);
    }

    /* Groups inside the global toolbar */
    .toolbar-group {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 8px 6px;
        border-right: 1px solid rgba(255,255,255,0.03);
        margin-right: 8px;
    }
    /* Practical inline group labels (left of the buttons) with 50% foreground transparency */
    .toolbar-group .group-label {
        display: inline-block;
        margin-right: 6px;
        padding: 0 6px;
        background: transparent;
        border: none;
        border-radius: 8px;
        color: rgba(174,190,205,0.5); /* 50% foreground */
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.4px;
        text-transform: uppercase;
        white-space: nowrap;
    }

    .toolbar .menu-button {
        margin-left: auto;
        cursor: pointer !important;
    }

    .play-content {
        background-color: #252526;
        padding: 8px;
        box-shadow: 0 6px 16px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
        flex: 1;
        overflow-y: auto;
    }

    .play-content h2 {
        margin-top: 0;
        font-size: 16px;
        color: #007bb0;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .play-content h3 {
        margin: 16px 0 8px 0;
        font-size: 14px;
        color: #007bb0;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .play-content p {
        margin: 4px 0;
        line-height: 1.4;
    }

    #play-desc {
        margin-bottom: 20px !important;
    }

    .error {
        color: red;
        text-shadow: 0 1px 2px rgba(255,0,0,0.5);
    }

    .choices {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-top: 8px;
        align-self: flex-start;
        width: auto;
    }

    .choices button {
        width: auto;
        min-width: 200px;
        justify-content: flex-start;
        padding: 6px 10px;
        font-size: 13px;
        opacity: 0;
        transform: translateX(-10px);
        animation: slideIn 0.5s forwards;
        text-align: left;
    }

    /* Disabled choice buttons both in editor and play view */
    .choices button[disabled],
    .choices button.disabled {
        opacity: 0.45 !important;
        cursor: not-allowed !important;
        color: #777 !important;
        background-color: rgba(255,255,255,0.02) !important;
        box-shadow: none !important;
        transform: none !important;
        text-decoration: line-through !important;
    }

    /* General disabled button styling for toolbar and other icon buttons */
    button[disabled],
    button.disabled {
        opacity: 0.45 !important;
        cursor: not-allowed !important;
        color: #777 !important;
        box-shadow: none !important;
        background-color: rgba(255,255,255,0.02) !important;
    }

    @keyframes slideIn {
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    .states-container {
        display: flex;
        height: 100%;
    }

    .states-list-panel {
        width: 30%;
        border-right: 1px solid #3C3C3C;
        padding: 0;
        overflow-y: auto;
        box-shadow: inset 4px 0 8px rgba(0,0,0,0.3);
        background-color: #151515;
    }

    .states-list-panel ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .states-list-panel ul li {
        padding: 5px;
        cursor: pointer;
        transition: all 0.3s;
        padding-left: 20px;
        border-bottom: 1px solid #222;
        box-shadow: inset 0 2px 12px rgba(0,0,0,0.2);
        color: #999;
    }

    /* Only hover rows that contain child elements (guards against empty/placeholder LIs) */
    .states-list-panel ul li:has(*):hover {
        color: #00AbC0;
        background: linear-gradient(0deg,rgba(15, 15, 15, 1) 0%, rgba(25, 25, 25, 1) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    .states-list-panel ul li.selected {
        color: #00AbC0;
        border-bottom: 2px solid #00AbC0;
        box-shadow: inset 16px 0px 20px rgba(0,123,176,0.4);
    }

    .states-list-panel ul li.disabled {
        opacity: 0.85;
        cursor: pointer;
        color: #999;
        text-decoration: none;
        font-style: italic;
    }

    .state-details-panel {
        width: 70%;
        padding: 0;
        overflow-y: auto;
        box-shadow: inset -4px 0 8px rgba(0,0,0,0.3);
        background-color: #252526;
    }

    .menubar {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-left: auto;
        flex: 1 1 auto; /* allow menubar to shrink and wrap */
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    /* toolbar should wrap into its own row when space is limited so it pushes the content below downward */
    .toolbar {
        display: flex;
        gap: 6px;
        align-items: center;
        flex-wrap: nowrap; /* do not wrap toolbar groups; use overflow menu instead */
        flex: 0 0 auto;
        justify-content: flex-end;
        overflow: hidden;
    }

    /* Make toolbar groups wrap as whole units: each .toolbar-group keeps its size and moves to next line if needed */
    .toolbar-group {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        padding: 6px 4px;
        flex: 0 1 auto; /* allow groups to shrink; overflow handled by JS */
        white-space: nowrap; /* prevent internal buttons from wrapping */
        min-width: 0;
    }

    /* ensure the menubar's non-toolbar controls (language/help) stay on the right row */
    .menubar .dropdown-menu { order: 2; }

    .menu-button {
        background-color: #252526;
        padding: 4px 8px;
        position: relative;
        transition: all 0.3s;
        cursor: pointer;
    }

    .dropdown-menu {
        display: none;
        position: absolute;
        background: transparent;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        z-index: 101;
        left: auto;
        right: 0;
        top: 100%;
        opacity: 0;
        transform: translateY(-10px) scale(0.95);
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid rgba(60, 60, 60, 0.8);
    }

    .dropdown-menu .menu-button {
        /* subtle bluish toolbar background for visual separation */
        /* slightly stronger blue tint (10% more prominent) */
        background: linear-gradient(180deg, rgba(12,28,48,0.61), rgba(6,16,30,0.66)) !important;
        border: 1px solid rgba(80,140,200,0.066) !important;
    }

    @keyframes dropdownOpen {
        from {
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    @keyframes dropdownClose {
        from {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        to {
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
        }
    }

    #language-dropdown {
        max-height: 50vh;
        overflow: hidden;
    }

    #language-dropdown input[type="text"] {
        width: 100%;
        padding: 8px;
        background: #1E1E1E;
        border: none;
        border-bottom: 1px solid #3C3C3C;
        color: #D4D4D4;
        box-sizing: border-box;
        font-size: 12px;
        position: sticky;
        top: 0;
        z-index: 1;
        box-shadow: inset 0 2px 0 rgba(255,255,255,0.05), inset 0 -1px 0 rgba(0,0,0,0.2);
    }

    #language-dropdown .button-container {
        overflow-y: auto;
        max-height: calc(50vh - 40px);
    }

    #language-dropdown button {
        width: 100%;
        text-align: left;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .menu-button:hover .dropdown-menu {
        display: block;
        opacity: 1;
        transform: translateY(0) scale(1);
        animation: dropdownOpen 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    /* Dropdowns styled to match toolbar/tabs (same dark gradient + subtle inner highlight) */
    .dropdown-menu {
        background: linear-gradient(0deg, #111, #222);
        border: 1px solid rgba(255,255,255,0.03);
        box-shadow: 0 8px 20px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
        backdrop-filter: blur(6px);
        color: #D4D4D4;
        border-radius: 0;
        padding: 6px;
    }

    .dropdown-menu button {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
        text-align: left;
        padding: 8px 10px;
        border: none !important;
        background: transparent !important;
        color: #D4D4D4;
        margin: 2px 0;
        border-radius: 0;
        transition: background-color 0.18s ease, color 0.18s ease, box-shadow 0.18s ease;
    }

    .dropdown-menu button:hover {
        color: #FFF;
        /* Use the same hover visual as toolbar icon buttons for perfect match */
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    /* Inline toolbar styling to match menubar buttons (allow wrapping on small screens) */
    #global-toolbar {
        position: relative;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap; /* allow groups to wrap to next line on small screens */
        background: transparent;
        padding-left: 6px;
        padding-right: 6px;
        margin-left: 6px;
        pointer-events: auto;
        z-index: 102;
    }

    .dropdown-menu .menu-category {
        padding: 6px 8px;
        border-bottom: 1px solid rgba(255,255,255,0.03);
    }

    .dropdown-menu .menu-category-title {
        color: #cfcfcf;
        font-size: 12px;
        padding: 4px 2px 8px 2px;
        font-weight: 600;
        min-width: 120px;
        text-align: left;
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 0.3px;
    }

    /* Category titles should not receive hover highlights */
    .dropdown-menu .menu-category-title,
    .dropdown-menu .menu-category-title * {
        background: transparent !important;
        color: #cfcfcf !important;
        cursor: default !important;
        pointer-events: none; /* ensure title doesn't react to hover/click */
    }

    /* Ensure the category container itself does not get highlighted when hovering its items */
    .dropdown-menu .menu-category,
    .dropdown-menu .menu-category:hover {
        background: transparent !important;
    }

    /* category layout: title left, items stacked on the right */
    .dropdown-menu .menu-category {
        display: flex;
        gap: 12px;
        align-items: flex-start;
        padding: 6px 8px;
    }

    .dropdown-menu .menu-category-items {
        display: flex;
        flex-direction: column;
        gap: 6px;
        flex: 1 1 auto;
    }

    /* Toolbar should be visually transparent (no background) per request */
    #global-toolbar {
        background: transparent !important;
        box-shadow: none !important;
    }

    /* Context menus that are not the small dropdowns (token/graph context)
       — use the same visual language as `.dropdown-menu` so all menus look uniform */
    #context-menu, #graph-context-menu {
        background: linear-gradient(0deg, #111, #222);
        border: 1px solid rgba(255,255,255,0.03);
        box-shadow: 0 8px 20px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
        color: #D4D4D4;
        border-radius: 0;
        padding: 6px;
        max-height: 50vh;
        overflow: auto;
        backdrop-filter: blur(6px);
    }

    #context-menu .dropdown-item, #graph-context-menu .dropdown-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 8px 10px;
        margin: 4px 0;
        background: transparent;
        color: #D4D4D4;
        border-radius: 0;
        transition: background-color 0.18s ease, box-shadow 0.18s ease;
    }

    #context-menu .dropdown-item:hover, #graph-context-menu .dropdown-item:hover {
        color: #fff;
        /* Use the toolbar button hover gradient to match exact color */
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0 40px rgba(0,123,176,0.6);
    }

    /* Icon tinting: default subtle, teal on hover */
    .dropdown-menu button i,
    .dropdown-menu button .fa,
    #context-menu .dropdown-item i,
    #context-menu .dropdown-item .fa,
    #graph-context-menu .dropdown-item i,
    #graph-context-menu .dropdown-item .fa {
        transition: color 0.18s ease, opacity 0.18s ease;
        color: rgba(212,212,212,0.7);
    }

    .dropdown-menu button:hover i,
    .dropdown-menu button:hover .fa,
    #context-menu .dropdown-item:hover i,
    #context-menu .dropdown-item:hover .fa,
    #graph-context-menu .dropdown-item:hover i,
    #graph-context-menu .dropdown-item:hover .fa {
        color: #00AbC0; /* teal accent */
    }

    .states-list-panel .toolbar {
        position: sticky;
        top: 0;
        background-color: #1E1E1E;
        z-index: 1;
        padding: 5px 5px 5px 0; /* remove left padding so search touches left edge */
        display: flex;
        gap: 8px;
        margin: 0;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    #tab-variables .toolbar {
        position: sticky;
        top: 0;
        background-color: #1E1E1E;
        z-index: 1;
        padding: 0;
        margin: 0;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    #file-input, #load-save {
        display: none;
    }

    #tab-graph .toolbar {
        justify-content: flex-start;
    }

    /* Positioning for context menus (kept distinct from small dropdowns) */
    #context-menu {
        position: fixed; /* position relative to viewport for safe clamping */
        z-index: 10000;
        max-height: 50vh; /* responsive to viewport */
        overflow: hidden;
        display: none;
        width: 300px;
        max-width: calc(100vw - 16px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        color: #d6e3ea;
        font-size: 12px;
    }

    #context-menu input {
        flex: none;
        position: relative;
        z-index: 1;
        background-color: transparent;
        border-bottom: 1px solid rgba(47,49,51,0.45);
        margin: 0;
        width: calc(100% - 2px);
        box-shadow: none;
        padding: 4px 6px;
        font-size: 12px;
        color: #eaf6ff;
    }

    #context-menu ul {
        flex: 1;
        overflow-y: auto;
        list-style: none;
        padding: 0;
        margin: 0;
    }

    /* Each menu row: fixed first column (token/label), flexible second column (example/description) */
    #context-menu li {
        padding: 3px 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background-color 0.12s ease, color 0.12s ease;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
        color: #cfe7f3;
    }

    /* Token/name column: fixed width to align items in a neat column */
    #context-menu li .token {
        flex: 0 0 100px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: #dbefff;
        font-weight: 600;
    }

    /* Example/description column grows to fill remaining space */
    #context-menu li .example {
        flex: 1 1 auto;
        color: rgba(154,166,173,0.45); /* more transparent */
        font-style: normal;
        margin-left: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 11px;
        line-height: 1.1;
        text-align: right; /* push description to the right */
    }

    /* Category header rows inside the menu */
    #context-menu li.menu-category {
        padding: 6px 8px;
        font-size: 10px;
        color: rgba(139,153,166,0.9);
        text-transform: uppercase;
        letter-spacing: 0.8px;
        cursor: default;
        box-shadow: none;
    }

    /* Only apply hover to rows that contain child elements (prevents hover on empty/placeholders) */
    #context-menu li:not(.menu-category):has(*):hover {
        color: #00AbC0;
        /* Use toolbar button hover gradient for stronger, consistent highlight */
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    /* Prevent category header rows from highlighting on hover */
    #context-menu li.menu-category:hover {
        background: transparent !important;
        color: rgba(139,153,166,0.9) !important;
        box-shadow: none !important;
    }

    #context-menu li .token {
        flex: 1;
    }

    #context-menu li .example {
        color: rgba(154,166,173,0.5); /* 50% transparent description */
        font-style: normal;
        margin-left: 10px;
        text-align: right; /* ensure description is on the right */
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Ensure hidden/placeholder LIs don't receive pointer events (covers inline style cases) */
    .states-list-panel ul li[hidden],
    .states-list-panel ul li[style*="display:none"],
    .states-list-panel ul li[style*="display: none"],
    .dropdown-list li[hidden],
    .dropdown-list li[style*="display:none"],
    .dropdown-list li[style*="display: none"],
    #context-menu li[hidden],
    #context-menu li[style*="display:none"],
    #context-menu li[style*="display: none"] {
        pointer-events: none;
    }

    #context-menu,
    #token-menu-list,
    .dropdown-menu,
    #language-dropdown .button-container,
    #graph-context-menu ul {
        overflow-x: hidden !important;
    }

    .force-visit {
        background-color: #8B0000 !important;
        color: #fff !important;
    }

    .force-visit:hover {
        background-color: #660000 !important;
    }

    /* Graph context menu: use the same visual language as dropdowns for uniformity */
    #graph-context-menu {
        position: fixed;
        z-index: 10000;
        display: none;
        transition: all 0.12s ease;
        min-width: 160px;
        max-width: calc(100vw - 16px);
        max-height: 50vh;
        overflow: auto;
        border-radius: 0;
        /* Visuals matching `.dropdown-menu` */
        background: linear-gradient(0deg, #111, #222);
        border: 1px solid rgba(255,255,255,0.03);
        box-shadow: 0 8px 20px rgba(0,0,0,0.6);
        padding: 6px;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        color: #D4D4D4;
    }

    #graph-context-menu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #graph-context-menu li {
        padding: 6px 8px;
        cursor: pointer;
        transition: background-color 0.18s ease, color 0.18s ease;
        border-radius: 0;
        background: transparent;
        color: #d6e3ea;
    }

    /* Only hover real graph context menu items (skip separators/empty LIs) */
    #graph-context-menu li:has(*):hover {
        color: #FFF;
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    /* Support for dynamic button-based context menu */
    #graph-context-menu .button-container {
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding: 6px;
    }

    #graph-context-menu .button-container button {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
        text-align: left;
        padding: 8px 10px;
        border: none !important;
        background: transparent !important;
        color: #D4D4D4;
        cursor: pointer;
        transition: background-color 0.18s ease, color 0.18s ease, box-shadow 0.18s ease;
        border-radius: 0;
        font-size: 12px;
    }

    #graph-context-menu .button-container button:hover {
        color: #FFF;
        background: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    #tab-text .toolbar {
        margin: 0;
        padding: 0;
    }

    .choices-section {
        margin-top: 16px;
        flex: 1;
        display: flex;
        flex-direction: column;
    }

    .choices-section .toolbar {
        position: sticky;
        top: 0;
        background-color: #1E1E1E;
        z-index: 1;
        padding: 0;
        margin: 0 0 4px 0;
        flex-shrink: 0;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .choices-section .table-wrapper {
        flex: 1;
        overflow-y: auto;
    }

    .choices-section table {
        width: 100%;
        display: table;
    }

    .play-choices-toolbar {
        position: sticky;
        top: 0;
        background-color: #1E1E1E;
        z-index: 1;
        padding: 0;
        margin: 0 0 4px 0;
        flex-shrink: 0;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .play-vars-toolbar {
        position: sticky;
        top: 0;
        background-color: #1E1E1E;
        z-index: 1;
        padding: 0;
        margin: 0 0 4px 0;
        flex-shrink: 0;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .state-name {
        font-size: 10px;
        color: #FFF4;
        font-style: italic;
        margin-left: 8px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .flag {
        margin-right: 5px;
        /* prefer OS color emoji fonts so flags render inside Electron */
        font-family: "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "EmojiOne Color", sans-serif;
        font-size: 16px;
        line-height: 1;
    }
    .flag-img {
        display: inline-block;
        width: 20px;
        height: 14px;
        object-fit: cover;
        margin-right: 6px;
        vertical-align: middle;
    }

    .props-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
    }

    .props-container label {
        position: relative;
        padding: 4px 8px 7px 8px;
        border-bottom: 3px solid transparent;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        border-radius: 3px;
        color: #FFF5;
    }

    .props-container label:hover {
        color: #00AbC0;
        background: linear-gradient(0deg,rgba(15, 15, 15, 1) 0%, rgba(25, 25, 25, 1) 100%);
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6);
    }

    .props-container input[type="checkbox"] {
        opacity: 0;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
        z-index: 2;
        margin: 0;
    }

    .props-container label:has(input[type="checkbox"]:checked) {
        border-bottom-color: #00ff00;
        box-shadow: 0 6px 8px rgba(0, 255, 0, 0.3), inset 0 -1px 0 #00ff00;
        color: #00ff00;
        border: 1px #0f0 solid;
        border-bottom-width: 5px;
    }

    .hide-cell {
        text-align: center;
        padding: 0 5px !important;
    }

    .hide-cell input[type="checkbox"] {
        appearance: none;
        -webkit-appearance: none;
        width: 60px;
        height: 26px;
        background-color: #2D2D2D;
        position: relative;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
        transition: background-color 0.3s;
    }

    .hide-cell input[type="checkbox"]:hover {
        background-color: #3C3C3D;
    }

    .hide-cell input[type="checkbox"]::after {
        content: "";
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        bottom: auto;
        left: 8px;
        right: 8px;
        height: 5px;
        background-color: #00000022;
        transition: all 0.3s ease;
    }

    .hide-cell input[type="checkbox"]:checked::after {
        background-color: #0f0;
        box-shadow: 0 0 22px #00ff00;
    }

    html, body { height: 100vh; margin: 0 !important; padding: 0 !important; overflow: hidden; }
    #editor { display: flex; flex-direction: column; height: 100vh; width: 100%; }

    /* Make the global toolbar inline and always visible in the header menubar.
       This neutralizes older fixed/hidden behaviour and lets the header control layout. */
    #global-toolbar {
        position: relative !important;
        top: auto !important;
        left: auto !important;
        transform: none !important;
        z-index: 102 !important;
        background: transparent !important;
        border-radius: 6px;
        opacity: 1 !important;
        visibility: visible !important;
        max-height: none !important;
        overflow: visible !important;
        transition: none !important;
        pointer-events: auto !important;
        width: auto !important;
        max-width: none !important;
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
        padding: 4px 8px !important;
        margin-right: 6px;
    }

    #tab-metadata .section,
    #tab-variables .section,
    #tab-states .states-container,
    #tab-play .play-content,
    #state-details,
    #graph-container,
    #text-editor { flex: 1; }

    #tab-metadata .section,
    #tab-variables .section,
    #tab-play .play-content,
    #state-details > div { padding: 10px; box-sizing: border-box; }

    .section, table, #graph-container, .play-content, .toolbar,
    .dropdown-menu, #context-menu, #graph-context-menu,
    .state-details-panel, .states-list-panel, .tab-content,
    .menu-button, .dropdown-menu button,
    summary, .props-container label { border-radius: 0 !important; }

    /* Restore rounded visual for menus (this overrides the global zero-radius rule above)
       so dropdowns and context menus remain visually consistent. */
    .dropdown-menu, #context-menu, #graph-context-menu {
        border-radius: 6px !important;
        background: linear-gradient(0deg, #111, #222) !important;
        border: 1px solid rgba(255,255,255,0.03) !important;
        box-shadow: 0 8px 20px rgba(0,0,0,0.6) !important;
        padding: 6px !important;
    }

    .toolbar-group {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 8px 6px;
        margin-right: 8px;
        flex: 0 1 auto; /* allow groups to shrink and wrap as units */
        min-width: 0;
    }
    /* Contextual toolbar group visual: slightly lighter blue tint and subtle border */
    /* More specific selector: toolbar groups that are contextual should be a bit lighter/more prominent */
    .toolbar-group.toolbar-context {
        background: rgba(120,190,240,0.10); /* ~20% more prominent (lighter) */
        border-radius: 6px;
        padding: 6px 8px;
        border: 1px solid rgba(120,190,240,0.07);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
    }
    /* vertical separators between categories (30% opacity) */
    .toolbar-group:not(:last-child) {
        border-right: 1px solid rgba(212,212,212,0.1); /* 10% opacity, 1px */
    }
    /* Practical inline group labels (left of the buttons) with 20% foreground transparency and site title font */
    .toolbar-group .group-label {
        order: -1; /* force label to the left of group buttons */
        display: inline-block;
        margin-right: 8px;
        margin-left: 0;
        padding: 0 6px;
        background: transparent;
        border: none;
        border-radius: 8px;
        color: rgba(174,190,205,0.2); /* 20% foreground */
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.4px;
        text-transform: uppercase;
        white-space: nowrap;
        font-family: 'Orbitron', sans-serif; /* match site title */
    }

    /* Slight layout tweaks on very small screens */
    @media (max-width: 720px) {
        #global-toolbar { gap: 6px; }
        .toolbar-group { padding: 6px 4px; }
        .toolbar-group .group-label { font-size: 11px; margin-right: 4px; }
    }
    /* Overflow menu for toolbar groups when space is limited */
    .toolbar-overflow { position: relative; }
    .toolbar-overflow .overflow-btn { padding: 6px 8px; }
    .toolbar-overflow .overflow-menu {
        display: none;
        position: absolute;
        top: 100%;
        right: 0;
        background: #1e1e1e;
        border: 1px solid rgba(255,255,255,0.06);
        box-shadow: 0 6px 18px rgba(0,0,0,0.5);
        z-index: 9999;
        min-width: 220px;
        max-height: 360px;
        overflow: auto;
        padding: 6px;
        border-radius: 6px;
    }
    /* Each overflowed group shows its label on top, and buttons flow horizontally beneath */
    .toolbar-overflow .overflow-menu .toolbar-group {
        display: block;
        border-right: none;
        margin: 6px 0;
        padding: 6px 4px;
    }
    .toolbar-overflow .overflow-menu .toolbar-group .group-label {
        display: block;
        margin-bottom: 6px;
        font-size: 12px;
        font-weight: 600;
        color: rgba(174,190,205,0.35);
    }
    .toolbar-overflow .overflow-menu .toolbar-group .icon-button {
        display: inline-flex;
        margin-right: 6px;
        margin-bottom: 4px;
        vertical-align: middle;
    }
    /* Hide the visual separator now that title removed */
    .toolbar-separator { display: none; }

    /* Contextual toolbar groups (states, variables, graph) - visually distinct */
    .toolbar-context-container { display: inline-flex; align-items: center; gap:6px; }
    .toolbar-context { background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.03); border-radius:6px; padding:4px 6px; }
    .choices-section table select {
        height: 26px !important;
        padding: 0 5px !important;
        line-height: 26px !important;
    }
    .hide-cell { 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        padding: 0 5px !important; 
    }

    .hide-cell input[type="checkbox"] {
        height: 26px !important;
        width: 60px !important;
        margin: 0 !important;
    }
    
    /* Status window behaves like a dropdown now (anchored to toolbar).
       Use the shared `.dropdown-menu` visual language and force 50% width. */
    #status-window.dropdown-menu {
        display: none;
        position: fixed; /* will be positioned by `toggleDropdown` */
        width: 50%;
        max-width: 90vw;
        min-width: 320px;
        max-height: 50vh;
        overflow: auto;
        z-index: 110;
    }

    #status-handle {
        cursor: default;
        padding: 8px 10px;
        text-align: left;
        border-bottom: 1px solid rgba(255,255,255,0.03);
        font-weight: 700;
        font-size: 13px;
        background: transparent;
    }

    #play-error {
        padding: 8px 10px;
        font-size: 12px;
        color: #D4D4D4;
        background: transparent;
        border-bottom: 1px solid rgba(255,255,255,0.03);
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-y: auto;
        max-height: 80px;
    }
    #play-error:empty { display: none; }

    #status-content {
        padding: 8px 10px;
        font-size: 12px;
        color: #D4D4D4;
        background: transparent;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    /* ------------------------------------------------------------------
       Unified menu styles
       Define a small set of CSS variables and a single rule that applies
       the same visual language to all dropdowns and context menus so
       they look and feel identical (states view context menu is the
       canonical appearance).
       This rule is placed after the other menu rules so it overrides
       duplicate properties and ensures visual consistency.
       ------------------------------------------------------------------ */
    :root {
        /* 50% transparent canonical menu background with blur backdrop */
        --menu-bg: rgba(17,17,17,0.5);
        --menu-border: 1px solid rgba(255,255,255,0.03);
        --menu-shadow: 0 8px 20px rgba(0,0,0,0.6);
        --menu-padding: 6px;
        --menu-radius: 6px;
        --menu-color: #D4D4D4;
        --menu-backdrop: blur(8px);
        --menu-hover-bg: linear-gradient(135deg, rgba(0,123,176,0.6) 0%, rgba(0,123,176,0.8) 100%);
        --menu-hover-icon: #00AbC0;
    }

    /* Apply unified variables to all known menu-like selectors */
    .dropdown-menu,
    #context-menu,
    #graph-context-menu,
    .dropdown-list,
    #token-menu-list,
    #status-window {
        /* Use semi-transparent background and a subtle gradient overlay to match the canonical look */
        background: linear-gradient(0deg, rgba(17,17,17,0.5), rgba(34,34,34,0.5)) !important;
        border: var(--menu-border) !important;
        box-shadow: var(--menu-shadow) !important;
        padding: var(--menu-padding) !important;
        border-radius: var(--menu-radius) !important;
        color: var(--menu-color) !important;
        backdrop-filter: var(--menu-backdrop) !important;
        -webkit-backdrop-filter: var(--menu-backdrop) !important;
    }

    /* Ensure menus are interactive inside draggable header areas in Electron */
    .dropdown-menu,
    #undo-dropdown,
    #language-dropdown,
    #help-dropdown,
    #status-window,
    #graph-context-menu,
    #context-menu {
        -webkit-app-region: no-drag !important;
        pointer-events: auto !important;
    }

    /* Unified hover for real menu items across different menu implementations.
       Exclude category headers and empty/separator list items (they shouldn't highlight). */
    .dropdown-menu button:hover,
    #context-menu li:not(.menu-category):has(*):hover,
    #graph-context-menu li:not(.menu-category):has(*):hover,
    .dropdown-list li:has(*):hover,
    #token-menu-list li:has(*):hover,
    #status-window .button-container button:hover {
        color: #FFF !important;
        background: var(--menu-hover-bg) !important;
        box-shadow: inset 30px 0px 40px rgba(0,123,176,0.6) !important;
    }

    /* Icons in menus adopt the unified hover tint */
    .dropdown-menu button:hover i,
    #context-menu li:not(.menu-category):has(*):hover i,
    #graph-context-menu li:not(.menu-category):has(*):hover i,
    .dropdown-list li:has(*):hover i,
    #token-menu-list li:has(*):hover i {
        color: var(--menu-hover-icon) !important;
    }

    /* Ensure Font Awesome and SVG icons inside menus render correctly and inherit color */
    .dropdown-menu i,
    .dropdown-menu .fa,
    .dropdown-menu .fas,
    #context-menu i,
    #context-menu .fa,
    #context-menu .fas,
    #graph-context-menu i,
    #graph-context-menu .fa,
    #graph-context-menu .fas,
    .dropdown-list i,
    .dropdown-list .fa,
    #token-menu-list i,
    #token-menu-list .fa,
    #status-window i,
    #status-window .fa {
        color: inherit !important;
        opacity: 1 !important;
        filter: none !important;
        font-size: 13px !important;
        line-height: 1 !important;
        display: inline-block !important;
        width: 18px !important;
        text-align: center !important;
    }

    /* Force Font Awesome font family for icons inside menus (solid/regular/brands) */
    .dropdown-menu .fa,
    .dropdown-menu .fas,
    .dropdown-menu .far,
    .dropdown-menu .fab,
    #context-menu .fa,
    #context-menu .fas,
    #context-menu .far,
    #context-menu .fab,
    #graph-context-menu .fa,
    #graph-context-menu .fas,
    #graph-context-menu .far,
    #graph-context-menu .fab {
        font-family: "Font Awesome 6 Free", "Font Awesome 6 Brands", sans-serif !important;
        font-style: normal !important;
        font-variant: normal !important;
        text-rendering: auto !important;
        -webkit-font-smoothing: antialiased !important;
        -moz-osx-font-smoothing: grayscale !important;
    }
    /* Brands use the Brands family and normal weight */
    .fab { font-family: "Font Awesome 6 Brands" !important; font-weight: 400 !important; }
    /* Solid icons require heavier weight */
    .fas { font-weight: 900 !important; }

    /* Pseudo-element rules (Font Awesome uses ::before) */
    .dropdown-menu i::before,
    .dropdown-menu .fa::before,
    #context-menu i::before,
    #context-menu .fa::before,
    #graph-context-menu i::before,
    #graph-context-menu .fa::before {
        color: inherit !important;
        opacity: 1 !important;
    }

    /* Ensure SVG icons fill with currentColor */
    .dropdown-menu svg,
    #context-menu svg,
    #graph-context-menu svg,
    .dropdown-list svg,
    #token-menu-list svg {
        fill: currentColor !important;
        color: inherit !important;
        width: 18px !important;
        height: 18px !important;
    }
    
    /* Ensure internal menu structure (labels, categories, list items) also follow unified style */
    .dropdown-menu *,
    #context-menu *,
    #graph-context-menu *,
    .dropdown-list *,
    #token-menu-list *,
    #status-window * {
        box-sizing: border-box;
        color: var(--menu-color) !important;
        font-family: inherit !important;
    }

    /* Normalize lists inside menus */
    .dropdown-menu ul,
    #context-menu ul,
    #graph-context-menu ul,
    .dropdown-list,
    #token-menu-list,
    #status-window ul {
        list-style: none;
        margin: 0;
        padding: 0;
        overflow: auto;
    }

    /* Generic menu row */
    .dropdown-menu li,
    #context-menu li,
    #graph-context-menu li,
    .dropdown-list li,
    #token-menu-list li,
    #status-window li,
    .dropdown-menu button,
    #status-window .button-container button {
        display: flex !important;
        align-items: center !important;

    /* Explicitly neutralize separators and non-interactive boundary labels so they
       never receive hover styling or pointer events (they are visual only). */
    .menu-separator,
    .history-boundary {
        pointer-events: none !important;
        background: transparent !important;
        color: inherit !important;
    }
        gap: 8px !important;
        width: 100% !important;
        text-align: left !important;
        justify-content: flex-start !important;
        padding: 8px 10px !important;
        background: transparent !important;
        color: var(--menu-color) !important;
        border: none !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: background-color 0.14s ease, color 0.14s ease, box-shadow 0.14s ease;
    }

    /* Ensure buttons and li inside menus accept pointer events (override app-region effects) */
    .dropdown-menu li,
    .dropdown-menu li button,
    .dropdown-menu button,
    #undo-dropdown li,
    #undo-dropdown li button {
        pointer-events: auto !important;
    }

    /* History item layout: title on the left, description aligned to the right.
       Use flex row with space-between so titles and details occupy their sides. */
    .history-item {
        display: flex !important;
        flex-direction: row !important;
        align-items: center !important;
        justify-content: space-between !important;
        gap: 12px !important;
        padding: 10px 12px !important;
        background: transparent !important;
        color: var(--menu-color) !important;
        border-radius: 4px !important;
        width: 100% !important;
        text-align: left !important;
    }
    .history-item .history-title {
        font-weight: 600 !important;
        font-size: 13px !important;
        color: rgba(255,255,255,0.95) !important;
        line-height: 1.1 !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        display: block !important;
        flex: 1 1 auto !important;
        text-align: left !important;
    }
    .history-item .history-detail {
        font-size: 12px !important;
        color: rgba(255,255,255,0.35) !important;
        line-height: 1.15 !important;
        font-weight: 400 !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        flex: 0 0 auto !important;
        margin-left: 8px !important;
        text-align: right !important;
        max-width: 55% !important;
    }
    /* Reduce empty spacing between list items while preserving visual separation */
    #undo-dropdown .menu-category-items { padding: 6px !important; }
    #history-list li { padding: 0 !important; margin: 2px 0 !important; }

    /* Icon area: fixed small width so text can use rest of the row */
    .dropdown-menu li i,
    .dropdown-menu button i,
    #context-menu li i,
    #graph-context-menu li i {
        flex: 0 0 20px !important;
        width: 20px !important;
        text-align: center !important;
    }

    /* Ensure textual content uses remaining space and is left-aligned */
    .dropdown-menu li span,
    .dropdown-menu button span,
    #context-menu li span,
    #graph-context-menu li span,
    .dropdown-list li span {
        display: block !important;
        flex: 1 1 auto !important;
        text-align: left !important;
    }

    /* History list separators and boundary marker */
    #history-list { padding: 0 !important; }
    /* Thin separators between rows (but not the visual boundary) */
    #history-list li:not(.history-boundary) { border-bottom: 1px solid rgba(255,255,255,0.03) !important; }
    /* Visual boundary showing the current historyIndex */
    #history-list li.history-boundary {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 6px 8px !important;
        color: rgba(200,200,200,0.75) !important;
        font-size: 11px !important;
        text-transform: uppercase !important;
        letter-spacing: 0.6px !important;
        background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)) !important;
        pointer-events: none !important;
    }

    /* Category title / label inside menus (not interactive) */
    .dropdown-menu .menu-category-title,
    .dropdown-menu .menu-category,
    #context-menu li.menu-category,
    #graph-context-menu li.menu-category,
    .dropdown-menu .menu-category-title * {
        font-size: 11px !important;
        color: rgba(207,207,207,0.85) !important;
        text-transform: uppercase !important;
        letter-spacing: 0.6px !important;
        font-weight: 700 !important;
        cursor: default !important;
        pointer-events: none !important;
        background: transparent !important;
        padding: 6px 8px !important;
        margin: 0 !important;
    }
    /* Put category title above items (stacked) so items can take full width.
       Some menu styles elsewhere lay out category title and items side-by-side;
       force a stacked layout for cleaner history dropdowns. */
    .dropdown-menu .menu-category {
        display: block !important;
        width: 100% !important;
    }
    .dropdown-menu .menu-category-title {
        display: block !important;
        width: 100% !important;
        margin-bottom: 8px !important;
        padding: 8px 12px !important;
    }
    .dropdown-menu .menu-category-items {
        display: block !important;
        padding-left: 0 !important;
    }

    /* Prevent category rows from being highlighted like items */
    #context-menu li.menu-category:hover,
    .dropdown-menu .menu-category:hover,
    #graph-context-menu li.menu-category:hover {
        background: transparent !important;
        box-shadow: none !important;
        color: rgba(207,207,207,0.85) !important;
    }

    /* Inputs inside menus (search fields) use the unified look */
    .dropdown-menu input[type="text"],
    #context-menu input[type="text"],
    #graph-context-menu input[type="text"],
    #status-window input[type="text"] {
        background: transparent !important;
        border: 1px solid rgba(255,255,255,0.03) !important;
        border-radius: 4px !important;
        color: var(--menu-color) !important;
        padding: 6px 8px !important;
        width: 100% !important;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.02) !important;
    }

    /* Disabled / non-interactive items appearance */
    .dropdown-menu button[disabled],
    .dropdown-menu .disabled,
    #context-menu li.disabled,
    #graph-context-menu li.disabled,
    .dropdown-list li.disabled {
        opacity: 0.6 !important;
        cursor: not-allowed !important;
        color: rgba(200,200,200,0.6) !important;
        background: transparent !important;
        box-shadow: none !important;
    }

    /* Ensure icons/text alignment inside token / example rows */
    #context-menu li .token,
    #context-menu li .example,
    #token-menu-list li .token,
    #token-menu-list li .example {
        color: var(--menu-color) !important;
    }

    /* Small safety: keep menu radiuses consistent where other rules tried to remove them */
    .dropdown-menu, #context-menu, #graph-context-menu, .dropdown-list, #token-menu-list, #status-window {
        border-radius: var(--menu-radius) !important;
    }

    /* Force-hide elements when the `hidden` attribute is used. Using `hidden` plus
       an !important rule makes hiding robust against other CSS that may try to
       override inline `display` styles in complex menus. Applies broadly to
       dropdowns, token menus and language/button lists. */
    .dropdown-menu [hidden],
    .dropdown-list [hidden],
    #context-menu [hidden],
    #token-menu-list [hidden],
    #graph-context-menu [hidden] {
        display: none !important;
    }
    /* Also ensure buttons hidden inside language menus and other button-based
       dropdowns are removed from layout (some menus render items as buttons). */
    .button-container button[hidden],
    .dropdown-menu button[hidden] {
        display: none !important;
    }
</style>
</head>
<body>
    <div id="splash-screen">
        <img src="icon_transparent.png" data-i18n-alt="title" alt="NS2 Editor Logo">
        <h1>NS2 Editor</h1>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>
    <div class="header">
        <div class="header-left" style="display:flex;align-items:center;gap:8px;min-width:0;">
            <img src="icon_transparent.png" data-i18n-alt="title" alt="Icon" style="height: 26px; width: auto;">
            <div class="toolbar-separator" aria-hidden="true" style="margin-left:6px;margin-right:6px;">|</div>
            <div id="toolbar-story-title" class="toolbar-story-title" style="margin-right:6px;min-width:0;">&nbsp;</div>
        </div>
        <div class="header-center" style="display:flex;align-items:center;gap:8px;flex:1 1 auto;min-width:0;">
            <div id="global-toolbar" class="toolbar no-drag" style="flex:1 1 auto;min-width:0;"></div>
            <!-- dropdown containers kept in DOM; toolbar buttons will toggle them -->
            <div class="dropdown-menu" id="language-dropdown">
                <!-- Dynamically populated -->
            </div>
            <div class="dropdown-menu" id="undo-dropdown" style="display:none; min-width:260px;">
                <div class="menu-category">
                    <div class="menu-category-title">History</div>
                    <div class="menu-category-items" style="max-height:360px; overflow:auto; padding:4px;">
                        <ul id="history-list" style="list-style:none; margin:0; padding:0;"></ul>
                    </div>
                </div>
            </div>
            <div class="dropdown-menu" id="help-dropdown" style="display:none">
                <div class="menu-category">
                    <div class="menu-category-title">Documentation</div>
                    <div class="menu-category-items">
                        <button onclick="openHelp('guide')"><i class="fas fa-book"></i> <span data-i18n="guide">Guide...</span></button>
                        <button onclick="openHelp('ai')"><i class="fas fa-robot"></i> <span data-i18n="ai">AI...</span></button>
                    </div>
                </div>
                <div class="menu-category">
                    <div class="menu-category-title">About</div>
                    <div class="menu-category-items">
                        <button onclick="openHelp('about')"><i class="fas fa-info-circle"></i> <span data-i18n="about">About...</span></button>
                    </div>
                </div>
            </div>
        </div>
        <div class="header-right" style="display:flex;align-items:center;gap:6px;flex:0 0 auto;">
            <!-- window control buttons (Electron only) -->
            <div id="window-controls" class="window-controls no-drag" style="display:none;">
                <button id="win-min" class="icon-button" title="Minimize"><i class="fas fa-window-minimize"></i></button>
                <button id="win-max" class="icon-button" title="Maximize"><i class="fas fa-square-full"></i></button>
                <button id="win-close" class="icon-button" title="Close"><i class="fas fa-times"></i></button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".ns2" onchange="loadFile()">

    <datalist id="state-list"></datalist>
    <datalist id="token-list"></datalist>

    <div id="editor">
        <div class="tabs">
            <button class="tab-button" data-i18n="text" onclick="openTab('text')">Text</button>
            <button class="tab-button active" data-i18n="metadata" onclick="openTab('metadata')">Metadata</button>
            <button class="tab-button" data-i18n="variables" onclick="openTab('variables')">Variables</button>
            <button class="tab-button" onclick="openTab('states')" data-i18n="states">States</button>
            <button class="tab-button" onclick="openTab('graph')" data-i18n="graph">Graph</button>
            <button class="tab-button" onclick="openTab('play')" data-i18n="play">Play</button>
        </div>

        <!-- toolbar was moved into the header menubar -->

        <div id="tab-text" class="tab-content">
            <div id="text-editor"></div>
        </div>

        <div id="tab-metadata" class="tab-content active">
            <div class="section">
                <div class="grid-form">
                    <label data-i18n="titleLabel:">Title:</label> <input type="text" id="story-title">
                    <label data-i18n="desc:">Description:</label> <textarea id="story-description"></textarea>
                    <label data-i18n="start:">Start:</label> <input id="start-state" list="state-list">
                </div>
            </div>
        </div>

        <div id="tab-variables" class="tab-content">
            <div class="section" style="flex: 1; overflow-y: auto;">
                <div class="toolbar">
                    <input type="text" id="var-search" data-i18n-placeholder="searchVars" oninput="filterVariables()">
                    <button class="icon-button" onclick="addVariable()" data-i18n-title="addVariable" title="Add Variable"><i class="fas fa-plus"></i></button>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="type">Type</th>
                            <th data-i18n="name">Name</th>
                            <th data-i18n="initial">Initial</th>
                            <th data-i18n="constraint">Constraint</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="variables-list"></tbody>
                </table>
            </div>
        </div>

        <div id="tab-states" class="tab-content">
            <div class="states-container">
                <div class="states-list-panel">
                    <div class="toolbar">
                        <input type="text" id="state-search" data-i18n-placeholder="searchStates" oninput="filterStates()">
                        <button class="icon-button" onclick="addState()" data-i18n-title="addState" title="Add State"><i class="fas fa-plus"></i></button>
                    </div>
                    <ul id="states-list"></ul>
                </div>
                <div id="state-details" class="state-details-panel"></div>
            </div>
        </div>

        <div id="tab-graph" class="tab-content">
            <div id="graph-container"></div>
        </div>

        <div id="tab-play" class="tab-content">
            <input type="file" id="load-save" accept=".save" onchange="loadProgress()">
            <div class="play-content">
                <h2 id="play-title"></h2>
                <p id="play-desc"></p>
                <div class="play-choices-toolbar">
                    <input type="text" id="choice-search-play" data-i18n-placeholder="searchChoices" oninput="filterPlayChoices()">
                </div>
                <div id="play-choices" class="choices"></div>
                <h3 data-i18n="variables">Variables</h3>
                <div class="play-vars-toolbar">
                    <input type="text" id="play-var-search" data-i18n-placeholder="Search variables..." oninput="filterPlayVars()">
                </div>
                <div id="play-variables"></div>
            </div>
        </div>
    </div>

    <div id="status-window" class="dropdown-menu" style="display:none;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
            <div id="status-handle" data-i18n="statusHandle">Status</div>
            <div class="status-actions" style="display:flex;gap:6px;align-items:center;">
                <button id="status-copy" class="icon-button" title="Copy status"><i class="fas fa-copy"></i></button>
            </div>
        </div>
            <div id="play-error" data-i18n="errorLabel">Error</div>
            <div id="status-content" data-i18n="readyLabel">Ready</div>
    </div>

    <div id="context-menu">
        <input type="text" id="context-search" data-i18n-placeholder="searchTokens" oninput="filterContextMenu()">
        <ul id="token-menu-list"></ul>
    </div>

    <div id="graph-context-menu">
        <!-- Context menu items will be injected dynamically -->
    </div>

    

    <script>
        let languages = {};
        let currentLanguage = 'en';

        (async () => {
            const splashStart = performance.now();  // <-- start timer for minimum 1-second splash

            await loadLanguages();
            await initModule();
            editorEngine = Module._CreateEngine();
            const savedContent = localStorage.getItem('ns2_content');
            if (savedContent) {
                Module.FS.writeFile('/story.ns2', savedContent);
                const pathPtr = allocateUTF8('/story.ns2');
                const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                Module._free(pathPtr);
                if (loaded) {
                    setStatus(languages[currentLanguage]['loadedSavedFromLocal'] || "Loaded saved story from local storage");
                } else {
                    setStatus((languages[currentLanguage]['failedLoadSavedStory'] || "Failed to load saved story: {err}").replace('{err}', getLastError(editorEngine)));
                }
            }
            renderEditor();
            openTab('metadata');
            updateGlobalToolbar('metadata');

            window.addEventListener('storage', (event) => {
                if (event.key === 'ns2_content' && event.newValue) {
                    Module.FS.writeFile('/story.ns2', event.newValue);
                    const pathPtr = allocateUTF8('/story.ns2');
                    const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                    Module._free(pathPtr);
                    if (loaded) {
                        renderEditor();
                        setStatus(languages[currentLanguage]['storyUpdatedFromStorage'] || "Story updated from storage");
                    } else {
                        setStatus((languages[currentLanguage]['failedUpdateFromStorage'] || "Failed to update story from storage: {err}").replace('{err}', getLastError(editorEngine)));
                    }
                }
            });

            // ----- Hide splash as soon as initialization finishes (no artificial wait) -----
            // If initialization took long, the splash stays visible until now; if it was fast,
            // we remove it immediately so the app loads as fast as possible while still
            // showing the loading screen if necessary.
            (function hideSplashNow(){
                const splash = document.getElementById('splash-screen');
                if (splash) {
                    splash.classList.add('hidden');
                    setTimeout(() => {
                        if (splash) splash.remove();
                    }, 700); // match transition duration + a little buffer
                }
            })();
            // ------------------------------------------------------------------
        })();
        (function(){
            // Wire custom window controls when running in Electron
            if(!window || !window.electronAPI) return;
            try{
                const wc = document.getElementById('window-controls');
                if(!wc) return;
                wc.style.display = 'flex';
                const btnMin = document.getElementById('win-min');
                const btnMax = document.getElementById('win-max');
                const btnClose = document.getElementById('win-close');
                if(btnMin) btnMin.addEventListener('click', () => { try{ window.electronAPI.minimize(); }catch(e){} });
                if(btnMax) btnMax.addEventListener('click', async () => { try{ const res = await window.electronAPI.toggleMaximize(); if(res && typeof res.maximized !== 'undefined') updateMaxIcon(res.maximized); }catch(e){} });
                if(btnClose) btnClose.addEventListener('click', () => { try{ window.electronAPI.closeWindow(); }catch(e){} });
                function updateMaxIcon(max){
                    try{
                        const i = btnMax && btnMax.querySelector('i');
                        if(i) i.className = max ? 'fas fa-clone' : 'fas fa-square-full';
                    }catch(e){}
                }
                // listen for maximize/unmaximize events forwarded from main
                if(window.electronWindowEvents && typeof window.electronWindowEvents.onMaximize === 'function'){
                    window.electronWindowEvents.onMaximize((isMax)=> updateMaxIcon(isMax));
                }
                // double-click header toggles maximize
                const header = document.querySelector('.header');
                if(header) header.addEventListener('dblclick', () => { try{ window.electronAPI.toggleMaximize(); }catch(e){} });
            }catch(e){ console.warn('window-controls wiring failed', e); }
        })();

        async function loadLanguages() {
            try {
                const response = await fetch('languages.json');
                languages = await response.json();
                // Add missing keys
                const missingKeys = ['file', 'edit', 'language', 'view', 'toggleStatus'];
                Object.keys(languages).forEach(lang => {
                    missingKeys.forEach(key => {
                        if (!languages[lang][key]) {
                            languages[lang][key] = languages['en'][key] || key.charAt(0).toUpperCase() + key.slice(1);
                        }
                    });
                });
                populateLanguageMenu();
                setLanguage(currentLanguage);
            } catch (e) {
                console.error('Failed to load languages.json', e);
            }
        }

        function populateLanguageMenu() {
            const langMenu = document.getElementById('language-dropdown');
            langMenu.innerHTML = '';
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = languages[currentLanguage] && languages[currentLanguage]['search'] ? languages[currentLanguage]['search'] : 'Search...';
            searchInput.oninput = function() {
                const raw = this.value || '';
                const query = normalizeForMatching(raw).toLowerCase();
                Array.from(langMenu.querySelectorAll('.button-container button')).forEach(btn => {
                    const text = normalizeForMatching(btn.textContent || '').toLowerCase();
                    try { btn.hidden = !text.includes(query); } catch (e) { btn.style.display = text.includes(query) ? 'flex' : 'none'; }
                });
            };

            // Helper to register Monarch provider while injecting dynamic state-name regexes
            function setNs2Monarch(baseDef) {
                try {
                    const origTokenizer = baseDef.tokenizer || {};

                    // Build a safe state-name rule for root only (no /g flags)
                    let stateRule = null;
                    if (Array.isArray(stateTokens) && stateTokens.length > 0) {
                        const escaped = stateTokens.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'));
                        const pattern = '\\b(' + escaped.join('|') + ')\\b';
                        stateRule = [new RegExp(pattern), 'ns2.state'];
                    }
                    // Build a variable-name rule to highlight variables anywhere (if available)
                    let variableRule = null;
                    if (Array.isArray(variableTokens) && variableTokens.length > 0) {
                        const escapedVars = variableTokens.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'));
                        try {
                            variableRule = [new RegExp('\\b(' + escapedVars.join('|') + ')\\b'), 'ns2.variable'];
                        } catch (e) {
                            variableRule = null;
                        }
                    }

                    // Bracket rule to enter script state; inject into every tokenizer state so '[' works everywhere
                    const bracketRule = [/\[/, { token: 'ns2.squarebracket', next: '@script' }];
                    // Arrow rule: prefer a forced match against known state names so targets are highlighted reliably
                    // Use two capture groups: the arrow + whitespace, and then the state name — tokens array must match groups
                    let arrowRule = [/(\-\>\s*)([A-Za-z0-9_\-]+)/, ['ns2.punct', 'ns2.state']];
                    if (Array.isArray(stateTokens) && stateTokens.length > 0) {
                        const escapedStates = stateTokens.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'));
                        try {
                            const arrowPattern = '(\\-\\>\\s*)(' + escapedStates.join('|') + ')\\b';
                            arrowRule = [new RegExp(arrowPattern), ['ns2.punct', 'ns2.state']];
                        } catch (e) {
                            // fallback to generic arrow rule
                            arrowRule = [/(\-\>\s*)([A-Za-z0-9_\-]+)/, ['ns2.punct', 'ns2.state']];
                        }
                    }

                    // Clone tokenizer states and prepend arrow/bracket/variable rules so they match everywhere
                    const newTokenizer = {};
                    Object.keys(origTokenizer).forEach(stateName => {
                        const rules = Array.isArray(origTokenizer[stateName]) ? origTokenizer[stateName].slice() : [];
                        // variable rule should be first so variables are recognized inside scripts/choices
                        if (variableRule) rules.unshift(variableRule);
                        // Ensure arrowRule then bracket rule so '-> target' and '[' are recognized everywhere
                        rules.unshift(bracketRule);
                        rules.unshift(arrowRule);
                        // If this is root and we have stateRule, add it after arrow/bracket/variable rules
                        if (stateName === 'root' && stateRule) {
                            rules.unshift(stateRule);
                        }
                        newTokenizer[stateName] = rules;
                    });

                    const provider = Object.assign({}, baseDef, { tokenizer: newTokenizer });
                        // Validate tokenizer rules: ensure regex capture groups match token array lengths
                        try {
                            Object.keys(provider.tokenizer).forEach(stateName => {
                                const rules = provider.tokenizer[stateName] || [];
                                rules.forEach((rule, idx) => {
                                    if (Array.isArray(rule) && rule.length >= 2) {
                                        const pattern = rule[0];
                                        const tokens = rule[1];
                                        if (pattern && pattern instanceof RegExp && Array.isArray(tokens)) {
                                            // count capturing groups (simple heuristic: count '(' not followed by '?:')
                                            const src = pattern.source || '';
                                            let groups = 0;
                                            for (let i = 0; i < src.length; i++) {
                                                if (src[i] === '(' && src[i+1] !== '?' ) groups++;
                                            }
                                            if (groups !== tokens.length) {
                                                console.warn('[ns2] Monarch rule mismatch in state', stateName, 'ruleIndex', idx, 'groups', groups, 'tokens', tokens.length, 'pattern', pattern, 'tokensArr', tokens);
                                            }
                                        }
                                    }
                                });
                            });
                        } catch(e) { console.warn('[ns2] tokenizer validation failed', e); }
                        monaco.languages.setMonarchTokensProvider('ns2', provider);
                    console.debug('[ns2] setNs2Monarch: registered provider with', (stateTokens||[]).length, 'state tokens');
                } catch (e) {
                    console.error('[ns2] setNs2Monarch failed', e);
                    monaco.languages.setMonarchTokensProvider('ns2', baseDef);
                }
            }

            
            searchInput.addEventListener('click', e => e.stopPropagation());
            langMenu.appendChild(searchInput);
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            langMenu.appendChild(buttonContainer);
            Object.keys(languages).forEach(lang => {
                const button = document.createElement('button');
                button.onclick = () => setLanguage(lang);

                const emojiSpan = document.createElement('span');
                emojiSpan.className = 'flag';
                emojiSpan.textContent = languages[lang].flag || '';

                // Map regional indicator emoji to ISO country code (e.g. 🇬🇧 -> gb)
                function emojiToISO(flagEmoji) {
                    try {
                        const chars = Array.from(flagEmoji);
                        if (chars.length !== 2) return null;
                        const letters = chars.map(ch => {
                            const cp = ch.codePointAt(0);
                            if (cp >= 0x1F1E6 && cp <= 0x1F1FF) return String.fromCharCode(cp - 0x1F1E6 + 65);
                            return null;
                        });
                        if (letters[0] && letters[1]) return (letters.join('')).toLowerCase();
                    } catch (e) {}
                    return null;
                }

                const iso = emojiToISO(languages[lang].flag || '');
                if (iso) {
                    const img = document.createElement('img');
                    img.className = 'flag-img';
                    img.alt = (languages[lang].languageName || lang) + ' flag';
                    img.src = `https://flagcdn.com/w40/${iso}.png`;
                    img.onload = () => { try { emojiSpan.style.display = 'none'; } catch(e){} };
                    img.onerror = () => { try { img.style.display = 'none'; } catch(e){} };
                    button.appendChild(img);
                }

                button.appendChild(emojiSpan);
                button.appendChild(document.createTextNode(' ' + (languages[lang].languageName || lang)));
                buttonContainer.appendChild(button);
            });
        }

        function setLanguage(lang) {
            if (!languages[lang]) {
                console.warn(`Language ${lang} not found, falling back to 'en'`);
                lang = 'en';
            }
            currentLanguage = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = languages[lang][key] || key;
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                el.placeholder = languages[lang][key] || key;
            });
            document.querySelectorAll('[data-i18n-alt]').forEach(el => {
                const key = el.getAttribute('data-i18n-alt');
                try { el.alt = languages[lang][key] || key; } catch(e) {}
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                el.title = languages[lang][key] || key;
            });
        }

        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.51.0/min/vs' } });

        let textEditor;
        let stateScriptEditor;

        mermaid.initialize({ 
            startOnLoad: false, 
            theme: 'dark',
            flowchart: {
                diagramPadding: 20,
                nodeSpacing: 50,
                rankSpacing: 240
            }
        });

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }

        function normalizeForMatching(s) {
            if (!s) return '';
            // decode basic HTML entities using a textarea (works in browser)
            try {
                const ta = document.createElement('textarea');
                ta.innerHTML = s;
                s = ta.value;
            } catch (e) {}
            // collapse whitespace and trim
            return s.replace(/\s+/g, ' ').trim();
        }

        // Debug helper removed in production build.

        let Module;
        let editorEngine;
        let playEngine;
        let currentGraphState = null;
        let tokens = [];
        let currentInput = null;
        let graphSelectedState = null;
        let stateTokens = [];
        let variableTokens = [];
        let functionTokens = ['set', 'reset', 'not', 'visited', 'get', 'dice', 'min', 'max', 'abs', 'sqrt', 'chance', 'if'];
        let operatorTokens = ['+', '-', '*', '/', 'or', 'and', '>=', '<=', '!=', '==', '>', '<', '='];
        let constantTokens = ['true', 'false'];
        let textApplyTimer = null;
        let textEditorAutoApplyAttached = false;

        const tokenExamples = {
            'set': 'set(health, get(health) + 5)',
            'reset': 'reset(state_name)',
            'not': 'not(visited(state))',
            'visited': 'visited(state_name)',
            'get': 'get(variable_name)',
            'dice': 'dice(1, 6)',
            'min': 'min(5, get(value))',
            'max': 'max(10, get(value))',
            'abs': 'abs(-3.5)',
            'sqrt': 'sqrt(16)',
            'chance': 'chance(50)',
            'if': 'if(visited(state), 1, 0)',
            '+': 'get(a) + get(b)',
            '-': 'get(a) - get(b)',
            '*': 'get(a) * get(b)',
            '/': 'get(a) / get(b)',
            'or': 'visited(a) or visited(b)',
            'and': 'visited(a) and visited(b)',
            '>=': 'get(a) >= 10',
            '<=': 'get(a) <= 5',
            '!=': 'get(a) != get(b)',
            '==': 'get(a) == get(b)',
            '>': 'get(a) > 0',
            '<': 'get(a) < 100',
            '=': 'get(a) = 42',
            'true': '',
            'false': ''
        };

        let graphPanZoom;
        let graphCurrentScale = 1;

        // Program-wide history (single array + index pointer).
        // Stores actions as { undo: fn, redo: fn, description?: string }
        // historyIndex is the position AFTER the last executed action (i.e. next redo index).
        const programHistory = [];
        let historyIndex = 0;
        const programHistoryLimit = 200;
        let __suppressProgramPush = false;
        // When true, commitFocusedChange will ignore the next blur/change
        // This is used to prevent accidental pushes when clicking history items
        // (mousedown/focus sequence can trigger blur on an input before our
        // history navigation runs). We clear the flag after handling.
        let __suppressCommitOnBlur = false;

        function pushProgramAction(action) {
            // action: { undo: fn, redo: fn, description?: string }
            if (!action || (typeof action.undo !== 'function') || (typeof action.redo !== 'function')) return;
            if (__suppressProgramPush) return;
            // truncate history if we've undone some actions
            if (historyIndex < programHistory.length) {
                programHistory.length = historyIndex;
            }
            programHistory.push(action);
            // enforce limit
            while (programHistory.length > programHistoryLimit) {
                programHistory.shift();
                if (historyIndex > 0) historyIndex--;
            }
            historyIndex = programHistory.length;
            updateUndoDropdown();
            updateToolbarUndoButtons();
        }

        // Helper: create a short, single-line summary of a value for history details
        function summarizeForHistory(v, maxLen=60) {
            try {
                if (v === null || typeof v === 'undefined') return '';
                let s = String(v);
                // collapse whitespace and newlines
                s = s.replace(/\s+/g, ' ').trim();
                if (s.length > maxLen) return s.slice(0, maxLen-1) + '…';
                return s;
            } catch (e) { return '';} 
        }

        function undoProgram() {
            if (historyIndex === 0) return false;
            historyIndex--;
            const action = programHistory[historyIndex];
            try { __suppressProgramPush = true; action.undo(); } catch (e) { console.warn('undo action failed', e); } finally { __suppressProgramPush = false; }
            // Ensure the UI reflects the new program state
            try { refreshView(); } catch (e) {}
            updateUndoDropdown();
            updateToolbarUndoButtons();
            return true;
        }

        function redoProgram() {
            if (historyIndex >= programHistory.length) return false;
            const action = programHistory[historyIndex];
            try { __suppressProgramPush = true; action.redo(); } catch (e) { console.warn('redo action failed', e); } finally { __suppressProgramPush = false; }
            historyIndex++;
            // Ensure the UI reflects the new program state
            try { refreshView(); } catch (e) {}
            updateUndoDropdown();
            updateToolbarUndoButtons();
            return true;
        }

        // Navigate to an explicit history index without mutating the history array.
        // targetIndex is the new historyIndex (position AFTER last executed action).
        // This function performs the required undo() or redo() calls while
        // suppressing program pushes so the history array is unchanged.
        function navigateHistoryTo(targetIndex) {
            try {
                if (typeof targetIndex !== 'number') return;
                if (targetIndex < 0) targetIndex = 0;
                if (targetIndex > programHistory.length) targetIndex = programHistory.length;
                if (targetIndex === historyIndex) return;
                __suppressProgramPush = true;
                if (targetIndex < historyIndex) {
                    // need to undo actions from historyIndex-1 down to targetIndex
                    for (let i = historyIndex - 1; i >= targetIndex; i--) {
                        try { programHistory[i].undo(); } catch (e) { console.warn('navigate undo failed', e); }
                    }
                } else {
                    // need to redo actions from historyIndex up to targetIndex-1
                    for (let i = historyIndex; i < targetIndex; i++) {
                        try { programHistory[i].redo(); } catch (e) { console.warn('navigate redo failed', e); }
                    }
                }
            } finally {
                __suppressProgramPush = false;
            }
            historyIndex = targetIndex;
            try { refreshView(); } catch (e) {}
            updateUndoDropdown();
            updateToolbarUndoButtons();
        }

        function refreshView() {
            try {
                // Re-render lists and tokens so UI matches the current editorEngine state
                updateTokens();
                populateStateDatalist();
                populateTokenDatalist();
                renderVariables();
                renderStates();
                // Keep editor form fields in sync
                try { renderEditor(); } catch (e) {}
                // If we're currently on the play tab, update play UI immediately
                try { if (currentTab === 'play') updatePlay(); } catch (e) {}
                // If graph tab is active, re-render graph
                try { if (currentTab === 'graph') renderGraph(); } catch (e) {}
            } catch (e) { console.warn('refreshView failed', e); }
        }

        // Live-update helpers: update visible list items as the user types without mutating the engine
        function liveUpdateStateName(originalName, liveValue) {
            try {
                const li = document.querySelector(`#states-list li[data-name="${originalName}"]`);
                if (li) {
                    const span = li.querySelector('.state-name');
                    if (span) span.textContent = liveValue;
                }
                // also update any datalist option visually (doesn't change engine)
                const opts = document.querySelectorAll('#state-list option');
                opts.forEach(opt => { if (opt.value === originalName) opt.value = liveValue; });
            } catch (e) {}
        }

        function liveUpdateStateTitle(name, liveTitle) {
            try {
                const li = document.querySelector(`#states-list li[data-name="${name}"]`);
                if (li) {
                    li.innerHTML = `${escapeHtml(liveTitle)} <span class="state-name">${name}</span>`;
                }
            } catch (e) {}
        }

        // Helpers to create input-change actions
        function describeElement(el) {
            try {
                if (!el) return 'Edit field';
                if (el.getAttribute) {
                    const a = el.getAttribute('aria-label') || el.getAttribute('data-i18n') || el.getAttribute('placeholder') || el.id || el.name;
                    if (a) return `Edit ${a}`;
                }
                if (el.tagName) return `Edit ${el.tagName.toLowerCase()}`;
            } catch (e) {}
            return 'Edit field';
        }
        function makeInputAction(el, prev, next) {
            return {
                description: { title: describeElement(el), detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(next)}` },
                undo: () => {
                    try {
                        if (el.type === 'checkbox' || el.type === 'radio') {
                            el.checked = prev;
                        } else if (el.isContentEditable) {
                            el.innerHTML = prev;
                        } else {
                            el.value = prev;
                        }
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                    } catch (e) {}
                },
                redo: () => {
                    try {
                        if (el.type === 'checkbox' || el.type === 'radio') {
                            el.checked = next;
                        } else if (el.isContentEditable) {
                            el.innerHTML = next;
                        } else {
                            el.value = next;
                        }
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                    } catch (e) {}
                }
            };
        }

        // Track focused input's initial value so we can push the change on blur/change
        let __program_lastFocused = null;
        document.addEventListener('focusin', (e) => {
            const t = e.target;
            if (!t) return;
            // Ignore Monaco editor and its children
            if (t.closest && t.closest('.monaco-editor')) return;
            if (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable || t.tagName === 'SELECT') {
                try {
                    if (t.type === 'checkbox' || t.type === 'radio') __program_lastFocused = { el: t, val: !!t.checked };
                    else if (t.isContentEditable) __program_lastFocused = { el: t, val: t.innerHTML };
                    else __program_lastFocused = { el: t, val: t.value };
                } catch (e) { __program_lastFocused = null; }
            } else {
                __program_lastFocused = null;
            }
        }, true);

        function commitFocusedChange() {
            // If a history navigation is about to occur, suppress committing the
            // focused change (clicking history causes blur -> commit otherwise)
            if (__suppressCommitOnBlur) { __suppressCommitOnBlur = false; __program_lastFocused = null; return; }
            if (!__program_lastFocused) return;
            const el = __program_lastFocused.el;
            try {
                let now;
                if (el.type === 'checkbox' || el.type === 'radio') now = !!el.checked;
                else if (el.isContentEditable) now = el.innerHTML;
                else now = el.value;
                const prev = __program_lastFocused.val;
                if (now !== prev) {
                    pushProgramAction(makeInputAction(el, prev, now));
                    // Do not trigger a full refresh on blur/change — UI updates should be contextual.
                    // Refresh of the whole view will be performed only when undo/redo is used.
                }
            } catch (e) {}
            __program_lastFocused = null;
        }

        // Commit on blur and on change events
        document.addEventListener('blur', (e) => { commitFocusedChange(); }, true);
        document.addEventListener('change', (e) => { 
            // For selects and checkbox changes, commit immediately if not inside Monaco
            const t = e.target;
            if (t && t.closest && t.closest('.monaco-editor')) return;
            commitFocusedChange();
        }, true);

        // Keyboard shortcuts: Ctrl+Z / Ctrl+Y or Ctrl+Shift+Z
        document.addEventListener('keydown', (e) => {
            if (!(e.ctrlKey || e.metaKey)) return;
            // If focus is inside Monaco editor, don't interfere
            const active = document.activeElement;
            if (active && active.closest && active.closest('.monaco-editor')) return;
            if (e.key === 'z' || e.key === 'Z') {
                if (e.shiftKey) {
                    if (redoProgram()) e.preventDefault();
                } else {
                    if (undoProgram()) e.preventDefault();
                }
            } else if (e.key === 'y' || e.key === 'Y') {
                if (redoProgram()) e.preventDefault();
            }
        }, true);

        // Expose APIs for other code to push actions
        window.pushProgramAction = pushProgramAction;
        window.undoProgram = undoProgram;
        window.redoProgram = redoProgram;
        // Expose history for debugging and UI
        window.programHistory = programHistory;
        window.programHistoryIndex = () => historyIndex;

        function updateUndoDropdown() {
            try {
                const hist = document.getElementById('history-list');
                if (!hist) return;
                hist.innerHTML = '';
                // Build combined list from programHistory using historyIndex
                // We'll iterate explicitly so items are always shown last-to-first
                const undoPart = programHistory.slice(0, historyIndex);
                const redoPart = programHistory.slice(historyIndex);
                // Render undo items (available to undo) with most-recent first
                for (let idx = undoPart.length - 1; idx >= 0; idx--) {
                    const item = undoPart[idx];
                    const li = document.createElement('li');
                    // support { title, detail } description objects or plain strings
                    // compute display title/detail
                    let title = item.description || `Change ${historyIndex - (undoPart.length - 1 - idx)}`;
                    let detail = '';
                    if (item && typeof item.description === 'object') { title = item.description.title || ''; detail = item.description.detail || ''; }
                    li.style.padding = '0';
                    li.style.cursor = 'pointer';
                    li.dataset.idx = idx; // original index within history
                    // create a button inside li so the clickable area is reliable
                    const btn = document.createElement('button');
                    btn.className = 'history-item';
                    btn.type = 'button';
                    btn.style.display = 'block';
                    btn.style.width = '100%';
                    btn.style.border = 'none';
                    btn.style.background = 'transparent';
                    btn.style.padding = '6px 8px';
                    btn.style.textAlign = 'left';
                    btn.style.cursor = 'pointer';
                    try {
                        const titleColor = 'rgba(255,255,255,0.95)';
                        const detailColor = 'rgba(255,255,255,0.35)';
                        btn.innerHTML = `<span class=\"history-title\" style=\"color:${titleColor}\">${escapeHtml(title)}</span>${detail ? `<span class=\"history-detail\" style=\"color:${detailColor}\">${escapeHtml(detail)}</span>` : ''}`;
                    } catch (e) { btn.textContent = title; }
                    // Prevent blur-driven commit when this button is pressed
                    btn.addEventListener('pointerdown', () => { __suppressCommitOnBlur = true; setTimeout(() => { __suppressCommitOnBlur = false; }, 400); });
                    // Jump to this history index (non-destructive navigation)
                    btn.addEventListener('click', () => {
                        navigateHistoryTo(idx);
                        toggleDropdown('undo-dropdown', null);
                    });
                    li.appendChild(btn);
                    hist.appendChild(li);
                }
                // Insert a visual boundary that represents the current historyIndex.
                // If there are redo items, place the boundary before them; otherwise
                // it will be implied at the end of the undo list.
                if (redoPart.length > 0) {
                        const boundary = document.createElement('li');
                        boundary.className = 'history-boundary';
                        boundary.textContent = 'Current';
                        boundary.setAttribute('aria-hidden', 'true');
                        boundary.style.pointerEvents = 'none';
                        hist.appendChild(boundary);
                }
                // Render redo items (available to redo) with more transparent color
                // Render most-recent redo first (so list is consistent)
                for (let rIdx = redoPart.length - 1; rIdx >= 0; rIdx--) {
                    const item = redoPart[rIdx];
                    const li = document.createElement('li');
                    let titleR = item.description || `Redo ${redoPart.length - rIdx}`;
                    let detailR = '';
                    if (item && typeof item.description === 'object') { titleR = item.description.title || ''; detailR = item.description.detail || ''; }
                    li.style.padding = '0';
                    li.style.cursor = 'pointer';
                    li.dataset.ridx = rIdx; // index within redoPart
                    // make redo entries semi-transparent
                    li.style.opacity = '0.5';
                    // create button for redo as well
                    const btn = document.createElement('button');
                    btn.className = 'history-item redo';
                    btn.type = 'button';
                    btn.style.display = 'block';
                    btn.style.width = '100%';
                    btn.style.border = 'none';
                    btn.style.background = 'transparent';
                    btn.style.padding = '6px 8px';
                    btn.style.textAlign = 'left';
                    btn.style.cursor = 'pointer';
                    try {
                        const titleColor = 'rgba(255,255,255,0.95)';
                        const detailColor = 'rgba(255,255,255,0.35)';
                        btn.innerHTML = `<span class=\\"history-title\\" style=\\"color:${titleColor}\\">${escapeHtml(titleR)}</span>${detailR ? `<span class=\\"history-detail\\" style=\\"color:${detailColor}\\">${escapeHtml(detailR)}</span>` : ''}`;
                    } catch (e) { btn.textContent = titleR; }
                    // compute the actual history index to jump to (position after the action)
                    const targetIndex = historyIndex + rIdx + 1;
                    btn.addEventListener('pointerdown', () => { __suppressCommitOnBlur = true; setTimeout(() => { __suppressCommitOnBlur = false; }, 400); });
                    btn.addEventListener('click', () => {
                        navigateHistoryTo(targetIndex);
                        toggleDropdown('undo-dropdown', null);
                    });
                    li.appendChild(btn);
                    hist.appendChild(li);
                }
            } catch (e) { }
        }

        function updateToolbarUndoButtons() {
            try {
                const toolbar = document.getElementById('global-toolbar');
                if (!toolbar) return;
                const undoBtn = toolbar.querySelector('[data-action="undo-btn"]');
                const redoBtn = toolbar.querySelector('[data-action="redo-btn"]');
                if (undoBtn) {
                    if (historyIndex === 0) { undoBtn.setAttribute('disabled', 'disabled'); undoBtn.classList.add('disabled'); }
                    else { undoBtn.removeAttribute('disabled'); undoBtn.classList.remove('disabled'); }
                }
                if (redoBtn) {
                    if (historyIndex >= programHistory.length) { redoBtn.setAttribute('disabled', 'disabled'); redoBtn.classList.add('disabled'); }
                    else { redoBtn.removeAttribute('disabled'); redoBtn.classList.remove('disabled'); }
                }
            } catch (e) {}
        }
        let currentTab = 'metadata';
        let selectedState = null;

        // Interval handle for live play-choice availability refreshing
        let playAvailabilityInterval = null;
        const availableProps = ['start_visited', 'always_available', 'dont_mark_visited'];

        function saveToLocalStorage() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            localStorage.setItem('ns2_content', content);
        }

        // Play-engine snapshot helpers (save/restore progress to a string)
        function savePlaySnapshot(engine) {
            try {
                const savePath = '/__snapshot.save';
                const pathPtr = allocateUTF8(savePath);
                Module._SaveProgress(engine, pathPtr);
                Module._free(pathPtr);
                const saveContent = Module.FS.readFile(savePath, { encoding: 'utf8' });
                return saveContent;
            } catch (e) { console.warn('savePlaySnapshot failed', e); return null; }
        }

        function restorePlaySnapshot(engine, snapshot) {
            try {
                if (!snapshot) return false;
                const savePath = '/__snapshot.save';
                Module.FS.writeFile(savePath, snapshot);
                const pathPtr = allocateUTF8(savePath);
                Module._LoadProgress(engine, pathPtr);
                Module._free(pathPtr);
                try { updatePlay(); } catch (e) {}
                return true;
            } catch (e) { console.warn('restorePlaySnapshot failed', e); return false; }
        }

        function newStory() {
            if (confirm(languages[currentLanguage]['createNewStoryConfirm'] || 'Create a new blank story? Unsaved changes will be lost.')) {
                Module._DestroyEngine(editorEngine);
                editorEngine = Module._CreateEngine();
                localStorage.removeItem('ns2_content');
                renderEditor();
                setStatus(languages[currentLanguage]['newStoryCreated'] || "New story created");
            }
        }

        async function openTab(tabName) {
            document.querySelectorAll('.tab-button').forEach(tab => tab.classList.remove('active'));
            const button = Array.from(document.querySelectorAll('.tab-button')).find(b => b.textContent.toLowerCase() === tabName.toLowerCase());
            if (button) button.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            const tabContent = document.getElementById(`tab-${tabName}`);
            tabContent.classList.add('active');

            currentTab = tabName;

            updateGlobalToolbar(tabName);

            const toolbar = document.getElementById('global-toolbar');
            const toolbarHeight = toolbar.offsetHeight;
            document.querySelectorAll('.tab-content').forEach(c => {
                c.style.height = `calc(100vh - 70px)`;
            });

            // Clear graph container when switching away to prevent event bleed
            if (tabName !== 'graph') {
                const graphTab = document.getElementById('tab-graph');
                const graphContainer = document.getElementById('graph-container');
                if (graphContainer) {
                    graphContainer.innerHTML = '';
                }
                if (graphPanZoom) {
                    try {
                        graphPanZoom.dispose();  // Clean up panzoom instance
                    } catch (e) {
                    }
                    graphPanZoom = null;
                }
            } else {
                renderGraph();
            }
            if (tabName === 'text') {
                renderStoryView();
            }
            if (tabName === 'states') {
                renderStates();
            }
            if (tabName === 'variables') {
                renderVariables();
            }
            if (tabName === 'metadata') {
                populateStateDatalist();
            }

            if (tabName === 'play') {
                // Always ensure play engine is ready
                if (!playEngine) {
                    await startPlayEngine();  // Auto-start if not running
                } else {
                    updatePlay();  // Refresh UI
                }
            }
        }
        
        function loadFile() {
            const file = document.getElementById('file-input').files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                const content = e.target.result;
                Module.FS.writeFile('/story.ns2', content);
                const pathPtr = allocateUTF8('/story.ns2');
                const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                Module._free(pathPtr);
                if (loaded) {
                    saveToLocalStorage();
                    renderEditor();
                    setStatus(languages[currentLanguage]['storyLoadedSuccessfully'] || "Story loaded successfully");
                } else {
                    setStatus((languages[currentLanguage]['failedToLoadStory'] || "Failed to load story: {err}").replace('{err}', getLastError(editorEngine)));
                }
            };
            reader.readAsText(file);
        }

        function allocateUTF8(str) {
            const size = Module.lengthBytesUTF8(str) + 1;
            const ptr = Module._malloc(size);
            Module.stringToUTF8(str, ptr, size);
            return ptr;
        }

        function getLastError(engine) {
            const ptr = Module._GetStoryLastError(engine);
            const err = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            return err;
        }

        function setStatus(message, isError = false) {
            const content = document.getElementById('status-content');
            content.innerHTML = (message || 'Ready').replace(/\n/g, '<br>');
            content.style.color = isError ? '#ff6b6b' : '#D4D4D4';
        }

        function renderStoryView() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            const container = document.getElementById('text-editor');

            // Collect state and variable tokens dynamically
            let stateTokens = [];
            const stateCount = Module._GetStateCount(editorEngine);
            for (let i = 0; i < stateCount; i++) {
                const statePtr = Module._GetStateName(editorEngine, i);
                stateTokens.push(Module.UTF8ToString(statePtr));
                Module._FreeString(statePtr);
            }

            let variableTokens = [];
            const varCount = Module._GetVariableCount(editorEngine);
            for (let i = 0; i < varCount; i++) {
                const varPtr = Module._GetVariableName(editorEngine, i);
                variableTokens.push(Module.UTF8ToString(varPtr));
                Module._FreeString(varPtr);
            }

            const functionTokens = ['set', 'reset', 'get', 'dice', 'min', 'max', 'abs', 'sqrt', 'chance', 'if', 'not', 'visited'];
            const operatorTokens = ['+', '-', '*', '/', '==', '!=', '>', '<', '>=', '<=', '=', 'and', 'or'];
            const constantTokens = ['true', 'false'];
            const typeTokens = ['string', 'int', 'float', 'bool'];

            const functionRegex = new RegExp('\\b(' + functionTokens.join('|') + ')\\b');
            const operatorRegex = new RegExp('(' + operatorTokens.map(op => op.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') + ')');
            const constantRegex = new RegExp('\\b(' + constantTokens.join('|') + ')\\b');
            const variableRegex = new RegExp('\\b(' + variableTokens.join('|') + ')\\b');
            const stateRegex = new RegExp('\\b(' + stateTokens.join('|') + ')\\b');
            const typeRegex = new RegExp('\\b(' + typeTokens.join('|') + ')\\b');
            const numberRegex = /[-+]?\d+(?:\.\d+)?/;
            const stringRegex = /"[^"]*"/;

            const commonExprRules = [
                [functionRegex, 'ns2.function.inside'],
                [operatorRegex, 'ns2.operator.inside'],
                [constantRegex, 'ns2.constant.inside'],
                [variableRegex, 'ns2.variable.inside'],
                [stateRegex, 'ns2.state.inside'],
                [typeRegex, 'ns2.type.inside'],
                [/[\(\)]/, 'ns2.roundbracket.inside'],
                [numberRegex, 'ns2.number.inside'],
                [stringRegex, 'ns2.string.inside']
            ];

            // Improved Monarch tokenizer matching the NS2 format described in the guide.
            const monarchDefinition = {
                defaultToken: '',
                tokenizer: {
                    root: [
                        // Top-level headings and sections
                        [/^(\s*)(Title\s*:)(.*)$/, ['', 'ns2.keyword', 'ns2.title']],
                        [/^(\s*)(Description\s*:)(.*)$/, ['', 'ns2.keyword', 'ns2.description']],
                        [/^(\s*)(Start\s*:)(.*)$/, ['', 'ns2.keyword', 'ns2.start']],
                        [/^\s*(Variables)\s*:\s*$/, 'ns2.section'],
                        [/^\s*(States)\s*:\s*$/, 'ns2.section'],

                        // State header (stateName:)
                        [/^([A-Za-z0-9_\-]+)(\s*)(:)(\s*)$/, ['ns2.state', '', 'ns2.punct', '']],

                        // Variable declarations: type name: initial [constraint]
                        [/^(\s*)(string|int|float|bool)(\s+)([A-Za-z0-9_]+)(\s*)(:)(.*)$/, ['', 'ns2.type', '', 'ns2.variable', '', 'ns2.punct', 'ns2.initial']],

                        // Choice line leading dash
                        [/^\s*\-\s+/, 'ns2.punct', '@choicetext'],

                        // Sub-keys under states (title:, description:, script:, requires:, actions:, properties:)
                        [/^(\s+)(title|description|script)(\s*:\s*)(.*)$/, ['', 'ns2.key', 'ns2.punct', 'ns2.string']],
                        [/^(\s+)(requires|actions|properties)(\s*:\s*)(\[.*\])?$/, ['', 'ns2.key', 'ns2.punct', 'ns2.squarebracket.inside']],

                        // Opening bracket starts a script/expression region handled by @script state
                        [/\[/, { token: 'ns2.squarebracket', next: '@script' }],
                        // numbers and strings in general
                        [/"[^"]*"/, 'ns2.string'],
                        [/\b(true|false)\b/, 'ns2.constant'],
                        [/[-+]?\d+(?:\.\d+)?\b/, 'ns2.number'],

                        // fallback: identifiers and punctuation
                        [/[:\[\]\(\)\-\>]/, 'ns2.punct'],
                        [/\w+/, '']
                    ],

                    // State for parsing choice text after the leading '- '
                    choicetext: [
                        // bracketed expressions at start — capture open/inside/close so token arrays match groups
                        [/\s*(\[)([^\]]*)(\])/, ['ns2.squarebracket', 'ns2.expression', 'ns2.squarebracket']],
                        // arrow to target
                        [/\s*->\s*/, 'ns2.punct', '@target'],
                        // rest of line as plain text
                        [/.*$/, { token: 'ns2.choiceText', next: '@pop' }]
                    ],

                    target: [
                        [/\s*([A-Za-z0-9_\-]+)\s*/, { token: 'ns2.state', next: '@aftertarget' }]
                    ],

                    aftertarget: [
                        // optional bracketed effect or flags — capture open/inside/close
                        [/\s*(\[)([^\]]*)(\])/, ['ns2.squarebracket', 'ns2.flag', 'ns2.squarebracket'], '@pop'],
                        [/.*$/, { token: '', next: '@pop' }]
                    ]
                    ,
                    // script state: everything inside [ ... ] is treated as script
                    script: [
                        [/[^\]]+/, 'ns2.script'],
                        [/\]/, { token: 'ns2.squarebracket', next: '@pop' }]
                    ]
                }
            };

            if (!textEditor) {
                require(['vs/editor/editor.main'], function () {
                        console.debug('[ns2] Monaco editor main loaded');
                        try {
                            console.debug('[ns2] registering language id=ns2');
                            monaco.languages.register({ id: 'ns2' });
                                console.debug('[ns2] setting Monarch tokens provider for ns2');
                                    if (typeof setNs2Monarch === 'function') setNs2Monarch(monarchDefinition);
                                    else monaco.languages.setMonarchTokensProvider('ns2', monarchDefinition);
                        } catch (err) {
                            console.error('[ns2] Error registering language or tokens provider', err);
                        }
                        try {
                            console.debug('[ns2] defining theme ns2-dark');
                            monaco.editor.defineTheme('ns2-dark', {
                        base: 'vs-dark',
                        inherit: true,
                        rules: [
                            // tokens emitted by the Monarch tokenizer
                            { token: 'ns2.keyword', foreground: 'c586c0' },
                            { token: 'ns2.title', foreground: 'c586c0' },
                            { token: 'ns2.description', foreground: 'c586c0' },
                            { token: 'ns2.start', foreground: '9cdcfe' },
                            { token: 'ns2.section', foreground: '4ec9b0' },
                            { token: 'ns2.state', foreground: 'c586c0' },
                            { token: 'ns2.type', foreground: '4ec9b0' },
                            { token: 'ns2.variable', foreground: '9cdcfe' },
                            { token: 'ns2.initial', foreground: 'b5cea8' },
                            { token: 'ns2.punct', foreground: 'd4d4d4' },
                            { token: 'ns2.key', foreground: '4ec9b0' },
                            { token: 'ns2.choiceText', foreground: 'dcdcaa' },
                            { token: 'ns2.string', foreground: 'ce9178' },
                            { token: 'ns2.number', foreground: 'b5cea8' },
                            { token: 'ns2.constant', foreground: '569cd6' },
                            { token: 'ns2.squarebracket.inside', foreground: '000000' },
                            { token: 'ns2.expression', foreground: '9cdcfe' },
                            { token: 'ns2.squarebracket', foreground: 'ffffff', background: '555555', fontStyle: 'bold' },
                            { token: 'ns2.squarebracket.inside', foreground: 'ffffff', background: '555555' },
                            { token: 'ns2.script', foreground: 'ffffff', background: '555555', fontStyle: 'bold' },
                            { token: 'ns2.flag', foreground: '569cd6' },
                            // legacy/compat tokens from earlier tokenizer (keep them mapped too)
                            { token: 'ns2.function.inside', foreground: 'dcdcaa' },
                            { token: 'ns2.operator.inside', foreground: 'd4d4d4' },
                            { token: 'ns2.constant.inside', foreground: '569cd6' },
                            { token: 'ns2.variable.inside', foreground: '9cdcfe' },
                            { token: 'ns2.state.inside', foreground: 'c586c0' },
                            { token: 'ns2.type.inside', foreground: '4ec9b0' },
                            { token: 'ns2.roundbracket.inside', foreground: 'ffd700' },
                            { token: 'ns2.number.inside', foreground: 'b5cea8' },
                            { token: 'ns2.string.inside', foreground: 'ce9178' },
                            { token: 'ns2.expression.inside', foreground: '9cdcfe' }
                        ],
                        colors: {
                           
                            'editor.background': '#1e1e1e'
                        }
                    });
                    textEditor = monaco.editor.create(container, {
                        value: content,
                        language: 'ns2',
                        theme: 'ns2-dark',
                        automaticLayout: true,
                        wordWrap: 'on'
                    });
                    attachTextEditorAutoApply();
                    try {
                        // Diagnostic: tokenize a small sample and log results
                        if (monaco && monaco.editor && typeof monaco.editor.tokenize === 'function') {
                            const sample = 'int health: 100 [0,100]\nintro:\n  title: Welcome\n  - Go north -> forest';
                            try {
                                const toks = monaco.editor.tokenize(sample, 'ns2');
                                console.debug('[ns2] tokenize sample result:', toks);
                            } catch (e) {
                                console.error('[ns2] tokenize sample failed', e);
                            }
                        }
                    } catch(e) {}
                    } catch (err) {
                        console.error('[ns2] Error defining theme or creating editor', err);
                    }
                });
            } else {
                if (typeof setNs2Monarch === 'function') setNs2Monarch(monarchDefinition);
                else monaco.languages.setMonarchTokensProvider('ns2', monarchDefinition);
                textEditor.setValue(content);
                attachTextEditorAutoApply();
            }
        }

        function attachTextEditorAutoApply() {
            if (!textEditor || textEditorAutoApplyAttached) return;
            textEditorAutoApplyAttached = true;
            textEditor.onDidChangeModelContent(() => {
                if (textApplyTimer) clearTimeout(textApplyTimer);
                textApplyTimer = setTimeout(() => {
                    try {
                        applyTextChanges();
                    } catch (e) {}
                }, 800);
                // update bracket decorations live
                try { applyMonacoBracketDecorations(); } catch (e) {}
            });
            // initial decorations
            try { applyMonacoBracketDecorations(); } catch (e) {}
        }

        // Monaco decoration id holder for bracket regions
        let bracketDecorations = [];

        function applyMonacoBracketDecorations() {
            if (!textEditor) return;
            const model = textEditor.getModel();
            if (!model) return;
            const text = model.getValue();
            const ranges = [];
            // Find all bracketed ranges (including nested/simple)
            let match;
            const re = /\[([\s\S]*?)\]/g;
            while ((match = re.exec(text)) !== null) {
                const startIndex = match.index;
                const endIndex = re.lastIndex;
                const startPos = model.getPositionAt(startIndex);
                const endPos = model.getPositionAt(endIndex);
                ranges.push({ range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column), options: { inlineClassName: 'ns2-bracket-deco' } });
            }
            // Apply decorations
            bracketDecorations = textEditor.deltaDecorations(bracketDecorations, ranges);
        }

        // Apply decoration CSS (Visual Studio style aggressive black background)
        (function injectBracketDecorationStyle(){
            const id = 'ns2-bracket-style';
            if (document.getElementById(id)) return;
            const s = document.createElement('style');
            s.id = id;
            s.textContent = `
            .monaco-editor .ns2-bracket-deco { background-color: #222; color: #690 !important; font-weight:700; border:1px solid #555; box-shadow: inset 3px 5px 8px rgba(0,0,0,1); }
        `;
            document.head.appendChild(s);
        })();

        

        function applyTextChanges() {
            const text = textEditor.getValue();
            Module.FS.writeFile('/temp.ns2', text);
            const pathPtr = allocateUTF8('/temp.ns2');
            const loaded = Module._LoadFromFile(editorEngine, pathPtr);
            Module._free(pathPtr);
            if (loaded) {
                saveToLocalStorage();
                renderEditor();
                setStatus(languages[currentLanguage]['changesApplied'] || "Changes applied successfully");
                } else {
                setStatus((languages[currentLanguage]['invalidNS2Format'] || "Invalid NS2 format: {err}").replace('{err}', getLastError(editorEngine)));
            }
        }

        function populateStateDatalist() {
            const stateList = document.getElementById('state-list');
            stateList.innerHTML = '';
            const count = Module._GetStateCount(editorEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetStateName(editorEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const option = document.createElement('option');
                option.value = name;
                stateList.appendChild(option);
            }
        }

        function populateTokenDatalist() {
            const tokenList = document.getElementById('token-list');
            tokenList.innerHTML = '';
            tokens.forEach(token => {
                const option = document.createElement('option');
                option.value = token;
                tokenList.appendChild(option);
            });
        }

        function renderVariables() {
            const list = document.getElementById('variables-list');
            list.innerHTML = '';
            const count = Module._GetVariableCount(editorEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetVariableName(editorEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const namePtr2 = allocateUTF8(name);
                const typePtr = Module._GetVariableType(editorEngine, namePtr2);
                const type = Module.UTF8ToString(typePtr);
                Module._FreeString(typePtr);
                const initialPtr = Module._GetVariableInitial(editorEngine, namePtr2);
                const initial = Module.UTF8ToString(initialPtr);
                Module._FreeString(initialPtr);
                const constraintPtr = Module._GetVariableConstraint(editorEngine, namePtr2);
                const constraint = Module.UTF8ToString(constraintPtr);
                Module._FreeString(constraintPtr);
                Module._free(namePtr2);
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><select onchange="updateVariable('${escapeHtml(name)}', 'type', this.value)"><option value="string">string</option><option value="int">int</option><option value="float">float</option><option value="bool">bool</option></select></td>
                    <td><input value="${escapeHtml(name)}" onchange="updateVariableName('${escapeHtml(name)}', this.value)" onblur="updateVariableName('${escapeHtml(name)}', this.value)"></td>
                    <td><input value="${escapeHtml(initial)}" onchange="updateVariable('${escapeHtml(name)}', 'initial', this.value)" onblur="updateVariable('${escapeHtml(name)}', 'initial', this.value)"></td>
                    <td><input value="${escapeHtml(constraint)}" onchange="updateVariable('${escapeHtml(name)}', 'constraint', this.value)" onblur="updateVariable('${escapeHtml(name)}', 'constraint', this.value)"></td>
                    <td><button class="icon-button" onclick="removeVariable('${escapeHtml(name)}')" data-i18n-title="deleteVariable" title="Delete Variable"><i class="fas fa-trash"></i></button></td>
                `;
                tr.querySelector('select').value = type || 'string';
                list.appendChild(tr);
            }
            filterVariables();
        }

        function generateUniqueVariableName() {
            const prefix = 'var';
            const existing = new Set();
            try {
                const count = Module._GetVariableCount(editorEngine);
                for (let i = 0; i < count; i++) {
                    const namePtr = Module._GetVariableName(editorEngine, i);
                    const name = Module.UTF8ToString(namePtr);
                    Module._FreeString(namePtr);
                    existing.add(name);
                }
            } catch (e) {}
            let idx = 1;
            while (existing.has(prefix + idx)) idx++;
            return prefix + idx;
        }

        function generateUniqueStateName() {
            const prefix = 'state';
            const existing = new Set();
            try {
                const count = Module._GetStateCount(editorEngine);
                for (let i = 0; i < count; i++) {
                    const namePtr = Module._GetStateName(editorEngine, i);
                    const name = Module.UTF8ToString(namePtr);
                    Module._FreeString(namePtr);
                    existing.add(name);
                }
            } catch (e) {}
            let idx = 1;
            while (existing.has(prefix + idx)) idx++;
            return prefix + idx;
        }

        function filterVariables() {
            const searchInput = document.getElementById('var-search');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const rows = document.querySelectorAll('#variables-list tr');
            rows.forEach(row => {
                try {
                    const nameCell = row.cells[1].querySelector('input').value || '';
                    const nameNorm = normalizeForMatching(nameCell).toLowerCase();
                    try { row.hidden = !nameNorm.includes(query); } catch (e) { row.style.display = nameNorm.includes(query) ? '' : 'none'; }
                } catch (e) { try { row.hidden = false; } catch (ee) { row.style.display = ''; } }
            });
        }

        function addVariable() {
            const name = generateUniqueVariableName();
            const namePtr = allocateUTF8(name);
            Module._AddVariable(editorEngine, allocateUTF8('string'), namePtr, allocateUTF8(''), allocateUTF8(''));
            Module._free(namePtr);
            renderVariables();
            saveToLocalStorage();
            updateTokens();
            populateTokenDatalist();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorAddingVariable'] || "Error adding variable: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['variableAdded'] || "Variable added successfully");
                // push undo/redo action for addVariable
                try {
                    const action = {
                        description: { title: `Add variable ${name}`, detail: `name: ${summarizeForHistory(name)}` },
                        undo: () => { removeVariable(name); },
                        redo: () => { const nPtr = allocateUTF8(name); Module._AddVariable(editorEngine, allocateUTF8('string'), nPtr, allocateUTF8(''), allocateUTF8('')); Module._free(nPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); }
                    };
                    pushProgramAction(action);
                    // Contextual update: update the corresponding variable row instead of full re-render
                    try {
                        const rows = Array.from(document.querySelectorAll('#variables-list tr'));
                        for (const tr of rows) {
                            const nameInp = tr.cells[1] && tr.cells[1].querySelector('input');
                            if (!nameInp) continue;
                            if (nameInp.value === name) {
                                if (field === 'type') {
                                    const sel = tr.querySelector('select'); if (sel) sel.value = value || 'string';
                                } else if (field === 'initial') {
                                    const inp = tr.cells[2] && tr.cells[2].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'constraint') {
                                    const inp = tr.cells[3] && tr.cells[3].querySelector('input'); if (inp) inp.value = value;
                                }
                                break;
                            }
                        }
                        try { updateTokens(); populateTokenDatalist(); } catch (e) {}
                    } catch (e) {}
                } catch (e) {}
            }
        }

        function updateVariable(name, field, value) {
            const namePtr = allocateUTF8(name);
            // capture previous value
            let prev = null;
            try {
                if (field === 'type') {
                    const prevPtr = Module._GetVariableType(editorEngine, namePtr);
                    prev = Module.UTF8ToString(prevPtr);
                    Module._FreeString(prevPtr);
                    const valuePtr = allocateUTF8(value);
                    Module._SetVariableType(editorEngine, namePtr, valuePtr);
                    Module._free(valuePtr);
                } else if (field === 'initial') {
                    const prevPtr = Module._GetVariableInitial(editorEngine, namePtr);
                    prev = Module.UTF8ToString(prevPtr);
                    Module._FreeString(prevPtr);
                    const valuePtr = allocateUTF8(value);
                    Module._SetVariableInitial(editorEngine, namePtr, valuePtr);
                    Module._free(valuePtr);
                } else if (field === 'constraint') {
                    const prevPtr = Module._GetVariableConstraint(editorEngine, namePtr);
                    prev = Module.UTF8ToString(prevPtr);
                    Module._FreeString(prevPtr);
                    const valuePtr = allocateUTF8(value);
                    Module._SetVariableConstraint(editorEngine, namePtr, valuePtr);
                    Module._free(valuePtr);
                }
            } catch (e) { console.warn('updateVariable capture failed', e); }
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingVariable'] || "Error updating variable: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update variable ${name}`, detail: `${field}: ${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateVariable(name, field, prev); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} },
                        redo: () => { try { updateVariable(name, field, value); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    try { refreshView(); } catch (e) {}
                } catch (e) {}
            }
        }

        function updateVariableName(oldName, newName) {
            if (newName === oldName) return;
            const oldPtr = allocateUTF8(oldName);
            const newPtr = allocateUTF8(newName);
            let type = 'string', initial = '', constraint = '';
            try {
                const typePtr = Module._GetVariableType(editorEngine, oldPtr);
                type = Module.UTF8ToString(typePtr); Module._FreeString(typePtr);
                const initialPtr = Module._GetVariableInitial(editorEngine, oldPtr);
                initial = Module.UTF8ToString(initialPtr); Module._FreeString(initialPtr);
                const constraintPtr = Module._GetVariableConstraint(editorEngine, oldPtr);
                constraint = Module.UTF8ToString(constraintPtr); Module._FreeString(constraintPtr);
            } catch (e) {}
            Module._AddVariable(editorEngine, allocateUTF8(type), newPtr, allocateUTF8(initial), allocateUTF8(constraint));
            Module._RemoveVariable(editorEngine, oldPtr);
            Module._free(oldPtr);
            Module._free(newPtr);
            // Contextual DOM updates: update the variable row name input and relevant datalists
            try {
                const rows = Array.from(document.querySelectorAll('#variables-list tr'));
                for (const tr of rows) {
                    const nameInp = tr.cells[1] && tr.cells[1].querySelector('input');
                    if (nameInp && nameInp.value === oldName) {
                        nameInp.value = newName;
                        break;
                    }
                }
                try { updateTokens(); populateTokenDatalist(); } catch (e) {}
            } catch (e) {}
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingVariableName'] || "Error updating variable name: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Rename variable ${oldName} -> ${newName}`, detail: `${summarizeForHistory(type)} ${summarizeForHistory(initial)}` },
                        undo: () => { try { const nPtr = allocateUTF8(oldName); Module._AddVariable(editorEngine, allocateUTF8(type), nPtr, allocateUTF8(initial), allocateUTF8(constraint)); const remPtr = allocateUTF8(newName); Module._RemoveVariable(editorEngine, remPtr); Module._free(remPtr); Module._free(nPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} },
                        redo: () => { try { updateVariableName(oldName, newName); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    try { refreshView(); } catch (e) {}
                } catch (e) {}
            }
        }

        function removeVariable(name) {
            const namePtr = allocateUTF8(name);
            // capture variable data
            let type = 'string', initial = '', constraint = '';
            try {
                const tPtr = Module._GetVariableType(editorEngine, namePtr); type = Module.UTF8ToString(tPtr); Module._FreeString(tPtr);
                const iPtr = Module._GetVariableInitial(editorEngine, namePtr); initial = Module.UTF8ToString(iPtr); Module._FreeString(iPtr);
                const cPtr = Module._GetVariableConstraint(editorEngine, namePtr); constraint = Module.UTF8ToString(cPtr); Module._FreeString(cPtr);
            } catch (e) {}

            Module._RemoveVariable(editorEngine, namePtr);
            Module._free(namePtr);
            renderVariables();
            saveToLocalStorage();
            updateTokens();
            populateTokenDatalist();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorRemovingVariable'] || "Error removing variable: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['variableRemoved'] || "Variable removed successfully");
                try {
                    const action = {
                        description: { title: `Remove variable ${name}`, detail: `${summarizeForHistory(type)} ${summarizeForHistory(initial)}` },
                        undo: () => { try { const nPtr = allocateUTF8(name); Module._AddVariable(editorEngine, allocateUTF8(type), nPtr, allocateUTF8(initial), allocateUTF8(constraint)); Module._free(nPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} },
                        redo: () => { try { const rPtr = allocateUTF8(name); Module._RemoveVariable(editorEngine, rPtr); Module._free(rPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    try { refreshView(); } catch (e) {}
                } catch (e) {}
            }
        }

        function renderStates() {
            const list = document.getElementById('states-list');
            list.innerHTML = '';
            const count = Module._GetStateCount(editorEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetStateName(editorEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const titlePtr = Module._GetStateTitle(editorEngine, allocateUTF8(name));
                const title = Module.UTF8ToString(titlePtr);
                Module._FreeString(titlePtr);
                const li = document.createElement('li');
                li.innerHTML = `${title} <span class="state-name">${name}</span>`;
                li.dataset.name = name;
                li.onclick = () => selectState(name);
                        list.appendChild(li);
                        // If playEngine exists, check whether this state can be visited from current play context
                        if (typeof playEngine !== 'undefined' && playEngine) {
                            const pNamePtr = allocateUTF8(name);
                            try {
                                const canVisit = Module._CanVisitState(playEngine, pNamePtr);
                                if (!canVisit) {
                                    li.classList.add('disabled');
                                    li.title = languages[currentLanguage]['cannotVisitState'] || 'State not visitable in current play session';
                                }
                            } catch (e) {
                                // ignore if function not available
                            }
                            Module._free(pNamePtr);
                        }
            }
            if (count > 0) {
                const firstNamePtr = Module._GetStateName(editorEngine, 0);
                const firstName = Module.UTF8ToString(firstNamePtr);
                Module._FreeString(firstNamePtr);
                // If a state was previously selected and still exists, keep it selected
                try {
                    if (selectedState) {
                        const exists = Array.from(list.querySelectorAll('li')).some(li => li.dataset.name === selectedState);
                        if (exists) {
                            selectState(selectedState);
                        } else {
                            selectState(firstName);
                        }
                    } else {
                        selectState(firstName);
                    }
                } catch (e) { selectState(firstName); }
            }
            populateStateDatalist();
            updateTokens();
            populateTokenDatalist();
        }

function selectState(name) {
    selectedState = name;
    document.querySelectorAll('#states-list li').forEach(li => li.classList.remove('selected'));
    const selectedLi = Array.from(document.querySelectorAll('#states-list li')).find(li => li.dataset.name === name);
    if (selectedLi) selectedLi.classList.add('selected');
    const panel = document.getElementById('state-details');
    panel.innerHTML = '';
    if (!name) return;
    const namePtr = allocateUTF8(name);
    const titlePtr = Module._GetStateTitle(editorEngine, namePtr);
    const title = Module.UTF8ToString(titlePtr);
    Module._FreeString(titlePtr);
    const descPtr = Module._GetStateDescription(editorEngine, namePtr);
    const desc = Module.UTF8ToString(descPtr);
    Module._FreeString(descPtr);
    const scriptPtr = Module._GetStateScript(editorEngine, namePtr);
    const script = Module.UTF8ToString(scriptPtr);
    Module._FreeString(scriptPtr);
    let requires = [];
    const reqCount = Module._GetStateRequiresCount(editorEngine, namePtr);
    for (let i = 0; i < reqCount; i++) {
        const reqPtr = Module._GetStateRequire(editorEngine, namePtr, i);
        requires.push(Module.UTF8ToString(reqPtr));
        Module._FreeString(reqPtr);
    }
    let actions = [];
    const actCount = Module._GetStateActionsCount(editorEngine, namePtr);
    for (let i = 0; i < actCount; i++) {
        const actPtr = Module._GetStateAction(editorEngine, namePtr, i);
        actions.push(Module.UTF8ToString(actPtr));
        Module._FreeString(actPtr);
    }
    let properties = [];
    const propCount = Module._GetStatePropertiesCount(editorEngine, namePtr);
    for (let i = 0; i < propCount; i++) {
        const propPtr = Module._GetStateProperty(editorEngine, namePtr, i);
        properties.push(Module.UTF8ToString(propPtr));
        Module._FreeString(propPtr);
    }
    Module._free(namePtr);
    const content = document.createElement('div');
    content.innerHTML = `
        <style>
            #state-script-textarea {
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 12px;
                line-height: 1.4;
                resize: none;
                min-height: 60px;
                overflow-y: auto;
            }
            #state-script-textarea:focus {
                border-color: #007bb0;
                box-shadow: 0 0 5px rgba(0, 122, 204, 0.5);
            }
        </style>
        <div class="grid-form">
                <label data-i18n="name:">Name:</label> <input value="${escapeHtml(name)}" data-live="true" oninput="liveUpdateStateName('${escapeHtml(name)}', this.value)" onchange="updateStateName('${escapeHtml(name)}', this.value)" onblur="updateStateName('${escapeHtml(name)}', this.value)">
                <label data-i18n="titleLabel:">Title:</label> <input value="${escapeHtml(title)}" data-live="true" oninput="liveUpdateStateTitle('${escapeHtml(name)}', this.value)" onchange="updateState('${escapeHtml(name)}', 'title', this.value); saveToLocalStorage()">
            <label data-i18n="desc:">Desc:</label> <textarea data-live="true" onchange="updateState('${escapeHtml(name)}', 'description', this.value); saveToLocalStorage()">${escapeHtml(desc)}</textarea>
            <label data-i18n="script:">Script:</label> <textarea id="state-script-textarea" list="token-list" onchange="updateState('${escapeHtml(name)}', 'script', this.value); saveToLocalStorage()">${escapeHtml(script)}</textarea>
            <label data-i18n="requires:">Requires:</label> <input list="token-list" value="${escapeHtml(requires.join('; '))}" onchange="updateStateList('${escapeHtml(name)}', 'requires', this.value); saveToLocalStorage()">
            <label data-i18n="actions:">Actions:</label> <input list="token-list" value="${escapeHtml(actions.join('; '))}" onchange="updateStateList('${escapeHtml(name)}', 'actions', this.value); saveToLocalStorage()">
            <label data-i18n="props:">Props:</label> <div class="props-container" id="props-checkboxes-${escapeHtml(name)}"></div>
        </div>
        <div class="choices-section">
                <div class="toolbar">
                <input type="text" id="choice-search" data-i18n-placeholder="searchChoices" oninput="filterChoices('${escapeHtml(name)}')">
                <button class="icon-button" onclick="addChoice('${escapeHtml(name)}')" data-i18n-title="addChoice" title="Add Choice"><i class="fas fa-plus"></i></button>
            </div>
            <div class="table-wrapper">
                <table>
                    <thead><tr><th data-i18n="text">Text</th><th data-i18n="cond">Cond</th><th data-i18n="target">Target</th><th data-i18n="effect">Effect</th><th data-i18n="hide">Hide</th><th></th></tr></thead>
                    <tbody id="choices-${escapeHtml(name)}"></tbody>
                </table>
            </div>
        </div>
    `;
    panel.appendChild(content);
    setLanguage(currentLanguage);  // to translate the new labels
    renderChoices(name);
    filterChoices(name);

    // (no overlays) highlighting restricted to Monaco editor only

    // Auto-resize and live-save the state description textarea (keep behavior similar to story description)
    try {
        const descTextarea = panel.querySelector('textarea:not(#state-script-textarea)');
        const scriptTextarea = panel.querySelector('#state-script-textarea');
        function autoResizeTextarea(el) {
            el.style.height = 'auto';
            el.style.height = (el.scrollHeight) + 'px';
        }
        if (descTextarea) {
            // apply initial size
            setTimeout(() => autoResizeTextarea(descTextarea), 0);
            descTextarea.addEventListener('input', function() {
                autoResizeTextarea(this);
                // update state description live (updateState already saves)
                try {
                    updateState(name, 'description', this.value);
                } catch (e) {
                    console.warn('Failed to update state description live', e);
                }
            });
        }
        if (scriptTextarea) {
            // apply initial size for script textarea
            setTimeout(() => autoResizeTextarea(scriptTextarea), 0);
            scriptTextarea.addEventListener('input', function() {
                autoResizeTextarea(this);
                // update state script live
                try {
                    updateState(name, 'script', this.value);
                } catch (e) {
                    console.warn('Failed to update state script live', e);
                }
            });
        }
    } catch (e) {
        console.warn('Auto-resize for state textareas failed', e);
    }

    // Render properties checkboxes
    const propsDiv = document.getElementById(`props-checkboxes-${escapeHtml(name)}`);
    availableProps.forEach(prop => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = prop;
        if (properties.includes(prop)) checkbox.checked = true;
        checkbox.onchange = () => {
            const checkedProps = availableProps.filter(p => {
                const cb = propsDiv.querySelector(`input[value="${p}"]`);
                return cb && cb.checked;
            }).join('; ');
            updateStateList(name, 'properties', checkedProps);
            saveToLocalStorage();
        };
        label.appendChild(checkbox);
        const propDisplay = prop.replace('_', ' ').toUpperCase();
        label.appendChild(document.createTextNode(` ${propDisplay}`));
        propsDiv.appendChild(label);
    });

    // Ensure textarea is styled consistently and focus first input
    const scriptTextarea = document.getElementById('state-script-textarea');
    if (scriptTextarea) {
        scriptTextarea.style.width = '100%';
        scriptTextarea.style.boxSizing = 'border-box';
    }
    
    // Focus the first input element (Name field) only if the panel doesn't already contain focus
    const firstInput = panel.querySelector('input');
    if (firstInput) {
        try {
            const active = document.activeElement;
            if (!panel.contains(active) || active === document.body) {
                firstInput.focus();
            }
        } catch (e) {
            try { firstInput.focus(); } catch (ee) {}
        }
    }

    // Sync selection with graph: highlight the node for the selected state
    try { highlightGraphNode(name); } catch (e) {}
}

        function filterChoices(stateName) {
            const raw = (document.getElementById(`choice-search`) && document.getElementById(`choice-search`).value) || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const rows = document.querySelectorAll(`#choices-${stateName} tr`);
            rows.forEach(row => {
                try {
                    const text = (row.cells[0].querySelector('input').value || '');
                    const textNorm = normalizeForMatching(text).toLowerCase();
                    try { row.hidden = !textNorm.includes(query); } catch (e) { row.style.display = textNorm.includes(query) ? '' : 'none'; }
                } catch (e) { try { row.hidden = false; } catch (ee) { row.style.display = ''; } }
            });
        }

        function setAsStart(name) {
            const namePtr = allocateUTF8(name);
            Module._SetStartState(editorEngine, namePtr);
            Module._free(namePtr);
            saveToLocalStorage();
            document.getElementById('start-state').value = name;
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorSettingStartState'] || "Error setting start state: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['startStateSet'] || "Start state set successfully");
            }
        }

        function jumpToState(name) {
            if (!name) return;
            if (confirm((languages[currentLanguage]['confirmDeleteState'] || 'Delete state "{name}"?').replace('{name}', name))) {
                removeState(name);
                // Refresh graph view
                try {
                    // clear any graph selection referencing the deleted state
                    if (graphSelectedState === name) graphSelectedState = null;
                    renderGraph();
                } catch (e) {}
            }
        }

        function forceJumpToState(name) {
            if (!playEngine) {
                setStatus(languages[currentLanguage]['startPlaySessionFirst'] || "Start the play session first", true);
                return;
            }
            try {
                const before = savePlaySnapshot(playEngine);
                const namePtr = allocateUTF8(name);
                Module._SetCurrentState(playEngine, namePtr);
                Module._free(namePtr);
                updatePlay();
                openTab('play');
                const after = savePlaySnapshot(playEngine);
                const err = getLastError(playEngine);
                if (err) {
                    setStatus((languages[currentLanguage]['errorForceJump'] || "Error force jumping to state: {err}").replace('{err}', err));
                } else {
                    setStatus(languages[currentLanguage]['forceJumpSuccess'] || "Force jumped to state successfully");
                    try {
                        const action = {
                                description: { title: `Force jump to ${name}`, detail: `to: ${summarizeForHistory(name)}` },
                                undo: () => { try { restorePlaySnapshot(playEngine, before); } catch (e) {} },
                                redo: () => { try { restorePlaySnapshot(playEngine, after); } catch (e) {} }
                            };
                        pushProgramAction(action);
                    } catch (e) {}
                }
            } catch (e) { console.warn('forceJumpToState failed', e); }
        }

        function renderChoices(name) {
            const list = document.getElementById(`choices-${escapeHtml(name)}`);
            list.innerHTML = '';
            const namePtr = allocateUTF8(name);
            const count = Module._GetStateChoicesCount(editorEngine, namePtr);
            for (let i = 0; i < count; i++) {
                const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
                const text = Module.UTF8ToString(textPtr);
                Module._FreeString(textPtr);
                const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
                const cond = Module.UTF8ToString(condPtr);
                Module._FreeString(condPtr);
                const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
                const target = Module.UTF8ToString(targetPtr);
                Module._FreeString(targetPtr);
                const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
                const effect = Module.UTF8ToString(effectPtr);
                Module._FreeString(effectPtr);
                const hide = Module._GetStateChoiceHide(editorEngine, namePtr, i);
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input list="token-list" value="${escapeHtml(text)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'text', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'text', this.value)"></td>
                    <td><input list="token-list" value="${escapeHtml(cond)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'cond', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'cond', this.value)"></td>
                    <td><div class="target-group"><input list="state-list" value="${escapeHtml(target)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'target', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'target', this.value)"><button class="icon-button scope-button" onclick="scopeToState(this.previousSibling.value)" data-i18n-title="Jump to State" title="Go to State"><i class="fas fa-arrow-right"></i></button></div></td>
                    <td><input list="token-list" value="${escapeHtml(effect)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'effect', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'effect', this.value)"></td>
                    <td class="hide-cell"><input type="checkbox" ${hide ? 'checked' : ''} onchange="updateChoice('${escapeHtml(name)}', ${i}, 'hide', this.checked)"></td>
                    <td><button class="icon-button" onclick="removeChoice('${escapeHtml(name)}', ${i})" data-i18n-title="deleteChoice" title="Delete Choice"><i class="fas fa-trash"></i></button></td>
                `;
                list.appendChild(tr);
                // (no overlays) highlighting restricted to Monaco editor only
                // Disable the "Go to State" button if the target state doesn't exist
                const scopeBtn = tr.querySelector('.scope-button');
                if (scopeBtn) {
                    const targetInput = tr.querySelector('.target-group input');
                    const targetVal = targetInput ? targetInput.value.trim() : '';
                    let targetExists = false;
                    if (targetVal) {
                        const sCount = Module._GetStateCount(editorEngine);
                        for (let si = 0; si < sCount; si++) {
                            const sPtr = Module._GetStateName(editorEngine, si);
                            const sName = Module.UTF8ToString(sPtr);
                            Module._FreeString(sPtr);
                            if (sName === targetVal) { targetExists = true; break; }
                        }
                    }
                    if (!targetVal || !targetExists) {
                        scopeBtn.setAttribute('disabled', 'disabled');
                        scopeBtn.classList.add('disabled');
                        scopeBtn.title = targetVal ? (languages[currentLanguage]['targetNotFound'] || 'Target state not found') : (languages[currentLanguage]['noTarget'] || 'No target state');
                    }
                }
            }
            Module._free(namePtr);
        }

        function filterStates() {
            const searchInput = document.getElementById('state-search');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            document.querySelectorAll('#states-list li').forEach(li => {
                try {
                    const txt = normalizeForMatching(li.textContent || '').toLowerCase();
                    try { li.hidden = !txt.includes(query); } catch (e) { li.style.display = txt.includes(query) ? 'block' : 'none'; }
                } catch (e) { try { li.hidden = false; } catch (ee) { li.style.display = 'block'; } }
            });
        }

        function scopeToState(name) {
            openTab('states');
            selectState(name);
        }

        function viewInGraph(name) {
            currentGraphState = name;
            openTab('graph');
        }

        function addState() {
            const name = generateUniqueStateName();
            try {
                Module._AddState(editorEngine, allocateUTF8(name));
                renderStates();
                selectState(name);
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus((languages[currentLanguage]['errorAddingState'] || "Error adding state: {err}").replace('{err}', err));
                } else {
                    setStatus(languages[currentLanguage]['stateAdded'] || "State added successfully");
                    // push undo/redo action for addState
                    try {
                        const action = {
                            description: { title: `Add state ${name}`, detail: `name: ${summarizeForHistory(name)}` },
                            undo: () => { removeState(name); },
                            redo: () => { const p = allocateUTF8(name); Module._AddState(editorEngine, p); Module._free(p); renderStates(); selectState(name); saveToLocalStorage(); }
                            };
                        pushProgramAction(action);
                    } catch (e) {}
                }
            } catch (e) { console.warn('addState failed', e); }
        }

        function playState(name) {
            openTab('play');
            if (typeof setPlayState === 'function') {
                setPlayState(name);
            } else {
                window.currentPlayState = name;
            }
        }
        function forcePlayState(name) {
            openTab('play');
            if (typeof setPlayState === 'function') {
                setPlayState(name, true); // true = force
            } else {
                window.currentPlayState = name;
                window.forcePlay = true;
            }
        }

        function updateStateName(oldName, newName) {
            if (newName === oldName || !newName) return;
            const oldPtr = allocateUTF8(oldName);
            const newPtr = allocateUTF8(newName);
            Module._AddState(editorEngine, newPtr);
            const titlePtr = Module._GetStateTitle(editorEngine, oldPtr);
            Module._SetStateTitle(editorEngine, newPtr, titlePtr);
            Module._FreeString(titlePtr);
            const descPtr = Module._GetStateDescription(editorEngine, oldPtr);
            Module._SetStateDescription(editorEngine, newPtr, descPtr);
            Module._FreeString(descPtr);
            const scriptPtr = Module._GetStateScript(editorEngine, oldPtr);
            Module._SetStateScript(editorEngine, newPtr, scriptPtr);
            Module._FreeString(scriptPtr);
            const reqCount = Module._GetStateRequiresCount(editorEngine, oldPtr);
            for (let i = 0; i < reqCount; i++) {
                const reqPtr = Module._GetStateRequire(editorEngine, oldPtr, i);
                Module._AddStateRequire(editorEngine, newPtr, reqPtr);
                Module._FreeString(reqPtr);
            }
            const actCount = Module._GetStateActionsCount(editorEngine, oldPtr);
            for (let i = 0; i < actCount; i++) {
                const actPtr = Module._GetStateAction(editorEngine, oldPtr, i);
                Module._AddStateAction(editorEngine, newPtr, actPtr);
                Module._FreeString(actPtr);
            }
            const propCount = Module._GetStatePropertiesCount(editorEngine, oldPtr);
            for (let i = 0; i < propCount; i++) {
                const propPtr = Module._GetStateProperty(editorEngine, oldPtr, i);
                Module._AddStateProperty(editorEngine, newPtr, propPtr);
                Module._FreeString(propPtr);
            }
            const choiceCount = Module._GetStateChoicesCount(editorEngine, oldPtr);
            for (let i = 0; i < choiceCount; i++) {
                Module._AddStateChoice(editorEngine, newPtr);
                const textPtr = Module._GetStateChoiceText(editorEngine, oldPtr, i);
                Module._SetStateChoiceText(editorEngine, newPtr, i, textPtr);
                Module._FreeString(textPtr);
                const condPtr = Module._GetStateChoiceCondition(editorEngine, oldPtr, i);
                Module._SetStateChoiceCondition(editorEngine, newPtr, i, condPtr);
                Module._FreeString(condPtr);
                const targetPtr = Module._GetStateChoiceTarget(editorEngine, oldPtr, i);
                Module._SetStateChoiceTarget(editorEngine, newPtr, i, targetPtr);
                Module._FreeString(targetPtr);
                const effectPtr = Module._GetStateChoiceEffect(editorEngine, oldPtr, i);
                Module._SetStateChoiceEffect(editorEngine, newPtr, i, effectPtr);
                Module._FreeString(effectPtr);
                const hide = Module._GetStateChoiceHide(editorEngine, oldPtr, i);
                Module._SetStateChoiceHide(editorEngine, newPtr, i, hide);
            }
            Module._RemoveState(editorEngine, oldPtr);
            Module._free(oldPtr);
            Module._free(newPtr);
            // Update DOM contextually: update list item, datalist options, choice targets and selection
            try {
                // Update selectedState reference
                if (selectedState === oldName) selectedState = newName;

                // Update the states list item text and data-name
                const li = document.querySelector(`#states-list li[data-name="${oldName}"]`);
                if (li) {
                    li.dataset.name = newName;
                    const span = li.querySelector('.state-name');
                    if (span) span.textContent = newName;
                }

                // Update datalist options for state-list
                const stateOptions = Array.from(document.querySelectorAll('#state-list option'));
                stateOptions.forEach(opt => { if (opt.value === oldName) opt.value = newName; });

                // Update any choice target inputs that reference the old name
                Array.from(document.querySelectorAll('input[list="state-list"]')).forEach(inp => {
                    if (inp.value === oldName) inp.value = newName;
                });

                // If the state-details panel is open for this state, update its name input
                const panel = document.getElementById('state-details');
                if (panel) {
                    const nameInput = panel.querySelector('input');
                    if (nameInput && nameInput.value === oldName) nameInput.value = newName;
                }

                // Update graph highlight if present
                try { highlightGraphNode(newName); } catch (e) {}
            } catch (e) {}
            saveToLocalStorage();
            const err = getLastError(editorEngine);
                if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingStateName'] || "Error updating state name: {err}").replace('{err}', err));
                }
            else {
                try {
                    const action = {
                        description: { title: `Rename state ${oldName} -> ${newName}`, detail: `${summarizeForHistory(newName)}` },
                        undo: () => { try { updateStateName(newName, oldName); renderStates(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateStateName(oldName, newName); renderStates(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    // refreshView may be expensive; do a targeted refresh of dependent UIs
                    try { updateTokens(); populateStateDatalist(); populateTokenDatalist(); } catch (e) {}
                } catch (e) {}
            }
        }

        function updateState(name, field, value) {
            const namePtr = allocateUTF8(name);
            let prev = '';
            try {
                if (field === 'title') {
                    const p = Module._GetStateTitle(editorEngine, namePtr); prev = Module.UTF8ToString(p); Module._FreeString(p);
                    const valuePtr = allocateUTF8(value); Module._SetStateTitle(editorEngine, namePtr, valuePtr); Module._free(valuePtr);
                } else if (field === 'description') {
                    const p = Module._GetStateDescription(editorEngine, namePtr); prev = Module.UTF8ToString(p); Module._FreeString(p);
                    const valuePtr = allocateUTF8(value); Module._SetStateDescription(editorEngine, namePtr, valuePtr); Module._free(valuePtr);
                } else if (field === 'script') {
                    const p = Module._GetStateScript(editorEngine, namePtr); prev = Module.UTF8ToString(p); Module._FreeString(p);
                    const valuePtr = allocateUTF8(value); Module._SetStateScript(editorEngine, namePtr, valuePtr); Module._free(valuePtr);
                }
            } catch (e) { console.warn('updateState capture failed', e); }
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingState'] || "Error updating state: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update state ${name}`, detail: `${field}: ${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateState(name, field, prev); renderStates(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateState(name, field, value); renderStates(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    // Contextual UI update: if title changed, update the corresponding list item title
                    try {
                        if (field === 'title') {
                            const li = document.querySelector(`#states-list li[data-name="${name}"]`);
                            if (li) {
                                // set innerHTML to title + span
                                li.innerHTML = `${escapeHtml(value)} <span class="state-name">${name}</span>`;
                            }
                        } else {
                            // For description/script updates, ensure the editor panel remains in sync
                            const panel = document.getElementById('state-details');
                            if (panel) {
                                // update the corresponding input/textarea if present
                                if (field === 'description') {
                                    const ta = panel.querySelector('textarea:not(#state-script-textarea)'); if (ta) ta.value = value;
                                } else if (field === 'script') {
                                    const st = panel.querySelector('#state-script-textarea'); if (st) st.value = value;
                                }
                            }
                        }
                    } catch (e) {}
                } catch (e) {}
            }
        }

        function updateStateList(name, field, value) {
            const namePtr = allocateUTF8(name);
            // capture previous list
            let prevList = '';
            try {
                const parts = [];
                let count = 0;
                if (field === 'requires') {
                    count = Module._GetStateRequiresCount(editorEngine, namePtr);
                    for (let i = 0; i < count; i++) { const p = Module._GetStateRequire(editorEngine, namePtr, i); parts.push(Module.UTF8ToString(p)); Module._FreeString(p); }
                } else if (field === 'actions') {
                    count = Module._GetStateActionsCount(editorEngine, namePtr);
                    for (let i = 0; i < count; i++) { const p = Module._GetStateAction(editorEngine, namePtr, i); parts.push(Module.UTF8ToString(p)); Module._FreeString(p); }
                } else if (field === 'properties') {
                    count = Module._GetStatePropertiesCount(editorEngine, namePtr);
                    for (let i = 0; i < count; i++) { const p = Module._GetStateProperty(editorEngine, namePtr, i); parts.push(Module.UTF8ToString(p)); Module._FreeString(p); }
                }
                prevList = parts.join(';');
            } catch (e) { console.warn('capture state list failed', e); }
            // Clear existing
            let count;
            if (field === 'requires') {
                count = Module._GetStateRequiresCount(editorEngine, namePtr);
                for (let i = count - 1; i >= 0; i--) {
                    Module._RemoveStateRequire(editorEngine, namePtr, i);
                }
            } else if (field === 'actions') {
                count = Module._GetStateActionsCount(editorEngine, namePtr);
                for (let i = count - 1; i >= 0; i--) {
                    Module._RemoveStateAction(editorEngine, namePtr, i);
                }
            } else if (field === 'properties') {
                count = Module._GetStatePropertiesCount(editorEngine, namePtr);
                for (let i = count - 1; i >= 0; i--) {
                    Module._RemoveStateProperty(editorEngine, namePtr, i);
                }
            }
            // Add new
            const items = value.split(';').map(s => s.trim()).filter(s => s);
            items.forEach(item => {
                const itemPtr = allocateUTF8(item);
                if (field === 'requires') {
                    Module._AddStateRequire(editorEngine, namePtr, itemPtr);
                } else if (field === 'actions') {
                    Module._AddStateAction(editorEngine, namePtr, itemPtr);
                } else if (field === 'properties') {
                    Module._AddStateProperty(editorEngine, namePtr, itemPtr);
                }
                Module._free(itemPtr);
            });
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingStateList'] || "Error updating state list: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update state list ${name} ${field}`, detail: `${summarizeForHistory(prevList)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateStateList(name, field, prevList); renderStates(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateStateList(name, field, value); renderStates(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
        }


        function addChoice(name) {
            const namePtr = allocateUTF8(name);
            Module._AddStateChoice(editorEngine, namePtr);
            // capture new choice data (likely empty defaults)
            const idx = Module._GetStateChoicesCount(editorEngine, namePtr) - 1;
            const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, idx);
            const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, idx);
            const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, idx);
            const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, idx);
            const hide = Module._GetStateChoiceHide(editorEngine, namePtr, idx);
            const text = Module.UTF8ToString(textPtr);
            const cond = Module.UTF8ToString(condPtr);
            const target = Module.UTF8ToString(targetPtr);
            const effect = Module.UTF8ToString(effectPtr);
            Module._FreeString(textPtr);
            Module._FreeString(condPtr);
            Module._FreeString(targetPtr);
            Module._FreeString(effectPtr);

            renderChoices(name);
            filterChoices(name);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorAddingChoice'] || "Error adding choice: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['choiceAdded'] || "Choice added successfully");
                try {
                    const action = {
                        description: { title: `Add choice ${name}`, detail: `text: ${summarizeForHistory(text)}` },
                        undo: () => { try { const p = allocateUTF8(name); const cIdx = Module._GetStateChoicesCount(editorEngine, p) - 1; if (cIdx >= 0) Module._RemoveStateChoice(editorEngine, p, cIdx); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { const p = allocateUTF8(name); Module._AddStateChoice(editorEngine, p); const newIdx = Module._GetStateChoicesCount(editorEngine, p) - 1; Module._SetStateChoiceText(editorEngine, p, newIdx, allocateUTF8(text)); Module._SetStateChoiceCondition(editorEngine, p, newIdx, allocateUTF8(cond)); Module._SetStateChoiceTarget(editorEngine, p, newIdx, allocateUTF8(target)); Module._SetStateChoiceEffect(editorEngine, p, newIdx, allocateUTF8(effect)); Module._SetStateChoiceHide(editorEngine, p, newIdx, hide); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
            Module._free(namePtr);
        }

        function updateChoice(name, i, field, value) {
            const namePtr = allocateUTF8(name);
            // capture previous value
            let prev = null;
            if (field === 'hide') {
                prev = Module._GetStateChoiceHide(editorEngine, namePtr, i);
                Module._SetStateChoiceHide(editorEngine, namePtr, i, value);
            } else if (field === 'text') {
                const prevPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceText(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            } else if (field === 'cond') {
                const prevPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceCondition(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            } else if (field === 'target') {
                const prevPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceTarget(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            } else if (field === 'effect') {
                const prevPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceEffect(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            }
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingChoice'] || "Error updating choice: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update choice ${name}`, detail: `${field}: ${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateChoice(name, i, field, prev); renderChoices(name); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateChoice(name, i, field, value); renderChoices(name); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
        }

        function removeChoice(name, i) {
            const namePtr = allocateUTF8(name);
            // capture current choice
            const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
            const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
            const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
            const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
            const hide = Module._GetStateChoiceHide(editorEngine, namePtr, i);
            const text = Module.UTF8ToString(textPtr);
            const cond = Module.UTF8ToString(condPtr);
            const target = Module.UTF8ToString(targetPtr);
            const effect = Module.UTF8ToString(effectPtr);
            Module._FreeString(textPtr);
            Module._FreeString(condPtr);
            Module._FreeString(targetPtr);
            Module._FreeString(effectPtr);

            Module._RemoveStateChoice(editorEngine, namePtr, i);
            renderChoices(name);
            filterChoices(name);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorRemovingChoice'] || "Error removing choice: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['choiceRemoved'] || "Choice removed successfully");
                try {
                    const action = {
                        description: { title: `Remove choice ${name}`, detail: `text: ${summarizeForHistory(text)}` },
                        undo: () => { try { const p = allocateUTF8(name); Module._AddStateChoice(editorEngine, p); const newIdx = Module._GetStateChoicesCount(editorEngine, p) - 1; Module._SetStateChoiceText(editorEngine, p, newIdx, allocateUTF8(text)); Module._SetStateChoiceCondition(editorEngine, p, newIdx, allocateUTF8(cond)); Module._SetStateChoiceTarget(editorEngine, p, newIdx, allocateUTF8(target)); Module._SetStateChoiceEffect(editorEngine, p, newIdx, allocateUTF8(effect)); Module._SetStateChoiceHide(editorEngine, p, newIdx, hide); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { const p = allocateUTF8(name); // find a matching choice index
                                    let found = -1; const count = Module._GetStateChoicesCount(editorEngine, p); for (let k = 0; k < count; k++) { const tPtr = Module._GetStateChoiceText(editorEngine, p, k); const t = Module.UTF8ToString(tPtr); Module._FreeString(tPtr); if (t === text) { found = k; break; } } if (found >= 0) Module._RemoveStateChoice(editorEngine, p, found); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
            Module._free(namePtr);
        }

        function removeState(name) {
            const namePtr = allocateUTF8(name);
            // capture whole state
            const state = { title: '', description: '', script: '', requires: [], actions: [], properties: [], choices: [] };
            try {
                const tPtr = Module._GetStateTitle(editorEngine, namePtr); state.title = Module.UTF8ToString(tPtr); Module._FreeString(tPtr);
                const dPtr = Module._GetStateDescription(editorEngine, namePtr); state.description = Module.UTF8ToString(dPtr); Module._FreeString(dPtr);
                const sPtr = Module._GetStateScript(editorEngine, namePtr); state.script = Module.UTF8ToString(sPtr); Module._FreeString(sPtr);
                const reqCount = Module._GetStateRequiresCount(editorEngine, namePtr);
                for (let i = 0; i < reqCount; i++) { const rPtr = Module._GetStateRequire(editorEngine, namePtr, i); state.requires.push(Module.UTF8ToString(rPtr)); Module._FreeString(rPtr); }
                const actCount = Module._GetStateActionsCount(editorEngine, namePtr);
                for (let i = 0; i < actCount; i++) { const aPtr = Module._GetStateAction(editorEngine, namePtr, i); state.actions.push(Module.UTF8ToString(aPtr)); Module._FreeString(aPtr); }
                const propCount = Module._GetStatePropertiesCount(editorEngine, namePtr);
                for (let i = 0; i < propCount; i++) { const pPtr = Module._GetStateProperty(editorEngine, namePtr, i); state.properties.push(Module.UTF8ToString(pPtr)); Module._FreeString(pPtr); }
                const choiceCount = Module._GetStateChoicesCount(editorEngine, namePtr);
                for (let i = 0; i < choiceCount; i++) {
                    const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
                    const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
                    const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
                    const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
                    const hide = Module._GetStateChoiceHide(editorEngine, namePtr, i);
                    state.choices.push({ text: Module.UTF8ToString(textPtr), cond: Module.UTF8ToString(condPtr), target: Module.UTF8ToString(targetPtr), effect: Module.UTF8ToString(effectPtr), hide });
                    Module._FreeString(textPtr); Module._FreeString(condPtr); Module._FreeString(targetPtr); Module._FreeString(effectPtr);
                }
            } catch (e) { console.warn('capture state failed', e); }

            Module._RemoveState(editorEngine, namePtr);
            renderStates();
            document.getElementById('state-details').innerHTML = '';
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorRemovingState'] || "Error removing state: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['stateRemoved'] || "State removed successfully");
                try {
                    const action = {
                        description: { title: `Remove state ${name}`, detail: `${summarizeForHistory(state.title)}` },
                        undo: () => {
                            try {
                                const nPtr = allocateUTF8(name);
                                Module._AddState(editorEngine, nPtr);
                                const tp = allocateUTF8(state.title); Module._SetStateTitle(editorEngine, nPtr, tp); Module._free(tp);
                                const dp = allocateUTF8(state.description); Module._SetStateDescription(editorEngine, nPtr, dp); Module._free(dp);
                                const sp = allocateUTF8(state.script); Module._SetStateScript(editorEngine, nPtr, sp); Module._free(sp);
                                state.requires.forEach(it => { Module._AddStateRequire(editorEngine, nPtr, allocateUTF8(it)); });
                                state.actions.forEach(it => { Module._AddStateAction(editorEngine, nPtr, allocateUTF8(it)); });
                                state.properties.forEach(it => { Module._AddStateProperty(editorEngine, nPtr, allocateUTF8(it)); });
                                state.choices.forEach(ch => { Module._AddStateChoice(editorEngine, nPtr); const idx = Module._GetStateChoicesCount(editorEngine, nPtr) - 1; Module._SetStateChoiceText(editorEngine, nPtr, idx, allocateUTF8(ch.text)); Module._SetStateChoiceCondition(editorEngine, nPtr, idx, allocateUTF8(ch.cond)); Module._SetStateChoiceTarget(editorEngine, nPtr, idx, allocateUTF8(ch.target)); Module._SetStateChoiceEffect(editorEngine, nPtr, idx, allocateUTF8(ch.effect)); Module._SetStateChoiceHide(editorEngine, nPtr, idx, ch.hide); });
                                Module._free(nPtr);
                                renderStates();
                                saveToLocalStorage();
                            } catch (e) { console.warn('undo remove state failed', e); }
                        },
                        redo: () => {
                            try { const p = allocateUTF8(name); Module._RemoveState(editorEngine, p); Module._free(p); renderStates(); saveToLocalStorage(); } catch (e) { console.warn('redo remove state failed', e); }
                        }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
            Module._free(namePtr);
        }

        function saveFile() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'edited.ns2';
            a.click();
            URL.revokeObjectURL(url);
            setStatus(languages[currentLanguage]['storySaved'] || "Story saved");
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorSavingStory'] || "Error saving story: {err}").replace('{err}', err));
            }
        }

        function generateNS2Content() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            return content;
        }

        async function initModule() {
            if (!Module) {
                if (typeof NSE2Module === 'undefined') {
                    throw new Error('NSE2Module not defined. Please make sure NSE2.js is loaded and compiled with -s EXPORT_NAME="NSE2Module" -s MODULARIZE=1');
                }
                Module = await NSE2Module();
            }
        }

        async function startPlayEngine() {
            try {
                await initModule();
                if (playEngine) {
                    // stop periodic availability refresh for previous engine
                    if (playAvailabilityInterval) {
                        clearInterval(playAvailabilityInterval);
                        playAvailabilityInterval = null;
                    }
                    Module._DestroyEngine(playEngine);
                    playEngine = null;
                }
                playEngine = Module._CreateEngine();
                const content = generateNS2Content();
                const storyPath = '/story.ns2';
                Module.FS.writeFile(storyPath, content);
                const pathPtr = allocateUTF8(storyPath);
                const loaded = Module._LoadFromFile(playEngine, pathPtr);
                Module._free(pathPtr);
                Module._Start(playEngine);
                updatePlay();  // Now safe to update UI
                setStatus(languages[currentLanguage]['playEngineStarted'] || "Play engine started");
            } catch (e) {
                const errMsg = 'Error: ' + e.message;
                document.getElementById('play-error').textContent = errMsg;
                setStatus(errMsg, true);
            }
        }

        function restartStory() {
            startPlayEngine();
            setStatus(languages[currentLanguage]['storyRestarted'] || "Story restarted");
        }

        function saveProgress() {
            if (!playEngine) {
                setStatus("No play engine running", true);
                return;
            }
            const savePath = '/save.save';
            const pathPtr = allocateUTF8(savePath);
            Module._SaveProgress(playEngine, pathPtr);
            Module._free(pathPtr);
            const saveContent = Module.FS.readFile(savePath, { encoding: 'utf8' });
            const blob = new Blob([saveContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'story.save';
            a.click();
            URL.revokeObjectURL(url);
            const err = getLastError(playEngine);
            if (err) {
                setStatus("Error saving progress: " + err, true);
            } else {
                setStatus("Progress saved");
            }
        }

        function loadProgress() {
            const file = document.getElementById('load-save').files[0];
            if (!file || !playEngine) {
                setStatus("No file or play engine not running", true);
                return;
            }
            const reader = new FileReader();
            reader.onload = e => {
                const saveContent = e.target.result;
                const savePath = '/save.save';
                Module.FS.writeFile(savePath, saveContent);
                const pathPtr = allocateUTF8(savePath);
                Module._LoadProgress(playEngine, pathPtr);
                Module._free(pathPtr);
                updatePlay();
                const err = getLastError(playEngine);
                if (err) {
                    setStatus("Error loading progress: " + err, true);
                } else {
                    setStatus("Progress loaded successfully");
                }
            };
            reader.readAsText(file);
        }

        function updatePlay() {
            if (!playEngine) {
                document.getElementById('play-title').textContent = '';
                document.getElementById('play-desc').innerHTML = '<em>Click "Start Play" to begin the story.</em>';
                document.getElementById('play-error').textContent = '';
                document.getElementById('play-choices').innerHTML = '';
                document.getElementById('play-variables').innerHTML = '';
                return;
            }

            const stateCount = Module._GetStateCount(playEngine);
            if (stateCount === 0) {
                document.getElementById('play-title').textContent = 'No Story Loaded';
                document.getElementById('play-desc').innerHTML = '<em>Create states and set a start state in the Metadata tab.</em>';
                document.getElementById('play-error').textContent = '';
                document.getElementById('play-choices').innerHTML = '';
                document.getElementById('play-variables').innerHTML = '';
                return;
            }

            const titlePtr = Module._GetCurrentTitle(playEngine);
            const title = Module.UTF8ToString(titlePtr);
            document.getElementById('play-title').textContent = title;
            Module._FreeString(titlePtr);

            const descPtr = Module._GetCurrentDescription(playEngine);
            const desc = Module.UTF8ToString(descPtr);
            document.getElementById('play-desc').textContent = desc;
            Module._FreeString(descPtr);

            const errorPtr = Module._GetStoryLastError(playEngine);
            const error = Module.UTF8ToString(errorPtr);
            document.getElementById('play-error').innerHTML = error.replace(/\n/g, '<br>');
            Module._FreeString(errorPtr);
            if (error) {
                setStatus(error);
            }

            // Update variables
            const variablesDiv = document.getElementById('play-variables');
            variablesDiv.innerHTML = '';
            const table = document.createElement('table');
            table.innerHTML = '<thead><tr><th>Variable</th><th>Value</th></tr></thead><tbody></tbody>';
            const tbody = table.querySelector('tbody');
            const count = Module._GetVariableCount(playEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetVariableName(playEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const namePtrVal = allocateUTF8(name);
                const valuePtr = Module._GetVariableValue(playEngine, namePtrVal);
                const value = Module.UTF8ToString(valuePtr);
                Module._FreeString(valuePtr);
                Module._free(namePtrVal);
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${escapeHtml(name)}</td><td><input value="${escapeHtml(value)}" onchange="setVariableValue('${escapeHtml(name)}', this.value)" onblur="setVariableValue('${escapeHtml(name)}', this.value)"></td>`;
                tbody.appendChild(tr);
            }
            variablesDiv.appendChild(table);
            filterPlayVars();

            // Retrieve available actions (names) and also full current choices
            const pActionsPtr = Module._malloc(4);
            const countAvailable = Module._GetAvailableActions(playEngine, pActionsPtr);
            const actionsArrayPtr = Module.getValue(pActionsPtr, 'i32');
            // Build a mapping from action text -> queue of available indices (handles duplicate texts)
            const availableActions = [];
            const actionIndexMap = new Map();
            for (let ai = 0; ai < countAvailable; ai++) {
                const strPtr = Module.getValue(actionsArrayPtr + ai * 4, 'i32');
                const actionText = Module.UTF8ToString(strPtr);
                availableActions.push(actionText);
                const key = normalizeForMatching(actionText);
                if (!actionIndexMap.has(key)) actionIndexMap.set(key, []);
                actionIndexMap.get(key).push(ai);
            }

            // Render all current choices but disable those that are not available
            const choicesDiv = document.getElementById('play-choices');
            choicesDiv.innerHTML = '';
            const totalChoices = Module._GetCurrentChoicesCount(playEngine);
            for (let ci = 0; ci < totalChoices; ci++) {
                const textPtr = Module._GetChoiceText(playEngine, ci);
                const text = Module.UTF8ToString(textPtr);
                Module._FreeString(textPtr);
                const btn = document.createElement('button');
                btn.textContent = text;
                // keep original text and index for later matching
                btn.dataset.choiceText = text;
                btn.dataset.choiceIndex = String(ci);
                choicesDiv.appendChild(btn);
            }

            // cleanup
            Module._FreeStrings(actionsArrayPtr, countAvailable);
            Module._free(pActionsPtr);

            // Update availability of rendered buttons now and start periodic refresh
            refreshPlayChoiceAvailability();
            filterPlayChoices();

            if (playAvailabilityInterval) clearInterval(playAvailabilityInterval);
            playAvailabilityInterval = setInterval(() => {
                if (!playEngine) {
                    clearInterval(playAvailabilityInterval);
                    playAvailabilityInterval = null;
                    return;
                }
                refreshPlayChoiceAvailability();
            }, 500);

            const isEnded = Module._IsEnded(playEngine);
            if (isEnded) {
                document.getElementById('play-desc').textContent += '\n\nThe story has ended.';
            }
        }

        function filterPlayChoices() {
            const searchInput = document.getElementById('choice-search-play');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const buttons = document.querySelectorAll('#play-choices button');
            buttons.forEach(btn => {
                try {
                    const txt = normalizeForMatching(btn.textContent || '').toLowerCase();
                    try { btn.hidden = !txt.includes(query); } catch (e) { btn.style.display = txt.includes(query) ? 'block' : 'none'; }
                } catch (e) { try { btn.hidden = false; } catch (ee) { btn.style.display = 'block'; } }
            });
        }

        function filterPlayVars() {
            const searchInput = document.getElementById('play-var-search');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const rows = document.querySelectorAll('#play-variables tbody tr');
            rows.forEach(row => {
                try {
                    const name = normalizeForMatching(row.cells[0].textContent || '').toLowerCase();
                    try { row.hidden = !name.includes(query); } catch (e) { row.style.display = name.includes(query) ? '' : 'none'; }
                } catch (e) { try { row.hidden = false; } catch (ee) { row.style.display = ''; } }
            });
        }

        // Refresh availability of buttons inside #play-choices by querying the play engine
        function refreshPlayChoiceAvailability() {
            if (!playEngine) return;
            const pActionsPtr = Module._malloc(4);
            const countAvailable = Module._GetAvailableActions(playEngine, pActionsPtr);
            const actionsArrayPtr = Module.getValue(pActionsPtr, 'i32');

            // Build index queues for normalized action texts
            const actionIndexMap = new Map();
            for (let ai = 0; ai < countAvailable; ai++) {
                const strPtr = Module.getValue(actionsArrayPtr + ai * 4, 'i32');
                const actionText = Module.UTF8ToString(strPtr);
                const key = normalizeForMatching(actionText);
                if (!actionIndexMap.has(key)) actionIndexMap.set(key, []);
                actionIndexMap.get(key).push(ai);
            }

            const choicesDiv = document.getElementById('play-choices');
            if (!choicesDiv) {
                Module._FreeStrings(actionsArrayPtr, countAvailable);
                Module._free(pActionsPtr);
                return;
            }

            const buttons = Array.from(choicesDiv.querySelectorAll('button'));
            buttons.forEach(btn => {
                const original = btn.dataset.choiceText || btn.textContent || '';
                const ci = parseInt(btn.dataset.choiceIndex || '-1', 10);

                // First: check target visitability for this specific choice index
                let choiceTarget = '';
                try {
                    const targetPtr = Module._GetChoiceTarget(playEngine, ci);
                    choiceTarget = Module.UTF8ToString(targetPtr);
                    Module._FreeString(targetPtr);
                } catch (e) {
                    // fallback: no specific target info available
                    choiceTarget = '';
                }

                // If a target exists, check whether it can be visited now
                let targetVisitOk = true;
                if (choiceTarget) {
                    try {
                        const tPtr = allocateUTF8(choiceTarget);
                        const canVisit = Module._CanVisitState(playEngine, tPtr);
                        targetVisitOk = !!canVisit;
                        Module._free(tPtr);
                    } catch (e) {
                        targetVisitOk = true; // if API not available, conservatively allow
                    }
                }

                if (!targetVisitOk) {
                    // Target explicitly not visitable: disable
                    btn.setAttribute('disabled', 'disabled');
                    btn.classList.add('disabled');
                    btn.title = languages[currentLanguage]['choiceUnavailable'] || 'Choice unavailable';
                    btn.onclick = null;
                    return;
                }

                // Otherwise, fall back to matching available actions by normalized text
                const norm = normalizeForMatching(original);
                const queue = actionIndexMap.get(norm);
                if (queue && queue.length > 0) {
                    const availIndex = queue.shift();
                    btn.removeAttribute('disabled');
                    btn.classList.remove('disabled');
                    btn.title = '';
                    // assign onclick to advance using this available index
                    btn.onclick = () => {
                        try {
                            // capture pre and post snapshots to allow reliable undo/redo
                            const before = savePlaySnapshot(playEngine);
                            Module._Advance(playEngine, availIndex);
                            const err = getLastError(playEngine);
                            if (err) setStatus("Error advancing: " + err, true);
                            updatePlay();
                            const after = savePlaySnapshot(playEngine);
                            try {
                                            const action = {
                                                description: { title: `Advance action`, detail: `index: ${availIndex}` },
                                                undo: () => { try { restorePlaySnapshot(playEngine, before); } catch (e) {} },
                                                redo: () => { try { restorePlaySnapshot(playEngine, after); } catch (e) {} }
                                            };
                                pushProgramAction(action);
                            } catch (e) {}
                        } catch (e) { console.warn('advance wrapper failed', e); }
                    };
                } else {
                    // not available: disable and remove handler
                    btn.setAttribute('disabled', 'disabled');
                    btn.classList.add('disabled');
                    btn.title = languages[currentLanguage]['choiceUnavailable'] || 'Choice unavailable';
                    btn.onclick = null;
                }
            });

            Module._FreeStrings(actionsArrayPtr, countAvailable);
            Module._free(pActionsPtr);
        }

        function setVariableValue(name, value) {
            if (!playEngine) return;
            const namePtr = allocateUTF8(name);
            // capture previous value
            let prev = '';
            try {
                const prevPtr = Module._GetVariableValue(playEngine, namePtr);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
            } catch (e) { prev = ''; }
            const valuePtr = allocateUTF8(value);
            Module._SetVariableValue(playEngine, namePtr, valuePtr);
            Module._free(valuePtr);
            Module._free(namePtr);
            updatePlay();
            const err = getLastError(playEngine);
            if (err) {
                setStatus("Error setting variable value: " + err, true);
            } else {
                try {
                    const action = {
                        description: { title: `Set variable ${name}`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { const np = allocateUTF8(name); const pv = allocateUTF8(prev); Module._SetVariableValue(playEngine, np, pv); Module._free(np); Module._free(pv); updatePlay(); } catch (e) {} },
                        redo: () => { try { const np = allocateUTF8(name); const nv = allocateUTF8(value); Module._SetVariableValue(playEngine, np, nv); Module._free(np); Module._free(nv); updatePlay(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
        }

        function buildGraph() {
            let adj = {};
            let radj = {};
            const count = Module._GetStateCount(editorEngine);
            for (let si = 0; si < count; si++) {
                const fromPtr = Module._GetStateName(editorEngine, si);
                const from = Module.UTF8ToString(fromPtr);
                Module._FreeString(fromPtr);
                adj[from] = [];
                radj[from] = [];
                const fromPtr2 = allocateUTF8(from);
                const choiceCount = Module._GetStateChoicesCount(editorEngine, fromPtr2);
                for (let ci = 0; ci < choiceCount; ci++) {
                    const targetPtr = Module._GetStateChoiceTarget(editorEngine, fromPtr2, ci);
                    const target = Module.UTF8ToString(targetPtr);
                    Module._FreeString(targetPtr);
                    const labelPtr = Module._GetStateChoiceText(editorEngine, fromPtr2, ci);
                    const label = Module.UTF8ToString(labelPtr);
                    Module._FreeString(labelPtr);
                    if (target) {
                        adj[from].push({ to: target, label: label || '' });
                        if (!radj[target]) radj[target] = [];
                        radj[target].push({ from: from, label: label || '' });
                    }
                }
                Module._free(fromPtr2);
            }
            return { adj, radj };
        }

        function getNeighbors(start, depth) {
            const { adj, radj } = buildGraph();
            let nodes = new Set();
            let queue = [{ node: start, d: 0 }];
            nodes.add(start);
            while (queue.length) {
                let { node, d } = queue.shift();
                if (d >= depth) continue;
                (adj[node] || []).forEach(({ to }) => {
                    if (!nodes.has(to)) {
                        nodes.add(to);
                        queue.push({ node: to, d: d + 1 });
                    }
                });
                (radj[node] || []).forEach(({ from }) => {
                    if (!nodes.has(from)) {
                        nodes.add(from);
                        queue.push({ node: from, d: d + 1 });
                    }
                });
            }
            return nodes;
        }

        function generateGraphDef(start = null) {
            const { adj, radj } = buildGraph();
            let graphDef = 'flowchart TD\n';
            let nodes = start ? getNeighbors(start, 2) : new Set(Object.keys(adj));
            if (nodes.size === 0) {
                graphDef += '    A["No states defined"]';
                return graphDef;
            }

            // Map original state names to safe mermaid node IDs (avoid spaces/reserved words)
            const idMap = {};
            let idCounter = 1;
            function makeId(name) {
                if (idMap[name]) return idMap[name];
                const id = 'n' + (idCounter++);
                idMap[name] = id;
                return id;
            }

            function escLabel(s) {
                if (!s && s !== 0) return '';
                return String(s).replace(/\|/g, '&#124;').replace(/"/g, '\\"').replace(/\n/g, ' ');
            }

            // Emit node definitions using safe IDs, but show the real title as label
            for (let name of nodes) {
                const namePtr = allocateUTF8(name);
                const sTitlePtr = Module._GetStateTitle(editorEngine, namePtr);
                const sTitle = Module.UTF8ToString(sTitlePtr);
                Module._FreeString(sTitlePtr);
                Module._free(namePtr);
                const id = makeId(name);
                // embed an internal-name marker in the label so we can map rendered nodes back to internal state names
                const marker = '@@ID@@' + name;
                graphDef += `    ${id}["${escLabel(sTitle || name)}"]\n`;
            }

            // expose reverse mapping id -> state name for fallback resolution
            window.graphIdToStateName = {};
            Object.keys(idMap).forEach(k => {
                window.graphIdToStateName[idMap[k]] = k;
            });

            // Emit edges using mapped IDs and sanitized labels
            for (let from of nodes) {
                (adj[from] || []).forEach(({ to, label }) => {
                    if (nodes.has(to)) {
                        const fromId = makeId(from);
                        const toId = makeId(to);
                        graphDef += `    ${fromId} -->|${escLabel(label)}| ${toId}\n`;
                    }
                });
            }

            if (start) {
                const startId = idMap[start] || makeId(start);
                graphDef += `    style ${startId} fill:#007bb0,stroke:#007bb0,stroke-width:2px\n`;
            }
            return graphDef;
        }

        function renderMermaid(graphDef) {
            const container = document.getElementById('graph-container');
            container.innerHTML = '';
            mermaid.render('graphDiv', graphDef).then(({ svg }) => {
                // Inject SVG-internal styles so rules apply inside the generated <svg>
                const injectStyle = `
                    <defs>
                        <linearGradient id="ueGradient" x1="0%" x2="0%" y1="0%" y2="100%">
                            <stop offset="0%" stop-color="#1b6b8a" stop-opacity="1"/>
                            <stop offset="60%" stop-color="#0f394a" stop-opacity="1"/>
                            <stop offset="100%" stop-color="#0b2b36" stop-opacity="1"/>
                        </linearGradient>
                        <filter id="ueDrop" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="0" dy="8" stdDeviation="16" flood-color="#000" flood-opacity="0.45"/>
                        </filter>
                    </defs>
                    <style>
                        /* Apply UE-like gradient + shadow to node bodies */
                        .node rect { fill: url(#ueGradient) !important; stroke: rgba(0,0,0,0.6) !important; stroke-width: 1.5px !important; filter: url(#ueDrop) !important; rx:8; ry:8; }
                        /* Slightly brighter stroke for hovered/selected states */
                        .node:hover rect, .node.graph-hover rect { stroke: #33c3ff !important; stroke-width: 2px !important; }
                        .node.graph-selected rect { stroke: #ffd166 !important; stroke-width: 2.5px !important; }
                        /* Node title styling */
                        .node text { fill: #FFFFFF !important; font-weight:700 !important; font-family: 'Segoe UI', Roboto, sans-serif !important; font-size:12px !important; text-shadow: 0 2px 6px rgba(0,0,0,0.6); }
                        /* Edge appearance */
                        .edgePath .path { stroke: #99e6ff !important; stroke-width: 2.5px !important; stroke-linecap: round !important; }
                        /* Make labels legible */
                        .edgeLabel, .edgeLabel text { fill: #e6fbff !important; }
                    </style>
                `;
                // Insert style right after opening <svg ...>
                const svgWithStyle = svg.replace(/<svg([^>]*)>/i, `<svg$1>${injectStyle}`);
                container.innerHTML = svgWithStyle;
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    svgElement.removeAttribute('width');
                    svgElement.removeAttribute('height');
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                    svgElement.style.maxWidth = 'none';
                    const ns = 'http://www.w3.org/2000/svg';
                    const contentG = svgElement.querySelector('g');
                    // No overlay/pins — we style existing Mermaid nodes with SVG-local defs/styles above
                    graphPanZoom = panzoom(contentG, { 
                        maxZoom: 5, 
                        minZoom: 0.1, 
                        bounds: false
                    });
                    const bbox = contentG.getBBox();
                    const containerRect = container.getBoundingClientRect();
                    const scale = Math.min(containerRect.width / bbox.width, containerRect.height / bbox.height) * 0.8;
                    // Set initial zoom and center
                    if (typeof graphPanZoom.zoomAbs === 'function') graphPanZoom.zoomAbs(0, 0, scale);
                    const offsetX = (containerRect.width / 2) - (bbox.width * scale / 2) - (bbox.x * scale);
                    const offsetY = (containerRect.height / 2) - (bbox.height * scale / 2) - (bbox.y * scale);
                    if (typeof graphPanZoom.moveTo === 'function') graphPanZoom.moveTo(offsetX, offsetY);
                    // Track current scale and add safe zoomIn/zoomOut helpers in case panzoom lacks them
                    try {
                        graphCurrentScale = scale || 1;
                        // Provide consistent zoomIn/zoomOut methods that use zoomAbs
                        graphPanZoom._zoomDelta = function(delta) {
                            // delta is multiplicative factor (e.g. 0.1 -> +10%)
                            const factor = 1 + (delta || 0.1);
                            graphCurrentScale = Math.max(Math.min(graphCurrentScale * factor, 5), 0.1);
                            if (typeof graphPanZoom.zoomAbs === 'function') graphPanZoom.zoomAbs(0, 0, graphCurrentScale);
                        };
                        graphPanZoom.zoomIn = function(delta) { graphPanZoom._zoomDelta(delta || 0.1); };
                        graphPanZoom.zoomOut = function(delta) { graphPanZoom._zoomDelta(-(delta || 0.1)); };
                    } catch (e) {}
                    const nodes = svgElement.querySelectorAll('.node');
                    nodes.forEach(node => {
                        const labelElement = node.querySelector('text');
                        if (labelElement) {
                            // Add a blueprint-style header band and input/output pins
                            try {
                                const ns = 'http://www.w3.org/2000/svg';
                                // Try to use the node's primary shape bbox (rect/polygon) so header aligns correctly
                                let baseShape = node.querySelector('rect, polygon, path, ellipse');
                                let shapeBBox = null;
                                try {
                                    if (baseShape) shapeBBox = baseShape.getBBox();
                                } catch (e) { shapeBBox = null; }
                                // Fallback to group's bbox
                                let nodeBBox = null;
                                try { nodeBBox = node.getBBox(); } catch (e) { nodeBBox = null; }
                                const refBBox = shapeBBox || nodeBBox || { x: 0, y: 0, width: 120, height: 48 };
                                const headerH = Math.max(18, Math.min(32, refBBox.height * 0.22));

                                // Avoid duplicating when re-rendering: create an overlay group painted last
                                if (!node.querySelector('.bp-overlay')) {
                                    const overlay = document.createElementNS(ns, 'g');
                                    overlay.setAttribute('class', 'bp-overlay');
                                    overlay.style.pointerEvents = 'none';

                                    // Header rect appended into overlay so it is rendered on top
                                    const headerRect = document.createElementNS(ns, 'rect');
                                    headerRect.setAttribute('class', 'bp-header');
                                    headerRect.setAttribute('x', String(refBBox.x));
                                    headerRect.setAttribute('y', String(refBBox.y));
                                    headerRect.setAttribute('width', String(Math.max(8, refBBox.width)));
                                    headerRect.setAttribute('height', String(Math.max(6, headerH)));
                                    headerRect.setAttribute('rx', '6');
                                    headerRect.setAttribute('ry', '6');
                                    // inline styles to ensure visibility even if external CSS fails
                                    headerRect.setAttribute('fill', '#0b66a1');
                                    headerRect.setAttribute('stroke', 'rgba(0,0,0,0.4)');
                                    headerRect.setAttribute('stroke-width', '1');
                                    overlay.appendChild(headerRect);

                                    // Pins: left (input) and right (output)
                                    const pinRadius = Math.max(4, Math.min(7, headerH * 0.36));
                                    const cy = refBBox.y + (headerH / 2);
                                    const leftCx = refBBox.x - (pinRadius + 2);
                                    const rightCx = refBBox.x + refBBox.width + (pinRadius + 2);

                                    const leftPin = document.createElementNS(ns, 'circle');
                                    leftPin.setAttribute('class', 'bp-pin in');
                                    leftPin.setAttribute('cx', String(leftCx));
                                    leftPin.setAttribute('cy', String(cy));
                                    leftPin.setAttribute('r', String(pinRadius));
                                    leftPin.setAttribute('fill', '#7ed6ff');
                                    leftPin.setAttribute('stroke', '#00a3d1');
                                    leftPin.setAttribute('stroke-width', '1');
                                    overlay.appendChild(leftPin);

                                    const rightPin = document.createElementNS(ns, 'circle');
                                    rightPin.setAttribute('class', 'bp-pin out');
                                    rightPin.setAttribute('cx', String(rightCx));
                                    rightPin.setAttribute('cy', String(cy));
                                    rightPin.setAttribute('r', String(pinRadius));
                                    rightPin.setAttribute('fill', '#ffd166');
                                    rightPin.setAttribute('stroke', '#ff9f1c');
                                    rightPin.setAttribute('stroke-width', '1');
                                    overlay.appendChild(rightPin);

                                    // Append overlay as last child of node so it paints on top
                                    node.appendChild(overlay);
                                }
                            } catch (e) {
                                // if SVG bbox access fails (browser quirk), ignore and continue
                            }
                            // Determine internal state name from the node's id via window.graphIdToStateName mapping
                            const fullId = node.id || node.getAttribute('id') || '';
                            
                            
                            // Mermaid adds a prefix like 'flowchart-' to node IDs
                            // Extract the base ID (e.g., 'n4' from 'flowchart-n4-3')
                            let baseId = fullId;
                            if (fullId.includes('-')) {
                                // Try to extract n<number> pattern
                                const match = fullId.match(/n\d+/);
                                if (match) {
                                    baseId = match[0];
                                }
                            }
                            
                            
                            let internalName = null;
                            if (baseId && window.graphIdToStateName && window.graphIdToStateName[baseId]) {
                                internalName = window.graphIdToStateName[baseId];
                            } else {
                                // Fallback: try to match the visible label text to a state title or name
                                const labelText = (labelElement.textContent || '').trim();
                                
                                if (labelText) {
                                    try {
                                        const stateCount = Module._GetStateCount(editorEngine);
                                        for (let si = 0; si < stateCount; si++) {
                                            const sNamePtr = Module._GetStateName(editorEngine, si);
                                            const sName = Module.UTF8ToString(sNamePtr);
                                            Module._FreeString(sNamePtr);
                                            const sTitlePtr = Module._GetStateTitle(editorEngine, allocateUTF8(sName));
                                            const sTitle = Module.UTF8ToString(sTitlePtr);
                                            Module._FreeString(sTitlePtr);
                                            if (sTitle === labelText || sName === labelText) {
                                                internalName = sName;
                                                break;
                                            }
                                        }
                                    } catch (e) {
                                    }
                                }
                                // Last resort: use the raw label text as-is
                                if (!internalName) {
                                    internalName = labelText || '';
                                    
                                }
                            }
                            node.setAttribute('data-state', internalName);

                            // Ensure pointer events and visual cursor on SVG nodes and children
                            try {
                                node.style.pointerEvents = 'auto';
                                node.style.cursor = 'pointer';
                                Array.from(node.querySelectorAll('*')).forEach(el => { try { el.style.pointerEvents = 'auto'; el.style.cursor = 'pointer'; } catch (e) {} });
                            } catch (e) {}

                            // Debug mapping
                            

                            // Only attempt to fetch state description/title if we have a likely internal name
                            let desc = '';
                            try {
                                if (internalName) {
                                    // verify state exists by searching for internalName among state names
                                    let found = false;
                                    const sc = Module._GetStateCount(editorEngine);
                                    for (let s = 0; s < sc; s++) {
                                        const nPtr = Module._GetStateName(editorEngine, s);
                                        const n = Module.UTF8ToString(nPtr);
                                        Module._FreeString(nPtr);
                                        if (n === internalName) { found = true; break; }
                                    }
                                    if (found) {
                                        const namePtr = allocateUTF8(internalName);
                                        const descPtr = Module._GetStateDescription(editorEngine, namePtr);
                                        desc = Module.UTF8ToString(descPtr);
                                        Module._FreeString(descPtr);
                                        Module._free(namePtr);
                                    }
                                }
                            } catch (e) {
                                console.warn('[renderMermaid] error fetching state description:', e);
                            }
                            const title = document.createElementNS(ns, 'title');
                            title.textContent = (desc && desc.slice) ? desc.slice(0, 200) : '';
                            node.appendChild(title);

                            // Helper to open state
                            const openStateFromNode = (ev) => {
                                try { ev && ev.stopPropagation(); } catch (e) {}
                                if (internalName) {
                                    scopeToState(internalName);
                                    openTab('states');
                                }
                            };

                            // Helper to show context menu
                            const showContextFromNode = (ev) => {
                                if (document.getElementById('tab-graph').classList.contains('active')) {
                                    try { ev && ev.preventDefault(); } catch (e) {}
                                    graphSelectedState = internalName;
                                    showGraphContextMenu((ev && ev.pageX) || 0, (ev && ev.pageY) || 0);
                                }
                            };

                            // Attach listeners in capture phase for robustness
                            try {
                                node.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); }, { passive: true, capture: true });
                                node.addEventListener('click', openStateFromNode, true);
                                node.addEventListener('contextmenu', showContextFromNode, true);
                            } catch (e) {
                                // fallback
                                node.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); });
                                node.addEventListener('click', openStateFromNode);
                                node.addEventListener('contextmenu', showContextFromNode);
                            }

                            // Also attach to inner shape/text to ensure events fire when those elements capture them
                            const innerShape = node.querySelector('rect, polygon, circle, ellipse, path');
                            if (innerShape) {
                                try { innerShape.style.cursor = 'pointer'; innerShape.style.pointerEvents = 'auto'; } catch (e) {}
                                innerShape.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); }, true);
                                innerShape.addEventListener('click', openStateFromNode, true);
                                innerShape.addEventListener('contextmenu', showContextFromNode, true);
                            }
                            if (labelElement) {
                                try { labelElement.style.cursor = 'pointer'; labelElement.style.pointerEvents = 'none'; } catch (e) {}
                                labelElement.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); }, true);
                                labelElement.addEventListener('click', openStateFromNode, true);
                                labelElement.addEventListener('contextmenu', showContextFromNode, true);
                            }

                            // Hover visual
                            node.addEventListener('pointerenter', () => { node.classList.add('graph-hover'); }, true);
                            node.addEventListener('pointerleave', () => { node.classList.remove('graph-hover'); }, true);

                            // Insert small Font Awesome icon overlay (foreignObject) at top-left of node
                            try {
                                const nodeBBox = node.getBBox();
                                const fo = document.createElementNS(ns, 'foreignObject');
                                fo.setAttribute('x', String(nodeBBox.x + 6));
                                fo.setAttribute('y', String(nodeBBox.y + 6));
                                fo.setAttribute('width', '18');
                                fo.setAttribute('height', '18');
                                fo.setAttribute('class', 'graph-icon-fo');
                                fo.innerHTML = `<div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"width:18px;height:18px;display:flex;align-items:center;justify-content:center;pointer-events:none\"><i class=\"fas fa-book\" style=\"font-size:13px;color:#fff;font-family:'Font Awesome 6 Free';font-weight:900;\"></i></div>`;
                                node.appendChild(fo);
                            } catch (e) {}
                        }
                    });

                    // Diagnostics: log how many nodes and overlays were created (dev only)
                    try { console.debug('[renderMermaid] nodes:', nodes.length, 'bp-overlays:', svgElement.querySelectorAll('.bp-overlay').length); } catch(e) {}

                    // Fallback: container-level click handler to catch clicks that don't reach node elements
                    try {
                        // remove previous handler if present
                        if (container._graphClickHandler) container.removeEventListener('click', container._graphClickHandler, true);
                        container._graphClickHandler = function(e) {
                            try {
                                const node = e.target && e.target.closest && e.target.closest('.node');
                                if (node) {
                                    const st = node.getAttribute('data-state') || node.dataset.state;
                                    if (st) {
                                        // primary button only
                                        if (e.button === 0 || e.type === 'click') {
                                            e.stopPropagation();
                                            scopeToState(st);
                                            openTab('states');
                                        }
                                    }
                                }
                            } catch (err) {}
                        };
                        container.addEventListener('click', container._graphClickHandler, true);
                        // remove previous pointer handlers if present
                        if (container._graphPointerDown) {
                            container.removeEventListener('pointerdown', container._graphPointerDown, true);
                            container.removeEventListener('pointermove', container._graphPointerMove, true);
                            container.removeEventListener('pointerup', container._graphPointerUp, true);
                            container.removeEventListener('contextmenu', container._graphContext, true);
                        }

                        // pointer tracking to distinguish click vs drag (so pan/zoom still works)
                        container._graphPointerTracker = {};
                        container._graphPointerDown = function(e) {
                            try {
                                if (!e.isPrimary) return;
                                container._graphPointerTracker.pointerId = e.pointerId;
                                container._graphPointerTracker.startX = e.clientX;
                                container._graphPointerTracker.startY = e.clientY;
                                container._graphPointerTracker.moved = false;
                                container._graphPointerTracker.downTarget = (e.target && e.target.closest) ? e.target.closest('.node') : null;
                            } catch (err) {}
                        };
                        container._graphPointerMove = function(e) {
                            try {
                                const t = container._graphPointerTracker;
                                if (!t || typeof t.startX !== 'number') return;
                                const dx = e.clientX - t.startX;
                                const dy = e.clientY - t.startY;
                                if (Math.hypot(dx, dy) > 6) t.moved = true;
                            } catch (err) {}
                        };
                        container._graphPointerUp = function(e) {
                            try {
                                const t = container._graphPointerTracker;
                                if (!t) return;
                                // only primary
                                if (e.button !== 0) return;
                                const clickedNode = (e.target && e.target.closest) ? e.target.closest('.node') : null;
                                // prefer the node where pointerdown started
                                const node = t.downTarget || clickedNode;
                                if (node && !t.moved) {
                                    const st = node.getAttribute('data-state') || node.dataset.state;
                                    if (st) {
                                        try { e.stopPropagation(); } catch (er) {}
                                        scopeToState(st);
                                        openTab('states');
                                    }
                                }
                                // reset tracker
                                container._graphPointerTracker = {};
                            } catch (err) {}
                        };

                        container._graphContext = function(e) {
                            try {
                                // find node under cursor at event position
                                const el = document.elementFromPoint(e.clientX, e.clientY);
                                const node = el && el.closest ? el.closest('.node') : null;
                                if (node) {
                                    e.preventDefault();
                                    // Try attribute first
                                    let st = node.getAttribute('data-state') || node.dataset.state || null;
                                    // If not set or empty, try to resolve via node id -> mapping
                                    if (!st) {
                                        try {
                                            const fullId = node.id || node.getAttribute('id') || '';
                                            let baseId = fullId;
                                            if (fullId && fullId.includes('-')) {
                                                const match = fullId.match(/n\d+/);
                                                if (match) baseId = match[0];
                                            }
                                            if (baseId && window.graphIdToStateName && window.graphIdToStateName[baseId]) {
                                                st = window.graphIdToStateName[baseId];
                                            }
                                        } catch (e) {
                                        
                                        }
                                    }

                                    // If still not resolved, try matching visible label text to state titles/names (case-insensitive)
                                    if (!st) {
                                        try {
                                            const labelEl = node.querySelector && node.querySelector('text');
                                            const labelText = labelEl ? (labelEl.textContent || '').trim().toLowerCase() : '';
                                            if (labelText) {
                                                const sc = Module._GetStateCount(editorEngine);
                                                for (let si = 0; si < sc; si++) {
                                                    const nPtr = Module._GetStateName(editorEngine, si);
                                                    const n = Module.UTF8ToString(nPtr);
                                                    Module._FreeString(nPtr);
                                                    const tPtr = Module._GetStateTitle(editorEngine, allocateUTF8(n));
                                                    const t = Module.UTF8ToString(tPtr);
                                                    Module._FreeString(tPtr);
                                                    if ((n && n.toLowerCase().trim() === labelText) || (t && t.toLowerCase().trim() === labelText)) {
                                                        st = n;
                                                        break;
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                        
                                        }
                                    }

                                    
                                    graphSelectedState = st || null;
                                    showGraphContextMenu(e.pageX, e.pageY);
                                } else {
                                    
                                }
                            } catch (err) {
                                console.error('[graph context] error:', err);
                            }
                        };

                        container.addEventListener('pointerdown', container._graphPointerDown, true);
                        container.addEventListener('pointermove', container._graphPointerMove, true);
                        container.addEventListener('pointerup', container._graphPointerUp, true);
                        container.addEventListener('contextmenu', container._graphContext, true);
                    } catch (e) {}
                    // If a specific graph state was requested, highlight it now (ensure UI centers on it)
                            try {
                                if (typeof highlightGraphNode === 'function' && currentGraphState) {
                                    // schedule on next tick so DOM/SVG is fully ready
                                    setTimeout(() => {
                                        try { highlightGraphNode(currentGraphState); } catch (e) { }
                                    }, 30);
                                }
                            } catch (e) {}
                }
            }).catch(e => {
                const container = document.getElementById('graph-container');
                container.innerHTML = '<div style="color: #D4D4D4; text-align: center; padding: 20px;">Error rendering graph: ' + e.message + '</div>';
                setStatus("Error rendering graph: " + e.message, true);
            });
        }

        function renderGraph() {
            const count = Module._GetStateCount(editorEngine);
            const graphDef = generateGraphDef(currentGraphState);
            renderMermaid(graphDef);
        }

        function resetGraph() {
            currentGraphState = null;
            renderGraph();
        }

        function zoomIn() {
            if (graphPanZoom) {
                graphPanZoom.zoomIn(0.1);
            }
        }

        function zoomOut() {
            if (graphPanZoom) {
                graphPanZoom.zoomOut(0.1);
            }
        }

        function centerGraph() {
            if (graphPanZoom) {
                const container = document.getElementById('graph-container');
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    const contentG = svgElement.querySelector('g');
                    const bbox = contentG.getBBox();
                    const containerRect = container.getBoundingClientRect();
                    const scale = Math.min(containerRect.width / bbox.width, containerRect.height / bbox.height) * 0.8;
                    graphPanZoom.zoomAbs(0, 0, scale);
                    const offsetX = (containerRect.width / 2) - (bbox.width * scale / 2) - (bbox.x * scale);
                    const offsetY = (containerRect.height / 2) - (bbox.height * scale / 2) - (bbox.y * scale);
                    graphPanZoom.moveTo(offsetX, offsetY);
                }
            }
        }

        // Highlight a graph node corresponding to a state name, and center it in view
        function highlightGraphNode(stateName) {
            const container = document.getElementById('graph-container');
            if (!container) return;
            const svgElement = container.querySelector('svg');
            if (!svgElement) return;
            // remove previous selection
            svgElement.querySelectorAll('.node.graph-selected').forEach(n => n.classList.remove('graph-selected'));
            if (!stateName) return;
            // find node by data-state
            const node = svgElement.querySelector(`.node[data-state="${CSS.escape(stateName)}"]`) || svgElement.querySelector(`.node[data-state='${stateName}']`);
            if (!node) return;
            node.classList.add('graph-selected');
            // try to center the node
            try {
                const contentG = svgElement.querySelector('g');
                const bbox = node.getBBox();
                const containerRect = container.getBoundingClientRect();
                const scale = Math.min(containerRect.width / bbox.width, containerRect.height / bbox.height) * 0.6;
                if (graphPanZoom && typeof graphPanZoom.zoomAbs === 'function') graphPanZoom.zoomAbs(0, 0, scale);
                const offsetX = (containerRect.width / 2) - (bbox.width * scale / 2) - (bbox.x * scale);
                const offsetY = (containerRect.height / 2) - (bbox.height * scale / 2) - (bbox.y * scale);
                if (graphPanZoom && typeof graphPanZoom.moveTo === 'function') graphPanZoom.moveTo(offsetX, offsetY);
            } catch (e) {}
        }
        function setupContextMenu() {
            // Global contextmenu handler with tab check
            document.addEventListener('contextmenu', (e) => {
                const activeTab = document.querySelector('.tab-content.active');
                const target = e.target;
                if (activeTab && activeTab.contains(target)) {
                    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                        e.preventDefault();
                        currentInput = target;
                        showContextMenu(e.pageX, e.pageY);
                    }
                } else if (target.closest('#graph-container') && document.getElementById('tab-graph').classList.contains('active')) {
                    // Graph-specific: let it bubble so container handler can process it
                    // Do NOT preventDefault here; let the container._graphContext handler do it
                    
                }
                // Otherwise, allow default inspect
            }, true); // Use capture phase for higher priority
            document.addEventListener('click', hideContextMenu);
            document.addEventListener('click', hideGraphContextMenu);
            // Close context/graph menus on Escape key (capture phase)
            document.addEventListener('keydown', (e) => {
                try {
                    if (e.key === 'Escape' || e.key === 'Esc') {
                        const cm = document.getElementById('context-menu');
                        const gm = document.getElementById('graph-context-menu');
                        let closed = false;
                        if (cm && cm.style && cm.style.display && cm.style.display !== 'none') { hideContextMenu(); closed = true; }
                        if (gm && gm.style && gm.style.display && gm.style.display !== 'none') { hideGraphContextMenu(); closed = true; }
                        if (closed) { e.stopPropagation(); e.preventDefault(); }
                    }
                } catch (ex) {}
            }, true);
            document.getElementById('context-menu').addEventListener('click', (e) => e.stopPropagation());
            const ctxSearch = document.getElementById('context-search');
            if (ctxSearch) {
                try { ctxSearch.addEventListener('focus', (e) => e.stopPropagation()); } catch (e) {}
                try { ctxSearch.addEventListener('mousedown', (e) => e.stopPropagation()); } catch (e) {}
                try { ctxSearch.addEventListener('click', (e) => e.stopPropagation()); } catch (e) {}
                // Ensure input events reach filterContextMenu even if inline handlers fail
                try { ctxSearch.addEventListener('input', filterContextMenu); } catch (e) {}
            }

            // Global input listener for debugging and to catch dropdown search inputs
            // input event listener (no debug logging)
            document.addEventListener('input', (e) => {
                try {
                    const t = e.target;
                    if (!t) return;
                    // previously logged debug events here; removed for production
                } catch (ex) {}
            }, true);
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 's':
                            e.preventDefault();
                            saveFile();
                            break;
                        case 'o':
                            e.preventDefault();
                            document.getElementById('file-input').click();
                            break;
                        case 'n':
                            e.preventDefault();
                            newStory();
                            break;
                    }

                    if (e.key >= '1' && e.key <= '6') {
                        e.preventDefault();
                        const tabs = ['text', 'metadata', 'variables', 'states', 'graph', 'play'];
                        openTab(tabs[parseInt(e.key) - 1]);
                    }
                }
                const activeTab = document.querySelector('.tab-button.active').textContent.toLowerCase();
                if (activeTab === 'graph') {
                    switch (e.key) {
                        case '=':
                        case '+':
                            e.preventDefault();
                            zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            zoomOut();
                            break;
                        case '0':
                            e.preventDefault();
                            centerGraph();
                            break;
                        case 'arrowleft':
                            e.preventDefault();
                            if (graphPanZoom) graphPanZoom.moveBy(-20, 0);
                            break;
                        case 'arrowright':
                            e.preventDefault();
                            if (graphPanZoom) graphPanZoom.moveBy(20, 0);
                            break;
                        case 'arrowup':
                            e.preventDefault();
                            if (graphPanZoom) graphPanZoom.moveBy(0, -20);
                            break;
                        case 'arrowdown':
                            e.preventDefault();
                            if (graphPanZoom) graphPanZoom.moveBy(0, 20);
                            break;
                    }
                }
            });
        }

        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const list = document.getElementById('token-menu-list');
            list.innerHTML = '';
            try { console.log('[ns2] showContextMenu', { x: x, y: y, hasInput: !!currentInput }); } catch(e) {}

            // Copy, Cut, Paste first, always visible with icons
                const copyLi = document.createElement('li');
                copyLi.className = 'menu-item';
                const copyLabel = languages[currentLanguage] && languages[currentLanguage]['Copy'] ? languages[currentLanguage]['Copy'] : 'Copy';
                copyLi.innerHTML = `<i class="fas fa-copy" style="margin-right: 8px;"></i> <span class="token">${copyLabel}</span>`;
            copyLi.onclick = () => {
                currentInput.select();
                document.execCommand('copy');
                hideContextMenu();
            };
            list.appendChild(copyLi);

            const cutLi = document.createElement('li');
            cutLi.className = 'menu-item';
            const cutLabel = languages[currentLanguage] && languages[currentLanguage]['Cut'] ? languages[currentLanguage]['Cut'] : 'Cut';
            cutLi.innerHTML = `<i class="fas fa-cut" style="margin-right: 8px;"></i> <span class="token">${cutLabel}</span>`;
            cutLi.onclick = () => {
                currentInput.select();
                document.execCommand('cut');
                hideContextMenu();
            };
            list.appendChild(cutLi);

            const pasteLi = document.createElement('li');
            pasteLi.className = 'menu-item';
            const pasteLabel = languages[currentLanguage] && languages[currentLanguage]['Paste'] ? languages[currentLanguage]['Paste'] : 'Paste';
            pasteLi.innerHTML = `<i class="fas fa-paste" style="margin-right: 8px;"></i> <span class="token">${pasteLabel}</span>`;
            pasteLi.onclick = () => {
                navigator.clipboard.readText().then(text => {
                    insertTextAtCursor(currentInput, text);
                    hideContextMenu();
                });
            };
            list.appendChild(pasteLi);

            const separator = document.createElement('li');
            separator.className = 'menu-separator';
            separator.setAttribute('aria-hidden', 'true');
            separator.style.borderTop = '1px solid #3C3C3C';
            separator.style.padding = '0';
            separator.style.margin = '5px 0';
            separator.style.pointerEvents = 'none';
            list.appendChild(separator);

            // Then tokens, grouped by category for easier discovery
            const categorized = {
                'Functions': [],
                'Operators': [],
                'Constants': [],
                'States': [],
                'Variables': [],
                'Other': []
            };

            tokens.forEach(token => {
                if (functionTokens.includes(token)) categorized['Functions'].push(token);
                else if (operatorTokens.includes(token)) categorized['Operators'].push(token);
                else if (constantTokens.includes(token)) categorized['Constants'].push(token);
                else if (stateTokens.includes(token)) categorized['States'].push(token);
                else if (variableTokens.includes(token)) categorized['Variables'].push(token);
                else categorized['Other'].push(token);
            });

            // Sort each category alphabetically (natural order) and render with headers
            Object.keys(categorized).forEach(cat => {
                const items = Array.from(new Set(categorized[cat])).sort((a,b) => a.localeCompare(b, undefined, {numeric:true, sensitivity:'base'}));
                if (!items.length) return;

                // category header
                const header = document.createElement('li');
                header.className = 'menu-category';
                header.textContent = cat;
                list.appendChild(header);

                items.forEach(token => {
                    const li = document.createElement('li');
                    li.className = 'menu-item';
                    const tokenSpan = document.createElement('span'); tokenSpan.className = 'token'; tokenSpan.textContent = token;
                    const exampleSpan = document.createElement('span'); exampleSpan.className = 'example'; exampleSpan.textContent = tokenExamples[token] || '';
                    li.appendChild(tokenSpan);
                    li.appendChild(exampleSpan);
                    li.onclick = () => insertTextAtCursor(currentInput, token);
                    list.appendChild(li);
                });

                // separator between categories
                const sep = document.createElement('li');
                sep.className = 'menu-separator';
                sep.setAttribute('aria-hidden', 'true');
                sep.style.borderTop = '1px solid #3C3C3C';
                sep.style.padding = '0';
                sep.style.margin = '6px 0';
                sep.style.pointerEvents = 'none';
                list.appendChild(sep);
            });

            document.getElementById('context-search').value = '';
            filterContextMenu();
            // Place menu and clamp to viewport so it never clips offscreen
            menu.style.visibility = 'hidden';
            menu.style.display = 'flex';
            // allow layout to occur then measure
            requestAnimationFrame(() => {
                const rect = menu.getBoundingClientRect();
                const margin = 8;
                let left = x;
                let top = y;
                // clamp horizontally
                if (left + rect.width > window.innerWidth - margin) left = Math.max(margin, window.innerWidth - rect.width - margin);
                if (left < margin) left = margin;
                // clamp vertically; prefer below cursor, otherwise place above
                if (top + rect.height > window.innerHeight - margin) {
                    // try placing above cursor
                    if (y - rect.height > margin) top = Math.max(margin, y - rect.height);
                    else top = Math.max(margin, window.innerHeight - rect.height - margin);
                }
                if (top < margin) top = margin;
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                menu.style.visibility = 'visible';
            });
        }

        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }

        function filterContextMenu() {
                    const raw = (document.getElementById('context-search') && document.getElementById('context-search').value) || '';
                    const query = normalizeForMatching(raw).toLowerCase();
                    // debug logging removed

                    // Prefer explicit menu-item markers, but fall back to any LI (excluding categories/separators)
                    let items = Array.from(document.querySelectorAll('#token-menu-list li.menu-item'));
                    if (!items.length) {
                        items = Array.from(document.querySelectorAll('#token-menu-list li')).filter(li => {
                            if (li.classList && (li.classList.contains('menu-category') || li.classList.contains('menu-separator'))) return false;
                            return true;
                        });
                    }

                    // debug logging removed

                    items.forEach((li, idx) => {
                        try {
                            // Collect a few sensible text sources so this works across different menu renderers
                            let tokenTextRaw = '';
                            const tokenEl = li.querySelector && (li.querySelector('.token') || li.querySelector('.example') || li.querySelector('button') || li.querySelector('span'));
                            if (tokenEl && tokenEl.textContent) tokenTextRaw = tokenEl.textContent;
                            else if (li.dataset && li.dataset.name) tokenTextRaw = li.dataset.name;
                            else tokenTextRaw = li.textContent || '';

                            const tokenText = normalizeForMatching(tokenTextRaw).toLowerCase();
                            const ok = (query === '' || tokenText.includes(query));
                            // Use the boolean `hidden` attribute rather than inline display toggles.
                            // This is more reliable and works with the CSS rule we added above.
                            try { li.hidden = !ok; } catch (e) { li.style.display = ok ? '' : 'none'; }
                            // log first few items for diagnostics
                            // debug logging removed
                        } catch (e) { try { ns2Debug({ err: 'item-check-failed', idx: idx }); } catch(e) {} }
                    });

                    // Now adjust category headers and separators based on whether their items are visible
                    const headers = Array.from(document.querySelectorAll('#token-menu-list li.menu-category'));
                    headers.forEach(header => {
                        let anyVisible = false;
                        let node = header.nextElementSibling;
                        while (node) {
                            if (node.classList && node.classList.contains('menu-category')) break; // next category
                            // skip over separators
                            if (node.classList && node.classList.contains('menu-separator')) { node = node.nextElementSibling; continue; }
                            // If an element is not hidden (or doesn't have hidden true), consider it visible
                            if (!(node.hidden === true) && (node.style ? node.style.display !== 'none' : true)) { anyVisible = true; break; }
                            node = node.nextElementSibling;
                        }
                        try { header.hidden = !anyVisible; } catch(e) { header.style.display = anyVisible ? 'block' : 'none'; }
                        // find separator after this category and show/hide it accordingly
                        let sep = header.nextElementSibling;
                        while (sep) {
                            if (sep.classList && sep.classList.contains('menu-separator')) { try { sep.hidden = !anyVisible; } catch(e) { sep.style.display = anyVisible ? 'block' : 'none'; } break; }
                            if (sep.classList && sep.classList.contains('menu-category')) break;
                            sep = sep.nextElementSibling;
                        }
                    });
        }

        function insertTextAtCursor(input, text) {
            const start = input.selectionStart;
            const end = input.selectionEnd;
            input.value = input.value.substring(0, start) + text + input.value.substring(end);
            input.selectionStart = input.selectionEnd = start + text.length;
            input.focus();
            hideContextMenu();
            input.dispatchEvent(new Event('change'));
        }

        function showGraphContextMenu(x, y) {
            const menu = document.getElementById('graph-context-menu');
            menu.className = '';
            menu.innerHTML = '';

            function resolveGraphSelectedState() {
                if (!graphSelectedState) return null;
                try {
                    const sc = Module._GetStateCount(editorEngine);
                    const needle = String(graphSelectedState).trim();
                    for (let si = 0; si < sc; si++) {
                        const nPtr = Module._GetStateName(editorEngine, si);
                        const n = Module.UTF8ToString(nPtr);
                        Module._FreeString(nPtr);
                        if (n === needle) return n;
                        // compare titles as fallback
                        try {
                            const tPtr = Module._GetStateTitle(editorEngine, allocateUTF8(n));
                            const t = Module.UTF8ToString(tPtr);
                            Module._FreeString(tPtr);
                            if (t === needle) return n;
                        } catch (e) {}
                    }
                } catch (e) {
                }
                return null;
            }

            const resolved = resolveGraphSelectedState();

            const options = [
                { icon: 'fas fa-eye', label: languages[currentLanguage]['View in States'] || 'View in States', action: () => { if (resolved) scopeToState(resolved); } },
                { icon: 'fas fa-expand', label: languages[currentLanguage]['View in Graph'] || 'View in Graph', action: () => { if (resolved) { currentGraphState = resolved; viewInGraph(resolved); } } },
                { icon: 'fas fa-star', label: languages[currentLanguage]['Set as Start'] || 'Set as Start', action: () => { if (resolved) setAsStart(resolved); } },
                { icon: 'fas fa-play', label: languages[currentLanguage]['Play State'] || 'Play State', action: () => { if (resolved) playState(resolved); } },
                { icon: 'fas fa-forward', label: languages[currentLanguage]['Force Play State'] || 'Force Play State', action: () => { if (resolved) forcePlayState(resolved); } },
                { icon: 'fas fa-trash', label: languages[currentLanguage]['Delete State'] || 'Delete State', action: () => { if (resolved) deleteState(resolved); } },
            ];

            const inner = document.createElement('div');
            inner.className = 'button-container';
            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.onclick = (e) => { e.stopPropagation(); menu.style.display = 'none'; opt.action(); };
                btn.innerHTML = `<i class="${opt.icon}" style="margin-right:8px;"></i> ${opt.label}`;
                if (!resolved) {
                    btn.setAttribute('disabled', 'disabled');
                    btn.classList.add('disabled');
                }
                inner.appendChild(btn);
            });
            menu.appendChild(inner);
            // Clamp graph context menu to viewport similarly to token menu
            menu.style.visibility = 'hidden';
            menu.style.display = 'block';
            requestAnimationFrame(() => {
                const rect = menu.getBoundingClientRect();
                const margin = 8;
                let left = x;
                let top = y;
                if (left + rect.width > window.innerWidth - margin) left = Math.max(margin, window.innerWidth - rect.width - margin);
                if (left < margin) left = margin;
                if (top + rect.height > window.innerHeight - margin) {
                    if (y - rect.height > margin) top = Math.max(margin, y - rect.height);
                    else top = Math.max(margin, window.innerHeight - rect.height - margin);
                }
                if (top < margin) top = margin;
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                menu.style.visibility = 'visible';
            });
        }

        function hideGraphContextMenu() {
            document.getElementById('graph-context-menu').style.display = 'none';
        }

        function viewStateFromGraph() {
                if (graphSelectedState) {
                    scopeToState(graphSelectedState);
                }
            hideGraphContextMenu();
        }

        function deleteState(name) {
            if (!name) return;
            if (confirm((languages[currentLanguage]['confirmDeleteState'] || 'Delete state "{name}"?').replace('{name}', name))) {
                removeState(name);
                // Refresh graph view
                try {
                    // clear any graph selection referencing the deleted state
                    if (graphSelectedState === name) graphSelectedState = null;
                    renderGraph();
                } catch (e) {}
            }
        }

        function updateTokens() {
            stateTokens = [];
            const stateCount = Module._GetStateCount(editorEngine);
            for (let i = 0; i < stateCount; i++) {
                const namePtr = Module._GetStateName(editorEngine, i);
                stateTokens.push(Module.UTF8ToString(namePtr));
                Module._FreeString(namePtr);
            }
            variableTokens = [];
            const varCount = Module._GetVariableCount(editorEngine);
            for (let i = 0; i < varCount; i++) {
                const namePtr = Module._GetVariableName(editorEngine, i);
                variableTokens.push(Module.UTF8ToString(namePtr));
                Module._FreeString(namePtr);
            }
            tokens = [...stateTokens, ...variableTokens, ...functionTokens, ...operatorTokens, ...constantTokens];
            tokens = [...new Set(tokens)].sort();
            // Re-register Monarch provider when state list changes so state names highlight consistently
            try {
                if (window.monaco && typeof setNs2Monarch === 'function') setNs2Monarch(monarchDefinition);
            } catch (e) {}
        }

        function renderEditor() {
            const titlePtr = Module._GetStoryTitle(editorEngine);
            const currentTitle = Module.UTF8ToString(titlePtr);
            document.getElementById('story-title').value = currentTitle;
            // keep toolbar title in sync (if toolbar exists)
            const tb = document.getElementById('toolbar-story-title');
            if(tb) tb.textContent = currentTitle || (languages[currentLanguage]['untitled'] || 'Untitled');
            Module._FreeString(titlePtr);
            document.getElementById('story-title').onchange = function() {
                const prevPtr = Module._GetStoryTitle(editorEngine);
                const prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const newVal = this.value;
                Module._SetStoryTitle(editorEngine, allocateUTF8(newVal));
                // update toolbar copy
                try{ const el = document.getElementById('toolbar-story-title'); if(el) el.textContent = newVal || (languages[currentLanguage]['untitled'] || 'Untitled'); }catch(e){}
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus("Error setting story title: " + err, true);
                } else {
                    try {
                        const action = {
                            description: { title: `Set story title`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(newVal)}` },
                            undo: () => { try { Module._SetStoryTitle(editorEngine, allocateUTF8(prev)); renderEditor(); saveToLocalStorage(); } catch (e) {} },
                            redo: () => { try { Module._SetStoryTitle(editorEngine, allocateUTF8(newVal)); renderEditor(); saveToLocalStorage(); } catch (e) {} }
                        };
                        pushProgramAction(action);
                    } catch (e) {}
                }
            };

            const descPtr = Module._GetStoryDescription(editorEngine);
            const storyDescEl = document.getElementById('story-description');
            storyDescEl.value = Module.UTF8ToString(descPtr);
            Module._FreeString(descPtr);
            function autoResizeTextarea(el) {
                el.style.height = 'auto';
                el.style.height = (el.scrollHeight) + 'px';
            }
            // Apply immediately and on input to auto-save and expand
            // track last saved description to push a single history entry on blur
            let lastSavedDesc = storyDescEl.value;
            storyDescEl.addEventListener('input', function() {
                autoResizeTextarea(this);
                Module._SetStoryDescription(editorEngine, allocateUTF8(this.value));
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus("Error setting story description: " + err, true);
                }
            });
            storyDescEl.addEventListener('blur', function() {
                const prev = lastSavedDesc;
                const newVal = this.value;
                if (prev === newVal) return;
                try {
                    const action = {
                        description: { title: `Edit story description`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(newVal)}` },
                        undo: () => { try { Module._SetStoryDescription(editorEngine, allocateUTF8(prev)); renderEditor(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { Module._SetStoryDescription(editorEngine, allocateUTF8(newVal)); renderEditor(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    lastSavedDesc = newVal;
                } catch (e) {}
            });
            // initial resize
            setTimeout(() => autoResizeTextarea(storyDescEl), 0);
            const startPtr = Module._GetStartState(editorEngine);
            document.getElementById('start-state').value = Module.UTF8ToString(startPtr);
            Module._FreeString(startPtr);
            document.getElementById('start-state').onchange = function() {
                const prevPtr = Module._GetStartState(editorEngine);
                const prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const newVal = this.value;
                Module._SetStartState(editorEngine, allocateUTF8(newVal));
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus("Error setting start state: " + err, true);
                } else {
                    try {
                        const action = {
                            description: { title: `Set start state`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(newVal)}` },
                            undo: () => { try { Module._SetStartState(editorEngine, allocateUTF8(prev)); renderEditor(); saveToLocalStorage(); } catch (e) {} },
                            redo: () => { try { Module._SetStartState(editorEngine, allocateUTF8(newVal)); renderEditor(); saveToLocalStorage(); } catch (e) {} }
                        };
                        pushProgramAction(action);
                        // Contextual update: if this state's choices panel is visible, update the specific row
                        try {
                            const panelTbody = document.getElementById(`choices-${name}`);
                            if (panelTbody && panelTbody.rows && panelTbody.rows[i]) {
                                const row = panelTbody.rows[i];
                                if (field === 'text') {
                                    const inp = row.cells[0].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'cond') {
                                    const inp = row.cells[1].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'target') {
                                    const inp = row.cells[2].querySelector('.target-group input'); if (inp) inp.value = value;
                                } else if (field === 'effect') {
                                    const inp = row.cells[3].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'hide') {
                                    const cb = row.cells[4] && row.cells[4].querySelector('input[type="checkbox"]'); if (cb) cb.checked = !!value;
                                }
                            }
                        } catch (e) {}
                    } catch (e) {}
                }
            };
            updateTokens();
            populateStateDatalist();
            populateTokenDatalist();
            renderVariables();
            renderStates();
            document.getElementById('editor').style.display = 'block';
            setupContextMenu();
            setupKeyboardShortcuts();
            setupStatusWindow();
            setStatus("Editor ready");
        }

        function openHelp(page) {
            window.open(page + '.html', '_self');
        }

        function updateGlobalToolbar(tabName) {
            const toolbar = document.getElementById('global-toolbar');
            toolbar.innerHTML = '';
            toolbar.style.display = 'flex';

            function makeBtn(html, title, onclick, extraClass) {
                const b = document.createElement('button');
                b.className = 'icon-button' + (extraClass ? ' ' + extraClass : '');
                if (onclick) b.onclick = onclick;
                b.title = title || '';
                b.innerHTML = html;
                return b;
            }

            function addGroupLabel(group, labelText) {
                const label = document.createElement('div');
                label.className = 'group-label';
                label.textContent = labelText;
                group.appendChild(label);
            }

            // FILE group (global)
            const fileGroup = document.createElement('div'); fileGroup.className = 'toolbar-group group-file'; fileGroup.id = 'toolbar-file-group';
            // (toolbar story title moved to header menubar for layout: logo -> editor -> | -> story -> buttons)

            fileGroup.appendChild(Object.assign(makeBtn('<i class="fas fa-file"></i>', languages[currentLanguage]['newStory'] || 'New Story', newStory), {}));
            fileGroup.appendChild(Object.assign(makeBtn('<i class="fas fa-folder-open"></i>', languages[currentLanguage]['loadStory'] || 'Load Story', () => document.getElementById('file-input').click()), {}));
            fileGroup.appendChild(Object.assign(makeBtn('<i class="fas fa-save"></i>', languages[currentLanguage]['saveStory'] || 'Save Story', saveFile), {}));
            // Save As button (matches toolbar style)
            const saveAsBtn = makeBtn('<i class="fas fa-file-export"></i>', languages[currentLanguage]['saveAs'] || 'Save As', function(){
                try{
                    if(typeof window.saveFileAs === 'function') return window.saveFileAs();
                    if(typeof saveFileAs === 'function') return saveFileAs();
                    if(typeof window.saveFile === 'function') return window.saveFile();
                }catch(e){ console.warn(e); }
            });
            saveAsBtn.id = 'electron-saveas-btn';
            fileGroup.appendChild(Object.assign(saveAsBtn, {}));
            addGroupLabel(fileGroup, 'FILE');
            toolbar.appendChild(fileGroup);

            // Create a container for contextual groups (states, variables, graph)
            const contextContainer = document.createElement('div'); contextContainer.className = 'toolbar-context-container';
            // Append file group first, then contextual groups, then play/tools to enforce ordering
            toolbar.appendChild(contextContainer);

            // PLAY group (global)
            const playGroup = document.createElement('div'); playGroup.className = 'toolbar-group';
            playGroup.appendChild(makeBtn('<i class="fas fa-play"></i>', languages[currentLanguage]['Play Current Story'] || 'Play Current Story', () => { startPlayEngine(); openTab('play'); }));
            playGroup.appendChild(makeBtn('<i class="fas fa-upload"></i>', languages[currentLanguage]['Load Progress'] || 'Load Progress', () => { document.getElementById('load-save').click(); openTab('play'); }));
            playGroup.appendChild(makeBtn('<i class="fas fa-download"></i>', languages[currentLanguage]['Save Progress'] || 'Save Progress', () => { saveProgress(); openTab('play'); }));
            playGroup.appendChild(makeBtn('<i class="fas fa-redo"></i>', languages[currentLanguage]['Restart'] || 'Restart', () => { restartStory(); openTab('play'); }));
            addGroupLabel(playGroup, 'PLAY');
            

            // Tab-specific: VARIABLES group (only on variables tab)
            if (tabName === 'variables') {
                const variablesGroup = document.createElement('div'); variablesGroup.className = 'toolbar-group toolbar-context';
                const addVarBtn = makeBtn('<i class="fas fa-plus"></i>', languages[currentLanguage]['addVariable'] || 'Add Variable', addVariable);
                variablesGroup.appendChild(addVarBtn);
                addGroupLabel(variablesGroup, 'VARIABLES');
                contextContainer.appendChild(variablesGroup);
            }

            // Tab-specific: STATES group (only on states tab)
            if (tabName === 'states') {
                const statesGroup = document.createElement('div'); statesGroup.className = 'toolbar-group toolbar-context';
                const addStateBtn = makeBtn('<i class="fas fa-plus"></i>', languages[currentLanguage]['addState'] || 'Add State', addState);
                statesGroup.appendChild(addStateBtn);
                const deleteBtn = makeBtn('<i class="fas fa-trash"></i>', languages[currentLanguage]['Delete State'] || 'Delete State', () => { if (selectedState) removeState(selectedState); });
                statesGroup.appendChild(deleteBtn);
                const startBtn = makeBtn('<i class="fas fa-flag"></i>', languages[currentLanguage]['Set as Start'] || 'Set as Start', () => { if (selectedState) setAsStart(selectedState); });
                statesGroup.appendChild(startBtn);
                const jumpBtn = makeBtn('<i class="fas fa-play"></i>', languages[currentLanguage]['Jump to State'] || 'Jump to State', () => { if (selectedState) { jumpToState(selectedState); openTab('play'); } });
                try {
                    if (typeof playEngine !== 'undefined' && playEngine && selectedState) {
                        const sPtr = allocateUTF8(selectedState);
                        const canVisit = Module._CanVisitState(playEngine, sPtr);
                        Module._free(sPtr);
                        if (!canVisit) {
                            jumpBtn.setAttribute('disabled', 'disabled');
                            jumpBtn.classList.add('disabled');
                            jumpBtn.title = languages[currentLanguage]['cannotVisitState'] || 'State not visitable in current play session';
                        }
                    } else if (!selectedState) {
                        jumpBtn.setAttribute('disabled', 'disabled');
                        jumpBtn.classList.add('disabled');
                    }
                } catch (e) {
                    // ignore if API not present
                }
                statesGroup.appendChild(jumpBtn);
                const forceBtn = makeBtn('<i class="fas fa-forward"></i>', languages[currentLanguage]['Force Jump'] || 'Force Jump', () => { if (selectedState) { forceJumpToState(selectedState); openTab('play'); } }, 'force-visit');
                statesGroup.appendChild(forceBtn);
                const graphBtn = makeBtn('<i class="fas fa-project-diagram"></i>', languages[currentLanguage]['View in Graph'] || 'View in Graph', () => { if (selectedState) viewInGraph(selectedState); });
                statesGroup.appendChild(graphBtn);
                addGroupLabel(statesGroup, 'STATES');
                contextContainer.appendChild(statesGroup);
            }

            // Tab-specific: GRAPH group (only on graph tab)
            if (tabName === 'graph') {
                const graphGroup = document.createElement('div'); graphGroup.className = 'toolbar-group toolbar-context';
                graphGroup.appendChild(makeBtn('<i class="fas fa-sync"></i>', languages[currentLanguage]['Reset Graph'] || 'Reset Graph', resetGraph));
                graphGroup.appendChild(makeBtn('<i class="fas fa-search-plus"></i>', languages[currentLanguage]['Zoom In'] || 'Zoom In', zoomIn));
                graphGroup.appendChild(makeBtn('<i class="fas fa-search-minus"></i>', languages[currentLanguage]['Zoom Out'] || 'Zoom Out', zoomOut));
                graphGroup.appendChild(makeBtn('<i class="fas fa-crosshairs"></i>', languages[currentLanguage]['Center Graph'] || 'Center Graph', centerGraph));
                addGroupLabel(graphGroup, 'GRAPH');
                contextContainer.appendChild(graphGroup);
            }

            // TOOLS group (language + help + view toggles merged)
            const toolsGroup = document.createElement('div'); toolsGroup.className = 'toolbar-group';
            // Undo / Redo (program-level) - do not interfere with Monaco's own undo
            const undoBtn = makeBtn('<i class="fas fa-undo"></i>', 'Undo', () => { undoProgram(); });
            undoBtn.dataset.action = 'undo-btn';
            try { if (historyIndex === 0) { undoBtn.setAttribute('disabled', 'disabled'); undoBtn.classList.add('disabled'); } } catch (e) {}
            toolsGroup.appendChild(undoBtn);
            const redoBtn = makeBtn('<i class="fas fa-redo"></i>', 'Redo', () => { redoProgram(); });
            redoBtn.dataset.action = 'redo-btn';
            try { if (historyIndex >= programHistory.length) { redoBtn.setAttribute('disabled', 'disabled'); redoBtn.classList.add('disabled'); } } catch (e) {}
            toolsGroup.appendChild(redoBtn);
            // small caret button to open the undo/redo history dropdown (placed to the right of redo)
            const undoMenuBtn = makeBtn('<i class="fas fa-caret-down"></i>', 'Undo/Redo History', null, 'small-caret');
            undoMenuBtn.onclick = () => { toggleDropdown('undo-dropdown', undoMenuBtn); };
            toolsGroup.appendChild(undoMenuBtn);
            // Toggle status button (moved from VIEW group into TOOLS)
            const toggleStatusBtn = makeBtn('<i class="fas fa-window-maximize"></i>', languages[currentLanguage]['toggleStatus'] || 'Toggle Status Window', null);
            toggleStatusBtn.onclick = () => { toggleDropdown('status-window', toggleStatusBtn); };
            toolsGroup.appendChild(toggleStatusBtn);
            const langBtn = makeBtn('<i class="fas fa-globe"></i>', languages[currentLanguage]['language'] || 'Language', null);
            langBtn.onclick = () => { toggleDropdown('language-dropdown', langBtn); };
            toolsGroup.appendChild(langBtn);
            const helpBtn = makeBtn('<i class="fas fa-question-circle"></i>', languages[currentLanguage]['help'] || 'Help', null);
            helpBtn.onclick = () => { toggleDropdown('help-dropdown', helpBtn); };
            toolsGroup.appendChild(helpBtn);
            addGroupLabel(toolsGroup, 'TOOLS');
            // Ensure playGroup is inserted before tools so the final order is: FILE -> CONTEXT -> PLAY -> TOOLS
            try { if (typeof playGroup !== 'undefined') toolbar.appendChild(playGroup); } catch (e) {}
            toolbar.appendChild(toolsGroup);

            toolbar.style.pointerEvents = 'auto';
            try { updateToolbarUndoButtons(); } catch (e) {}
            // Ensure toolbar overflow is arranged (move groups into overflow if they don't fit)
            try { arrangeToolbarOverflow(); } catch (e) {}
        }

        // Arrange toolbar groups into an overflow menu when they don't fit
        function arrangeToolbarOverflow() {
            const toolbar = document.getElementById('global-toolbar');
            if (!toolbar) return;
            // create overflow holder if missing
            let overflow = toolbar.querySelector('.toolbar-overflow');
            if (!overflow) {
                overflow = document.createElement('div');
                overflow.className = 'toolbar-overflow toolbar-group';
                overflow.id = 'toolbar-overflow';
                const overflowBtn = document.createElement('button');
                overflowBtn.className = 'icon-button overflow-btn';
                overflowBtn.innerHTML = '<i class="fas fa-ellipsis-h"></i>';
                overflowBtn.title = 'More';
                overflowBtn.onclick = (e) => {
                    const menu = overflow.querySelector('.overflow-menu');
                    if (!menu) return;
                    menu.style.display = (menu.style.display === 'block') ? '' : 'block';
                };
                const menu = document.createElement('div');
                menu.className = 'overflow-menu';
                overflow.appendChild(overflowBtn);
                overflow.appendChild(menu);
                toolbar.appendChild(overflow);
            }
            const menu = overflow.querySelector('.overflow-menu');
            // move any previously overflowed groups back to toolbar before measuring
            while (menu && menu.firstChild) {
                const g = menu.firstChild;
                toolbar.insertBefore(g, overflow);
            }

            // compute available space (reserve overflow button width)
            const toolbarWidth = toolbar.clientWidth;
            const overflowBtnWidth = overflow.offsetWidth || 40;
            let used = 0;
            const children = Array.from(toolbar.children).filter(c => c !== overflow);
            // measure from left to right, move groups that overflow into the overflow menu
            for (const ch of children) {
                // ensure element is visible for measurement
                ch.style.display = '';
                const w = ch.offsetWidth;
                if (used + w + overflowBtnWidth > toolbarWidth) {
                    // move this and all following into overflow
                    const following = Array.from(toolbar.children).filter(c => c !== overflow).slice(children.indexOf(ch));
                    following.forEach(f => { try { menu.appendChild(f); } catch (e) {} });
                    break;
                }
                used += w;
            }
            // hide overflow if empty
            if (menu && menu.children.length === 0) overflow.style.display = 'none'; else overflow.style.display = '';
        }

        // Close overflow menus on resize or click outside
        window.addEventListener('resize', () => { try { arrangeToolbarOverflow(); } catch (e) {} });
        document.addEventListener('click', (e) => {
            const of = document.getElementById('toolbar-overflow');
            if (!of) return;
            const menu = of.querySelector('.overflow-menu');
            if (!menu) return;
            if (!of.contains(e.target)) menu.style.display = '';
        });

        // Toggle an existing dropdown container (positions it under the anchor)
        function toggleDropdown(dropdownId, anchorEl) {
            const dd = document.getElementById(dropdownId);
            if (!dd || !anchorEl) return;
            if (dd.dataset.visible === '1') {
                dd.style.display = '';
                dd.dataset.visible = '';
                return;
            }
            // Close other open dropdowns first
            document.querySelectorAll('.dropdown-menu').forEach(d => {
                if (d.id !== dropdownId && d.dataset.visible === '1') {
                    d.style.display = '';
                    d.dataset.visible = '';
                }
            });

            // If this is the undo dropdown, refresh its contents
            try { if (dropdownId === 'undo-dropdown') updateUndoDropdown(); } catch (e) {}
            // Position dropdown below anchor
            const rect = anchorEl.getBoundingClientRect();
            dd.style.position = 'fixed';
            // start hidden state for animation
            dd.style.display = 'block';
            dd.style.opacity = '0';
            dd.style.transform = 'translateY(-8px) scale(0.98)';
            dd.style.zIndex = 110;
            dd.dataset.visible = '1';

            // Animate into place and clamp horizontally to viewport
            requestAnimationFrame(() => {
                const b = dd.getBoundingClientRect();
                let left = Math.max(8, Math.min(rect.left, window.innerWidth - b.width - 8));
                let top = rect.bottom + 8;
                // If bottom would overflow, open above anchor
                if (top + b.height > window.innerHeight - 8) {
                    top = rect.top - b.height - 8;
                }
                dd.style.left = left + 'px';
                dd.style.top = top + 'px';
                dd.style.transition = 'opacity 160ms ease, transform 160ms ease';
                dd.style.opacity = '1';
                dd.style.transform = 'translateY(0) scale(1)';
                // match header-like background so dropdown is visible
                dd.style.background = 'linear-gradient(0deg, rgba(17,17,17,0.96) 0%, rgba(30,30,30,0.96) 100%)';
                dd.style.backdropFilter = 'blur(8px)';
                dd.style.boxShadow = '0 8px 32px rgba(0,0,0,0.3)';
                dd.style.border = '1px solid rgba(60,60,60,0.8)';
            });

            function outsideClick(e) {
                if (!dd.contains(e.target) && !anchorEl.contains(e.target)) {
                    dd.style.display = '';
                    dd.dataset.visible = '';
                    document.removeEventListener('click', outsideClick);
                }
            }
            setTimeout(() => document.addEventListener('click', outsideClick), 0);
        }

        function setupStatusWindow() {
            // Status window is now a dropdown anchored to the toolbar; no dragging needed.
            const windowElement = document.getElementById('status-window');
            if (windowElement) {
                windowElement.style.display = '';
                windowElement.dataset.visible = '';
            }
            const copyBtn = document.getElementById('status-copy');
            if (copyBtn) {
                copyBtn.onclick = copyStatusContent;
            }
        }

        function copyStatusContent() {
            try {
                const play = document.getElementById('play-error') ? document.getElementById('play-error').innerText : '';
                const status = document.getElementById('status-content') ? document.getElementById('status-content').innerText : '';
                const combined = [play, status].filter(Boolean).join('\n\n');
                if (!combined) { setStatus(languages[currentLanguage]['nothingToCopy'] || 'Nothing to copy'); return; }
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(combined).then(() => { setStatus(languages[currentLanguage]['copiedToClipboard'] || 'Status copied to clipboard'); }, () => { fallbackCopy(combined); });
                } else {
                    fallbackCopy(combined);
                }
            } catch (e) { console.warn('copyStatusContent failed', e); setStatus(languages[currentLanguage]['copyFailed'] || 'Copy failed', true); }
        }

        function fallbackCopy(text) {
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed'; ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.select();
            try {
                document.execCommand('copy');
                setStatus(languages[currentLanguage]['copiedToClipboard'] || 'Status copied to clipboard');
            } catch (e) {
                setStatus(languages[currentLanguage]['copyFailed'] || 'Copy failed', true);
            }
            ta.remove();
        }

        function makeDraggable(element, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            handle.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // Toolbar mouse tracking removed — toolbar is now static in the header next to Language/Help

        (async () => {
            await loadLanguages();
            await initModule();
            editorEngine = Module._CreateEngine();
            const savedContent = localStorage.getItem('ns2_content');
            if (savedContent) {
                Module.FS.writeFile('/story.ns2', savedContent);
                const pathPtr = allocateUTF8('/story.ns2');
                const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                Module._free(pathPtr);
                if (loaded) {
                    renderEditor();
                    setStatus("Loaded saved story from local storage");
                } else {
                    setStatus("Failed to load saved story: " + getLastError(editorEngine));
                }
            } else {
            }
            renderEditor();
            openTab('metadata');
            updateGlobalToolbar('metadata');
            window.addEventListener('storage', (event) => {
                if (event.key === 'ns2_content' && event.newValue) {
                    Module.FS.writeFile('/story.ns2', event.newValue);
                    const pathPtr = allocateUTF8('/story.ns2');
                    const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                    Module._free(pathPtr);
                    if (loaded) {
                        renderEditor();
                        setStatus("Story updated from storage");
                    } else {
                        setStatus("Failed to update story from storage: " + getLastError(editorEngine));
                    }
                }
            });
        })();
        </script>

        <script>
        (function(){
            if(!window || !window.document) return;
            if(!window.electronAPI) return; // only run inside Electron where preload exposes electronAPI
            console.info('Electron bridge detected — enabling disk I/O overrides');

            // keep track of an opened path (if available)
            let electronCurrentPath = null;

            async function electronOpenFile(){
                try{
                    const res = await window.electronAPI.openFile();
                    if(!res) return;
                    if(res.error){ console.error('openFile error', res.error); return; }
                    electronCurrentPath = res.path || null;
                    // If there is a function that accepts the file contents, prefer it
                    if(typeof window.loadFromString === 'function'){
                        return window.loadFromString(res.content);
                    }
                    if(typeof window.openFromString === 'function'){
                        return window.openFromString(res.content);
                    }
                    // Try to find an editor textarea and populate it
                    const ta = document.querySelector('textarea#file-content') || document.querySelector('textarea.story-text');
                    if(ta){ ta.value = res.content; ta.dispatchEvent(new Event('input')); return; }
                    // Fallback: if the app exposes a loader that reads from a hidden file input, create a Blob and try to call existing handler
                    console.warn('No known loader found in page to accept file content; you may need to expose loadFromString(content)');
                }catch(err){ console.error('electronOpenFile', err); }
            }

            async function electronSaveFile(content){
                try{
                    // When possible, ask the page for the current content
                    if(!content){ if(typeof window.getCurrentContent === 'function') content = await window.getCurrentContent(); else {
                        const ta = document.querySelector('textarea#file-content') || document.querySelector('textarea.story-text'); if(ta) content = ta.value;
                    }}
                    if(content == null) { console.warn('No content available to save'); return; }

                    if(electronCurrentPath){
                        const res = await window.electronAPI.saveFile(content, electronCurrentPath);
                        if(res && res.error) console.error('saveFile error', res.error);
                        return res;
                    }
                    // no current path — open Save As
                    const res = await window.electronAPI.saveAs(content);
                    if(res && res.error) console.error('saveAs error', res.error);
                    if(res && res.path) electronCurrentPath = res.path;
                    return res;
                }catch(err){ console.error('electronSaveFile', err); }
            }

            async function electronSaveAs(content){
                try{
                    if(!content){ if(typeof window.getCurrentContent === 'function') content = await window.getCurrentContent(); else {
                        const ta = document.querySelector('textarea#file-content') || document.querySelector('textarea.story-text'); if(ta) content = ta.value;
                    }}
                    if(content == null) { console.warn('No content available to save'); return; }
                    const res = await window.electronAPI.saveAs(content);
                    if(res && res.path) electronCurrentPath = res.path;
                    if(res && res.error) console.error('saveAs error', res.error);
                    return res;
                }catch(err){ console.error('electronSaveAs', err); }
            }

            // Override existing web functions only when present; otherwise, add minimal wrappers
            try{
                if(typeof window.loadFile === 'function'){
                    const webLoad = window.loadFile;
                    window.loadFile = function(){ return electronOpenFile(); };
                    window.webLoadFile = webLoad;
                } else {
                    window.loadFile = electronOpenFile;
                }

                if(typeof window.saveFile === 'function'){
                    const webSave = window.saveFile;
                    window.saveFile = function(){ return electronSaveFile(); };
                    window.webSaveFile = webSave;
                } else {
                    window.saveFile = electronSaveFile;
                }

                // Optional: expose saveAs
                window.saveFileAs = window.saveFileAs || electronSaveAs;

                // Intercept file input clicks (if the page uses a native <input type="file">)
                const fileInput = document.getElementById('file-input') || document.querySelector('input[type=file]');
                if(fileInput){
                    fileInput.addEventListener('click', function(ev){
                        if(window.electronAPI){ ev.preventDefault(); electronOpenFile(); }
                    });
                }

                // Add a 'Save As' button into the toolbar if we can detect a toolbar update function
                if(typeof window.updateGlobalToolbar === 'function'){
                    const orig = window.updateGlobalToolbar;
                    window.updateGlobalToolbar = function(){
                        orig.apply(this, arguments);
                        try{
                            // attempt to find a FILE toolbar group
                            const fileGroup = document.querySelector('.toolbar .group-file') || document.querySelector('#toolbar-file-group') || document.querySelector('.toolbar');
                            if(fileGroup && !document.getElementById('electron-saveas-btn')){
                                const btn = document.createElement('button');
                                btn.id = 'electron-saveas-btn';
                                btn.className = 'toolbtn';
                                btn.textContent = 'Save As';
                                btn.addEventListener('click', async function(){ await electronSaveAs(); });
                                fileGroup.appendChild(btn);
                            }
                        }catch(e){ console.warn(e); }
                    }
                } else {
                    // if no toolbar function, try to append a small save-as button into body header
                    const header = document.querySelector('header') || document.body;
                    if(header && !document.getElementById('electron-saveas-btn')){
                        const btn = document.createElement('button'); btn.id = 'electron-saveas-btn'; btn.style.marginLeft = '8px'; btn.textContent = 'Save As'; btn.addEventListener('click', async ()=> electronSaveAs()); header.appendChild(btn);
                    }
                }
            }catch(e){ console.error('Error installing electron overrides', e); }

        })();
        </script>
</body>
</html>