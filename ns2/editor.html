<!-- ...existing code... -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NS2 Editor</title>
    <link rel="icon" type="image/png" href="icon_transparent.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://unpkg.com/panzoom@9.4.3/dist/panzoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.51.0/min/vs/loader.min.js"></script>
    <script type="text/javascript" src="NSE2.js"></script>
    <script type="text/javascript" src="play.js"></script>
    <link href="style.css" rel="stylesheet">
</head>
<body>
    <div id="splash-screen">
        <img src="icon_transparent.png" data-i18n-alt="title" alt="NS2 Editor Logo">
        <h1>NS2 Editor</h1>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>
    <div class="header">
        <div class="header-left" style="display:flex;align-items:center;gap:8px;min-width:0;">
            <img src="icon_transparent.png" data-i18n-alt="title" alt="Icon" style="height: 26px; width: auto;">
            <div class="toolbar-separator" aria-hidden="true" style="margin-left:6px;margin-right:6px;">|</div>
            <div id="toolbar-story-title" class="toolbar-story-title" style="margin-right:6px;min-width:0;display:flex;align-items:center;gap:4px;">
                <span id="toolbar-story-text">&nbsp;</span>
                <span id="unsaved-dot" title="Unsaved changes" style="color:#e5c07b;display:none;">‚óè</span>
                <span id="unsaved-pill" class="unsaved-pill" aria-hidden="true">Edited</span>
            </div>
        </div>
        <div class="header-center" style="display:flex;align-items:center;gap:8px;flex:1 1 auto;min-width:0;">
            <div id="global-toolbar" class="toolbar no-drag" style="flex:1 1 auto;min-width:0;"></div>
            <!-- dropdown containers kept in DOM; toolbar buttons will toggle them -->
            <div class="dropdown-menu" id="language-dropdown">
                <!-- Dynamically populated -->
            </div>
            <div class="dropdown-menu keep-width" id="recent-dropdown" style="display:none"></div>
            <div class="dropdown-menu keep-width" id="undo-dropdown" style="display:none"></div>
            <div class="dropdown-menu" id="help-dropdown" style="display:none">
                <div class="menu-category">
                    <div class="menu-category-title">Documentation</div>
                    <div class="menu-category-items">
                        <button onclick="openHelp('guide')"><i class="fas fa-book"></i> <span data-i18n="guide">Guide...</span></button>
                        <button onclick="openHelp('ai')"><i class="fas fa-robot"></i> <span data-i18n="ai">AI...</span></button>
                    </div>
                </div>
                <div class="menu-category">
                    <div class="menu-category-title">About</div>
                    <div class="menu-category-items">
                        <button onclick="openHelp('about')"><i class="fas fa-info-circle"></i> <span data-i18n="about">About...</span></button>
                    </div>
                </div>
            </div>
        </div>
        <div class="header-right" style="display:flex;align-items:center;gap:6px;flex:0 0 auto;">
            <!-- window control buttons (Electron only) -->
            <div id="window-controls" class="window-controls no-drag" style="display:none;">
                <button id="win-min" class="icon-button" title="Minimize"><i class="fas fa-window-minimize"></i></button>
                <button id="win-max" class="icon-button" title="Maximize"><i class="fas fa-square-full"></i></button>
                <button id="win-close" class="icon-button" title="Close"><i class="fas fa-times"></i></button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".ns2" onchange="loadFile()">

    <datalist id="state-list"></datalist>
    <datalist id="token-list"></datalist>

    <div id="editor">
        <div class="tabs">
            <button class="tab-button" data-i18n="text" onclick="openTab('text')">Text</button>
            <button class="tab-button active" data-i18n="metadata" onclick="openTab('metadata')">Metadata</button>
            <button class="tab-button" data-i18n="variables" onclick="openTab('variables')">Variables</button>
            <button class="tab-button" onclick="openTab('states')" data-i18n="states">States</button>
            <button class="tab-button" onclick="openTab('graph')" data-i18n="graph">Graph</button>
            <button class="tab-button" onclick="openTab('play')" data-i18n="play">Play</button>
        </div>

        <!-- toolbar was moved into the header menubar -->

        <div id="tab-text" class="tab-content">
            <div id="text-editor"></div>
        </div>

        <div id="tab-metadata" class="tab-content active">
            <div class="section">
                <div class="grid-form">
                    <label data-i18n="titleLabel:">Title:</label> <input type="text" id="story-title">
                    <label data-i18n="desc:">Description:</label> <textarea id="story-description"></textarea>
                    <label data-i18n="start:">Start:</label> <input id="start-state" list="state-list">
                </div>
            </div>
        </div>

        <div id="tab-variables" class="tab-content">
            <div class="section" style="flex: 1; overflow-y: auto;">
                <div class="toolbar">
                    <input type="text" id="var-search" data-i18n-placeholder="searchVars" oninput="filterVariables()">
                    <button class="icon-button" onclick="addVariable()" data-i18n-title="addVariable" title="Add Variable"><i class="fas fa-plus"></i></button>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="type">Type</th>
                            <th data-i18n="name">Name</th>
                            <th data-i18n="initial">Initial</th>
                            <th data-i18n="constraint">Constraint</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="variables-list"></tbody>
                </table>
            </div>
        </div>

        <div id="tab-states" class="tab-content">
            <div class="states-container">
                <div class="states-list-panel">
                    <div class="toolbar">
                        <input type="text" id="state-search" data-i18n-placeholder="searchStates" oninput="filterStates()">
                        <button class="icon-button" onclick="addState()" data-i18n-title="addState" title="Add State"><i class="fas fa-plus"></i></button>
                    </div>
                    <ul id="states-list"></ul>
                </div>
                <div id="state-details" class="state-details-panel"></div>
            </div>
        </div>

        <div id="tab-graph" class="tab-content">
            <div id="graph-container"></div>
        </div>

        <div id="tab-play" class="tab-content" style="display:flex;flex-direction:column;">
            <!-- Externalized play view: loaded entirely via iframe; no play logic resides in editor. -->
            <iframe id="play-iframe" src="reader.html" title="Play" style="flex:1 1 auto;width:100%;border:0;background:#1e1e1e;min-height:300px;"></iframe>
        </div>

        <!-- Help view container: loads full HTML pages in the tab area (no tab button) -->
        <div id="tab-help" class="tab-content">
            <div class="section" style="padding:0; height:100%; display:flex; flex-direction:column;">
                <div id="help-container" style="flex:1 1 auto; overflow:hidden;">
                    <iframe id="help-iframe" title="Help" style="width:100%; height:100%; border:0; background:#1E1E1E;"></iframe>
                </div>
            </div>
        </div>
    </div>

    <div id="status-window" class="dropdown-menu" style="display:none;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
            <div id="status-handle" data-i18n="statusHandle">Status</div>
            <div class="status-actions" style="display:flex;gap:6px;align-items:center;">
                <button id="status-copy" class="icon-button" title="Copy status"><i class="fas fa-copy"></i></button>
            </div>
        </div>
            <div id="play-error" data-i18n="errorLabel">Error</div>
            <div id="status-content" data-i18n="readyLabel">Ready</div>
    </div>

    <div id="context-menu">
        <input type="text" id="context-search" data-i18n-placeholder="searchTokens" oninput="filterContextMenu()">
        <ul id="token-menu-list"></ul>
    </div>

    <div id="graph-context-menu">
        <!-- Context menu items will be injected dynamically -->
    </div>

    <div id="external-change-modal" class="ns2-modal" aria-hidden="true">
        <div class="ns2-modal__backdrop" data-change-close></div>
        <div class="ns2-modal__panel" role="dialog" aria-modal="true" aria-labelledby="external-change-title">
            <button class="ns2-modal__close" title="Dismiss" data-change-close>
                <i class="fas fa-times"></i>
            </button>
            <div class="ns2-modal__icon">
                <i class="fas fa-wave-square"></i>
            </div>
            <div class="ns2-modal__body">
                <div class="ns2-modal__eyebrow">Live Sync</div>
                <h2 id="external-change-title">External update detected</h2>
                <p data-change-message></p>
                <div class="ns2-modal__meta">
                    <div>
                        <span class="label">File</span>
                        <span data-change-name>‚Äî</span>
                    </div>
                    <div>
                        <span class="label">Modified</span>
                        <span data-change-timestamp>Just now</span>
                    </div>
                </div>
                <p class="ns2-modal__warning" data-change-warning style="display:none;"><i class="fas fa-exclamation-triangle"></i> Unsaved editor changes will be overwritten.</p>
                <div class="ns2-modal__actions">
                    <button class="primary" data-change-reload><i class="fas fa-sync"></i> Reload story</button>
                    <button class="ghost" data-change-ignore>Keep my version</button>
                </div>
            </div>
        </div>
    </div>

    <div id="ns2-generic-modal" class="ns2-modal" aria-hidden="true">
        <div class="ns2-modal__backdrop" data-modal-close></div>
        <div class="ns2-modal__panel" role="dialog" aria-modal="true" aria-labelledby="ns2-generic-title">
            <button class="ns2-modal__close" title="Dismiss" data-modal-close>
                <i class="fas fa-times"></i>
            </button>
            <div class="ns2-modal__icon">
                <i data-modal-icon class="fas fa-wave-square"></i>
            </div>
            <div class="ns2-modal__body">
                <div class="ns2-modal__eyebrow" data-modal-eyebrow>Confirm</div>
                <h2 id="ns2-generic-title" data-modal-title>Are you sure?</h2>
                <p data-modal-message></p>
                <div class="ns2-modal__meta" data-modal-meta style="display:none;"></div>
                <p class="ns2-modal__warning" data-modal-warning style="display:none;">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span data-modal-warning-text></span>
                </p>
                <div class="ns2-modal__actions" data-modal-actions>
                    <button class="primary" data-modal-primary>
                        <i class="fas fa-check"></i>
                        <span data-modal-primary-label>Continue</span>
                    </button>
                    <button class="ghost" data-modal-secondary>
                        <i class="fas fa-times"></i>
                        <span data-modal-secondary-label>Cancel</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    

    <script>
        let languages = {};
        let currentLanguage = 'en';
        let editorBootstrapped = false;
        let storageSyncInstalled = false;

        (async () => {
            if (editorBootstrapped) return;
            editorBootstrapped = true;
            const splashStart = performance.now();  // <-- start timer for minimum 1-second splash

            await loadLanguages();
            await initModule();
            await resetEditorToBlank({ skipStatus: true, skipFocus: true, reason: 'startup' });
            openTab('metadata');
            updateGlobalToolbar('metadata');
            updateFileIndicator();
            installStorageSyncBridge();
                // Dispatch readiness AFTER editorEngine exists and story (if any) loaded
                try { window.dispatchEvent(new Event('ns2-module-ready')); } catch(e) {}

            // ----- Hide splash as soon as initialization finishes (no artificial wait) -----
            // If initialization took long, the splash stays visible until now; if it was fast,
            // we remove it immediately so the app loads as fast as possible while still
            // showing the loading screen if necessary.
            (function hideSplashNow(){
                const splash = document.getElementById('splash-screen');
                if (splash) {
                    splash.classList.add('hidden');
                    setTimeout(() => {
                        if (splash) splash.remove();
                    }, 700); // match transition duration + a little buffer
                }
            })();
            // ------------------------------------------------------------------
        })();
        // Simplified: direct save functions now manage clean state; wrapper removed to avoid stale closures.
        (function(){
            // Wire custom window controls when running in Electron
            if(!window || !window.electronAPI) return;
            try{
                const wc = document.getElementById('window-controls');
                if(!wc) return;
                wc.style.display = 'flex';
                const btnMin = document.getElementById('win-min');
                const btnMax = document.getElementById('win-max');
                const btnClose = document.getElementById('win-close');
                if(btnMin) btnMin.addEventListener('click', () => { try{ window.electronAPI.minimize(); }catch(e){} });
                if(btnMax) btnMax.addEventListener('click', async () => { try{ const res = await window.electronAPI.toggleMaximize(); if(res && typeof res.maximized !== 'undefined') updateMaxIcon(res.maximized); }catch(e){} });
                if(btnClose) btnClose.addEventListener('click', () => { try{ window.electronAPI.closeWindow(); }catch(e){} });
                function updateMaxIcon(max){
                    try{
                        const i = btnMax && btnMax.querySelector('i');
                        if(i) i.className = max ? 'fas fa-clone' : 'fas fa-square-full';
                    }catch(e){}
                }
                // listen for maximize/unmaximize events forwarded from main
                if(window.electronWindowEvents && typeof window.electronWindowEvents.onMaximize === 'function'){
                    window.electronWindowEvents.onMaximize((isMax)=> updateMaxIcon(isMax));
                }
                // double-click header toggles maximize
                const header = document.querySelector('.header');
                if(header) header.addEventListener('dblclick', () => { try{ window.electronAPI.toggleMaximize(); }catch(e){} });
            }catch(e){ console.warn('window-controls wiring failed', e); }
        })();

        async function loadLanguages() {
            try {
                const response = await fetch('languages.json');
                languages = await response.json();
                // Add missing keys
                const missingKeys = ['file', 'edit', 'language', 'view', 'toggleStatus'];
                Object.keys(languages).forEach(lang => {
                    missingKeys.forEach(key => {
                        if (!languages[lang][key]) {
                            languages[lang][key] = languages['en'][key] || key.charAt(0).toUpperCase() + key.slice(1);
                        }
                    });
                });
                populateLanguageMenu();
                setLanguage(currentLanguage);
            } catch (e) {
                console.error('Failed to load languages.json', e);
            }
        }

        function installStorageSyncBridge() {
            if (storageSyncInstalled || typeof window === 'undefined') return;
            window.addEventListener('storage', (event) => {
                if (event.key === 'ns2_content' && event.newValue) {
                    try {
                        Module.FS.writeFile('/story.ns2', event.newValue);
                        const pathPtr = allocateUTF8('/story.ns2');
                        const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                        Module._free(pathPtr);
                        if (loaded) {
                            renderEditor();
                            setStatus(languages[currentLanguage]['storyUpdatedFromStorage'] || "Story updated from storage");
                        } else {
                            setStatus((languages[currentLanguage]['failedUpdateFromStorage'] || "Failed to update story from storage: {err}").replace('{err}', getLastError(editorEngine)));
                        }
                    } catch (err) {
                        setStatus((languages[currentLanguage]['failedUpdateFromStorage'] || "Failed to update story from storage: {err}").replace('{err}', err && err.message ? err.message : String(err)), true);
                    }
                }
            });
            storageSyncInstalled = true;
        }

        function setRecentStories(items) {
            if (!Array.isArray(items)) {
                recentStoryEntries = [];
            } else {
                recentStoryEntries = items.slice(0, 10);
            }
            updateRecentDropdownContent();
        }

        function updateRecentDropdownContent() {
            const dropdown = document.getElementById('recent-dropdown');
            if (!dropdown) return;
            const prevInput = dropdown.querySelector('.dropdown-search input');
            const preservedQuery = prevInput ? (prevInput.value || '') : '';
            const queryToRestore = recentDropdownQuery || preservedQuery;

            dropdown.innerHTML = '';
            const category = document.createElement('div');
            category.className = 'menu-category';
            const title = document.createElement('div');
            title.className = 'menu-category-title';
            title.textContent = languages[currentLanguage]?.recentStories || 'Recent Stories';
            category.appendChild(title);

            const itemsContainer = document.createElement('div');
            itemsContainer.className = 'menu-category-items indexed-list';

            const searchWrapper = document.createElement('div');
            searchWrapper.className = 'dropdown-search';
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = (languages[currentLanguage]?.search) || 'Search...';
            searchInput.value = queryToRestore;
            searchInput.spellcheck = false;
            searchWrapper.appendChild(searchInput);
            itemsContainer.appendChild(searchWrapper);

            const listWrapper = document.createElement('div');
            listWrapper.id = 'recent-list';
            listWrapper.className = 'indexed-rows';
            const scrollRegion = document.createElement('div');
            scrollRegion.className = 'indexed-scroll';
            scrollRegion.appendChild(listWrapper);
            itemsContainer.appendChild(scrollRegion);

            const entryButtons = [];
            if (!recentStoryEntries || recentStoryEntries.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'recent-empty';
                empty.textContent = languages[currentLanguage]?.recentEmpty || 'No recent stories yet.';
                listWrapper.appendChild(empty);
            } else {
                recentStoryEntries.forEach((entry, idx) => {
                    const indexDisplay = idx + 1;
                    const btn = document.createElement('button');
                    btn.className = 'indexed-entry recent-entry';
                    btn.type = 'button';
                    const name = entry && entry.name ? entry.name : (entry && entry.path ? getBaseName(entry.path) : 'Untitled');
                    const pathValue = entry && entry.path ? entry.path : '';
                    const secondary = pathValue || '';
                    btn.dataset.filterText = normalizeForMatching(`${name || ''} ${secondary}`).toLowerCase();
                    btn.innerHTML = `
                        <div class="indexed-entry__content">
                            <div class="indexed-entry__heading">
                                <span class="indexed-entry__index">${indexDisplay}.</span>
                                <span class="indexed-entry__primary">${escapeHtml(name || '')}</span>
                            </div>
                            ${secondary ? `<div class="indexed-entry__secondary">${escapeHtml(secondary)}</div>` : ''}
                        </div>`;
                    btn.title = secondary;
                    btn.addEventListener('click', () => openRecentStoryFromList(pathValue));
                    listWrapper.appendChild(btn);
                    entryButtons.push(btn);
                });
            }

            let noResults = null;
            if (entryButtons.length > 0) {
                noResults = document.createElement('div');
                noResults.className = 'recent-empty recent-empty--filtered';
                noResults.textContent = languages[currentLanguage]?.recentNoMatches || 'No matches found.';
                noResults.style.display = 'none';
                listWrapper.appendChild(noResults);
            }

            const filterEntries = () => {
                const raw = searchInput.value || '';
                recentDropdownQuery = raw;
                if (!entryButtons.length) {
                    if (noResults) noResults.style.display = 'none';
                    return;
                }
                const q = normalizeForMatching(raw).toLowerCase();
                let visibleCount = 0;
                entryButtons.forEach(btn => {
                    const haystack = btn.dataset.filterText || '';
                    const match = q ? haystack.includes(q) : true;
                    btn.style.display = match ? 'flex' : 'none';
                    if (match) visibleCount++;
                });
                if (noResults) noResults.style.display = visibleCount === 0 ? 'block' : 'none';
            };
            searchInput.addEventListener('input', filterEntries);
            if (searchInput.value) filterEntries();

            category.appendChild(itemsContainer);
            dropdown.appendChild(category);
            applyDropdownHeightClamp(scrollRegion);
        }

        function applyDropdownHeightClamp(scrollRegion) {
            if (!scrollRegion) return;
            requestAnimationFrame(() => {
                try {
                    const rect = scrollRegion.getBoundingClientRect();
                    const available = Math.floor(window.innerHeight - rect.top - 12);
                    if (available <= 0) return;
                    const contentHeight = scrollRegion.scrollHeight;
                    if (contentHeight > available) {
                        scrollRegion.style.maxHeight = available + 'px';
                        scrollRegion.style.overflowY = 'auto';
                        scrollRegion.classList.add('indexed-scroll--clamped');
                    } else {
                        scrollRegion.style.maxHeight = '';
                        scrollRegion.style.overflowY = '';
                        scrollRegion.classList.remove('indexed-scroll--clamped');
                    }
                } catch (e) {}
            });
        }

        async function refreshRecentStories() {
            if (!window || !window.electronAPI || typeof window.electronAPI.getRecentStories !== 'function') return;
            try {
                const res = await window.electronAPI.getRecentStories();
                if (res && Array.isArray(res.items)) {
                    setRecentStories(res.items);
                }
            } catch (err) {
                console.warn('Failed to refresh recent stories', err);
            }
        }

        function toggleRecentDropdown(anchorEl) {
            updateRecentDropdownContent();
            toggleDropdown('recent-dropdown', anchorEl);
            refreshRecentStories();
        }

        function closeRecentDropdown() {
            const dd = document.getElementById('recent-dropdown');
            if (!dd) return;
            dd.style.display = '';
            dd.dataset.visible = '';
        }

        function openRecentStoryFromList(filePath) {
            if (!filePath) return Promise.resolve(false);
            const handler = typeof window.__openRecentStoryFromElectron === 'function'
                ? window.__openRecentStoryFromElectron
                : null;
            if (!handler) {
                closeRecentDropdown();
                return Promise.resolve(false);
            }
            return Promise.resolve(handler(filePath))
                .catch(() => false)
                .finally(() => closeRecentDropdown());
        }

        function populateLanguageMenu() {
            const langMenu = document.getElementById('language-dropdown');
            langMenu.innerHTML = '';
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = languages[currentLanguage] && languages[currentLanguage]['search'] ? languages[currentLanguage]['search'] : 'Search...';
            searchInput.oninput = function() {
                const raw = this.value || '';
                const query = normalizeForMatching(raw).toLowerCase();
                Array.from(langMenu.querySelectorAll('.button-container button')).forEach(btn => {
                    const text = normalizeForMatching(btn.textContent || '').toLowerCase();
                    try { btn.hidden = !text.includes(query); } catch (e) { btn.style.display = text.includes(query) ? 'flex' : 'none'; }
                });
            };

            // Helper to register Monarch provider while injecting dynamic state-name regexes
            function setNs2Monarch(baseDef) {
                try {
                    const origTokenizer = baseDef.tokenizer || {};

                    // Build a safe state-name rule for root only (no /g flags)
                    let stateRule = null;
                    if (Array.isArray(stateTokens) && stateTokens.length > 0) {
                        const escaped = stateTokens.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'));
                        const pattern = '\\b(' + escaped.join('|') + ')\\b';
                        stateRule = [new RegExp(pattern), 'ns2.state'];
                    }
                    // Build a variable-name rule to highlight variables anywhere (if available)
                    let variableRule = null;
                    if (Array.isArray(variableTokens) && variableTokens.length > 0) {
                        const escapedVars = variableTokens.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'));
                        try {
                            variableRule = [new RegExp('\\b(' + escapedVars.join('|') + ')\\b'), 'ns2.variable'];
                        } catch (e) {
                            variableRule = null;
                        }
                    }

                    // Bracket rule to enter script state; inject into every tokenizer state so '[' works everywhere
                    const bracketRule = [/\[/, { token: 'ns2.squarebracket', next: '@script' }];
                    // Arrow rule: prefer a forced match against known state names so targets are highlighted reliably
                    // Use two capture groups: the arrow + whitespace, and then the state name ‚Äî tokens array must match groups
                    let arrowRule = [/(\-\>\s*)([A-Za-z0-9_\-]+)/, ['ns2.punct', 'ns2.state']];
                    if (Array.isArray(stateTokens) && stateTokens.length > 0) {
                        const escapedStates = stateTokens.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&'));
                        try {
                            const arrowPattern = '(\\-\\>\\s*)(' + escapedStates.join('|') + ')\\b';
                            arrowRule = [new RegExp(arrowPattern), ['ns2.punct', 'ns2.state']];
                        } catch (e) {
                            // fallback to generic arrow rule
                            arrowRule = [/(\-\>\s*)([A-Za-z0-9_\-]+)/, ['ns2.punct', 'ns2.state']];
                        }
                    }

                    // Clone tokenizer states and prepend arrow/bracket/variable rules so they match everywhere
                    const newTokenizer = {};
                    Object.keys(origTokenizer).forEach(stateName => {
                        const rules = Array.isArray(origTokenizer[stateName]) ? origTokenizer[stateName].slice() : [];
                        // variable rule should be first so variables are recognized inside scripts/choices
                        if (variableRule) rules.unshift(variableRule);
                        // Ensure arrowRule then bracket rule so '-> target' and '[' are recognized everywhere
                        rules.unshift(bracketRule);
                        rules.unshift(arrowRule);
                        // If this is root and we have stateRule, add it after arrow/bracket/variable rules
                        if (stateName === 'root' && stateRule) {
                            rules.unshift(stateRule);
                        }
                        newTokenizer[stateName] = rules;
                    });

                    const provider = Object.assign({}, baseDef, { tokenizer: newTokenizer });
                        // Validate tokenizer rules: ensure regex capture groups match token array lengths
                        try {
                            Object.keys(provider.tokenizer).forEach(stateName => {
                                const rules = provider.tokenizer[stateName] || [];
                                rules.forEach((rule, idx) => {
                                    if (Array.isArray(rule) && rule.length >= 2) {
                                        const pattern = rule[0];
                                        const tokens = rule[1];
                                        if (pattern && pattern instanceof RegExp && Array.isArray(tokens)) {
                                            // count capturing groups (simple heuristic: count '(' not followed by '?:')
                                            const src = pattern.source || '';
                                            let groups = 0;
                                            for (let i = 0; i < src.length; i++) {
                                                if (src[i] === '(' && src[i+1] !== '?' ) groups++;
                                            }
                                            if (groups !== tokens.length) {
                                                console.warn('[ns2] Monarch rule mismatch in state', stateName, 'ruleIndex', idx, 'groups', groups, 'tokens', tokens.length, 'pattern', pattern, 'tokensArr', tokens);
                                            }
                                        }
                                    }
                                });
                            });
                        } catch(e) { console.warn('[ns2] tokenizer validation failed', e); }
                        monaco.languages.setMonarchTokensProvider('ns2', provider);
                    console.debug('[ns2] setNs2Monarch: registered provider with', (stateTokens||[]).length, 'state tokens');
                } catch (e) {
                    console.error('[ns2] setNs2Monarch failed', e);
                    monaco.languages.setMonarchTokensProvider('ns2', baseDef);
                }
            }

            
            searchInput.addEventListener('click', e => e.stopPropagation());
            langMenu.appendChild(searchInput);
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            langMenu.appendChild(buttonContainer);
            Object.keys(languages).forEach(lang => {
                const button = document.createElement('button');
                button.onclick = () => setLanguage(lang);
                // Ensure left alignment of content
                button.style.display = 'flex';
                button.style.alignItems = 'center';
                button.style.gap = '6px';
                button.style.justifyContent = 'flex-start';
                button.style.textAlign = 'left';
                button.style.width = '100%';

                // Build single flag element: prefer image (ISO), fallback to emoji
                let flagElement = null;
                const rawFlagEmoji = languages[lang].flag || '';
                const emojiSpan = document.createElement('span');
                emojiSpan.className = 'flag';
                emojiSpan.textContent = rawFlagEmoji;

                // Map regional indicator emoji to ISO country code (e.g. üá¨üáß -> gb)
                function emojiToISO(flagEmoji) {
                    try {
                        const chars = Array.from(flagEmoji);
                        if (chars.length !== 2) return null;
                        const letters = chars.map(ch => {
                            const cp = ch.codePointAt(0);
                            if (cp >= 0x1F1E6 && cp <= 0x1F1FF) return String.fromCharCode(cp - 0x1F1E6 + 65);
                            return null;
                        });
                        if (letters[0] && letters[1]) return (letters.join('')).toLowerCase();
                    } catch (e) {}
                    return null;
                }

                const iso = emojiToISO(rawFlagEmoji);
                if (iso) {
                    const img = document.createElement('img');
                    img.className = 'flag-img';
                    img.alt = (languages[lang].languageName || lang) + ' flag';
                    img.src = `https://flagcdn.com/w40/${iso}.png`;
                    img.onerror = () => { try { img.remove(); button.insertBefore(emojiSpan, button.firstChild); } catch(e){} };
                    flagElement = img;
                } else {
                    flagElement = emojiSpan;
                }

                if (flagElement && rawFlagEmoji) button.appendChild(flagElement);
                // Language name text node
                const nameNode = document.createElement('span');
                nameNode.className = 'language-name';
                nameNode.textContent = languages[lang].languageName || lang;
                nameNode.style.flex = '1 1 auto';
                nameNode.style.overflow = 'hidden';
                nameNode.style.textOverflow = 'ellipsis';
                nameNode.style.whiteSpace = 'nowrap';
                button.appendChild(nameNode);
                buttonContainer.appendChild(button);
            });
        }

        function setLanguage(lang) {
            if (!languages[lang]) {
                console.warn(`Language ${lang} not found, falling back to 'en'`);
                lang = 'en';
            }
            currentLanguage = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = languages[lang][key] || key;
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                el.placeholder = languages[lang][key] || key;
            });
            document.querySelectorAll('[data-i18n-alt]').forEach(el => {
                const key = el.getAttribute('data-i18n-alt');
                try { el.alt = languages[lang][key] || key; } catch(e) {}
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                el.title = languages[lang][key] || key;
            });
        }

        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.51.0/min/vs' } });

        let textEditor;
        let stateScriptEditor;

        mermaid.initialize({ 
            startOnLoad: false, 
            theme: 'dark',
            flowchart: {
                diagramPadding: 20,
                nodeSpacing: 50,
                rankSpacing: 240
            }
        });

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }

        function normalizeForMatching(s) {
            if (!s) return '';
            // decode basic HTML entities using a textarea (works in browser)
            try {
                const ta = document.createElement('textarea');
                ta.innerHTML = s;
                s = ta.value;
            } catch (e) {}
            // collapse whitespace and trim
            return s.replace(/\s+/g, ' ').trim();
        }

        // Debug helper removed in production build.

        let Module;
        let editorEngine;
        let playEngine;
        // Help view state
        let __lastNonHelpTab = 'metadata';
        let __currentHelpPage = null;
        const __helpTitles = { guide: 'Guide', ai: 'AI', about: 'About' };
        let currentGraphState = null;
        let tokens = [];
        let currentInput = null;
        let graphSelectedState = null;
        let stateTokens = [];
        let variableTokens = [];
        let functionTokens = ['set', 'reset', 'not', 'visited', 'get', 'dice', 'min', 'max', 'abs', 'sqrt', 'chance', 'if'];
        let operatorTokens = ['+', '-', '*', '/', 'or', 'and', '>=', '<=', '!=', '==', '>', '<', '='];
        let constantTokens = ['true', 'false'];
        let textApplyTimer = null;
        let textEditorAutoApplyAttached = false;
        // Browser File System Access API tracking (non-Electron)
        let fsCurrentHandle = null; // FileSystemFileHandle when opened/saved via FS Access
        let electronCurrentPath = null; // Absolute path of currently opened file in Electron
        let fsCurrentName = null;
        let recentStoryEntries = [];
        let recentDropdownQuery = '';
        let historyDropdownQuery = '';
        let suppressTextEditorApply = false;
        let pendingStoryTextSync = null;

        // Display name = story title; dirty indicator tracks text edits only
        let currentFileName = null;       // legacy name (not displayed)
        // Simplified reset: drop unified target abstraction (electron uses electronCurrentPath, browser uses fsCurrentHandle)
        let isDirtyText = false;          // True only when Text tab content changed since last save/open
        let lastSavedText = null;         // Snapshot of text content at last save/open

        function getBaseName(p) {
            try { if (!p) return null; const s = String(p); const sep = s.includes('\\') ? '\\' : '/'; const parts = s.split(sep); return parts[parts.length - 1] || null; } catch (e) { return null; }
        }

        function updateFileIndicator() {
            try {
                const titleWrapper = document.getElementById('toolbar-story-title');
                const titleSpan = document.getElementById('toolbar-story-text');
                const dotEl = document.getElementById('unsaved-dot');
                let name = '';
                // Pull current story title from engine (safer than DOM alone)
                try {
                    const ptr = Module._GetStoryTitle(editorEngine);
                    name = Module.UTF8ToString(ptr);
                    Module._FreeString(ptr);
                } catch (e) {}
                if (!name) name = languages[currentLanguage]['untitled'] || 'Untitled';
                if (titleSpan) titleSpan.textContent = name;
                if (dotEl) {
                    dotEl.textContent = isDirtyText ? '*' : '';
                    dotEl.style.display = isDirtyText ? 'inline-block' : 'none';
                    dotEl.style.marginLeft = isDirtyText ? '4px' : '0';
                    dotEl.style.fontSize = '12px';
                }
                const pillEl = document.getElementById('unsaved-pill');
                if (pillEl) {
                    pillEl.style.display = isDirtyText ? 'inline-flex' : 'none';
                    pillEl.setAttribute('aria-hidden', isDirtyText ? 'false' : 'true');
                }
                if (titleWrapper) titleWrapper.title = name + (isDirtyText ? ' (unsaved changes *)' : '');
                // Window title: include story name + dirty marker for taskbar visibility
                try { document.title = `${name}${isDirtyText ? ' *' : ''} - NS2`; } catch (e) {}
            } catch (e) {}
        }

        function setDirtyText(flag) {
            try {
                const prev = isDirtyText;
                isDirtyText = !!flag;
                if (prev !== isDirtyText) updateFileIndicator();
            } catch (e) {}
        }

        function getCurrentEditorText() {
            try {
                if (textEditor && typeof textEditor.getValue === 'function') {
                    return textEditor.getValue();
                }
            } catch (e) {}
            return null;
        }

        function markClean(content, name) {
            try {
                if (typeof name === 'string' && name) currentFileName = name; // retained for save backend only
                // prefer Monaco model snapshot if available; else fall back to provided content
                try { lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : (typeof content === 'string' ? content : null); } catch (e) { lastSavedText = typeof content === 'string' ? content : null; }
                setDirtyText(false);
                updateFileIndicator();
            } catch (e) {}
        }

        function recalcDirty() {
            try {
                const now = getCurrentEditorText();
                if (now == null) {
                    setDirtyText(!!lastSavedText);
                    return;
                }
                if (lastSavedText == null) {
                    setDirtyText(now.length > 0);
                    return;
                }
                setDirtyText(now !== lastSavedText);
            } catch (e) {}
        }

        // Allow Electron bridge to inform us about current file and load content in one place
        window.setCurrentFileInfo = function(filePathOrName, content) {
            try {
                const name = getBaseName(filePathOrName) || filePathOrName || null;
                if (typeof content === 'string') {
                    loadFromString(content);
                    markClean(content, name);
                } else {
                    currentFileName = name;
                    setDirty(false);
                    updateFileIndicator();
                }
            } catch (e) { console.warn('setCurrentFileInfo failed', e); }
        };

        const tokenExamples = {
            'set': 'set(health, get(health) + 5)',
            'reset': 'reset(state_name)',
            'not': 'not(visited(state))',
            'visited': 'visited(state_name)',
            'get': 'get(variable_name)',
            'dice': 'dice(1, 6)',
            'min': 'min(5, get(value))',
            'max': 'max(10, get(value))',
            'abs': 'abs(-3.5)',
            'sqrt': 'sqrt(16)',
            'chance': 'chance(50)',
            'if': 'if(visited(state), 1, 0)',
            '+': 'get(a) + get(b)',
            '-': 'get(a) - get(b)',
            '*': 'get(a) * get(b)',
            '/': 'get(a) / get(b)',
            'or': 'visited(a) or visited(b)',
            'and': 'visited(a) and visited(b)',
            '>=': 'get(a) >= 10',
            '<=': 'get(a) <= 5',
            '!=': 'get(a) != get(b)',
            '==': 'get(a) == get(b)',
            '>': 'get(a) > 0',
            '<': 'get(a) < 100',
            '=': 'get(a) = 42',
            'true': '',
            'false': ''
        };

        let graphPanZoom;
        let graphCurrentScale = 1;

        // Program-wide history (single array + index pointer).
        // Stores actions as { undo: fn, redo: fn, description?: string }
        // historyIndex is the position AFTER the last executed action (i.e. next redo index).
        const programHistory = [];
        let historyIndex = 0;
        const programHistoryLimit = 200;
        let __suppressProgramPush = false;
        // When true, commitFocusedChange will ignore the next blur/change
        // This is used to prevent accidental pushes when clicking history items
        // (mousedown/focus sequence can trigger blur on an input before our
        // history navigation runs). We clear the flag after handling.
        let __suppressCommitOnBlur = false;

        function clearProgramHistory() {
            try {
                programHistory.length = 0;
                historyIndex = 0;
                updateToolbarUndoButtons();
                const list = document.getElementById('history-list');
                if (list) list.innerHTML = '';
                historyDropdownQuery = '';
                updateUndoDropdown();
            } catch (e) { console.warn('clearProgramHistory failed', e); }
        }

        function pushProgramAction(action) {
            // action: { undo: fn, redo: fn, description?: string }
            if (!action || (typeof action.undo !== 'function') || (typeof action.redo !== 'function')) return;
            if (__suppressProgramPush) return;
            // truncate history if we've undone some actions
            if (historyIndex < programHistory.length) {
                programHistory.length = historyIndex;
            }
            // Helper: dedupe consecutive actions
            function __normalizeDesc(d) {
                try {
                    if (!d) return '';
                    if (typeof d === 'string') return d.trim();
                    if (typeof d === 'object') return `${d.title || ''}::${d.detail || ''}`.trim();
                    return '';
                } catch (e) { return ''; }
            }
            try {
                const last = programHistory[programHistory.length - 1];
                const lastNorm = last ? __normalizeDesc(last.description) : '';
                const nextNorm = __normalizeDesc(action.description);
                // Exact normalized duplicate -> skip
                if (last && lastNorm && nextNorm && lastNorm === nextNorm) return;
                // Duplicate by title (collapse repeated edits to same field regardless of detail)
                const lastTitle = last && last.description && last.description.title ? String(last.description.title).trim() : '';
                const nextTitle = action && action.description && action.description.title ? String(action.description.title).trim() : '';
                if (lastTitle && nextTitle && lastTitle === nextTitle) {
                    // For edit-type actions just update last redo handler
                    if (/^Edit /i.test(lastTitle)) {
                        try { if (typeof action.redo === 'function') last.redo = action.redo; } catch (e) {}
                        return;
                    }
                }
            } catch (e) { /* swallow */ }
            programHistory.push(action);
            // enforce limit
            while (programHistory.length > programHistoryLimit) {
                programHistory.shift();
                if (historyIndex > 0) historyIndex--;
            }
            historyIndex = programHistory.length;
            updateUndoDropdown();
            updateToolbarUndoButtons();
            // Do not mark dirty here; dot reflects text edits only
        }

        // Helper: create a short, single-line summary of a value for history details
        function summarizeForHistory(v, maxLen=60) {
            try {
                if (v === null || typeof v === 'undefined') return '';
                let s = String(v);
                // collapse whitespace and newlines
                s = s.replace(/\s+/g, ' ').trim();
                if (s.length > maxLen) return s.slice(0, maxLen-1) + '‚Ä¶';
                return s;
            } catch (e) { return '';} 
        }

        function undoProgram() {
            if (historyIndex === 0) return false;
            historyIndex--;
            const action = programHistory[historyIndex];
            try { __suppressProgramPush = true; action.undo(); } catch (e) { console.warn('undo action failed', e); } finally { __suppressProgramPush = false; }
            // Ensure the UI reflects the new program state
            try { refreshView(); } catch (e) {}
            updateUndoDropdown();
            updateToolbarUndoButtons();
            recalcDirty();
            return true;
        }

        function redoProgram() {
            if (historyIndex >= programHistory.length) return false;
            const action = programHistory[historyIndex];
            try { __suppressProgramPush = true; action.redo(); } catch (e) { console.warn('redo action failed', e); } finally { __suppressProgramPush = false; }
            historyIndex++;
            // Ensure the UI reflects the new program state
            try { refreshView(); } catch (e) {}
            updateUndoDropdown();
            updateToolbarUndoButtons();
            recalcDirty();
            return true;
        }

        // Navigate to an explicit history index without mutating the history array.
        // targetIndex is the new historyIndex (position AFTER last executed action).
        // This function performs the required undo() or redo() calls while
        // suppressing program pushes so the history array is unchanged.
        function navigateHistoryTo(targetIndex) {
            try {
                if (typeof targetIndex !== 'number') return;
                if (targetIndex < 0) targetIndex = 0;
                if (targetIndex > programHistory.length) targetIndex = programHistory.length;
                if (targetIndex === historyIndex) return;
                __suppressProgramPush = true;
                if (targetIndex < historyIndex) {
                    // need to undo actions from historyIndex-1 down to targetIndex
                    for (let i = historyIndex - 1; i >= targetIndex; i--) {
                        try { programHistory[i].undo(); } catch (e) { console.warn('navigate undo failed', e); }
                    }
                } else {
                    // need to redo actions from historyIndex up to targetIndex-1
                    for (let i = historyIndex; i < targetIndex; i++) {
                        try { programHistory[i].redo(); } catch (e) { console.warn('navigate redo failed', e); }
                    }
                }
            } finally {
                __suppressProgramPush = false;
            }
            historyIndex = targetIndex;
            try { refreshView(); } catch (e) {}
            updateUndoDropdown();
            updateToolbarUndoButtons();
            recalcDirty();
        }

        function refreshView() {
            try {
                // Re-render lists and tokens so UI matches the current editorEngine state
                updateTokens();
                populateStateDatalist();
                populateTokenDatalist();
                renderVariables();
                renderStates();
                // Keep editor form fields in sync
                try { renderEditor(); } catch (e) {}
                // If we're currently on the play tab, update play UI immediately
                try { if (currentTab === 'play') updatePlay(); } catch (e) {}
                // If graph tab is active, re-render graph
                try { if (currentTab === 'graph') renderGraph(); } catch (e) {}
            } catch (e) { console.warn('refreshView failed', e); }
        }

        // Live-update helpers: update visible list items as the user types without mutating the engine
        function liveUpdateStateName(originalName, liveValue) {
            try {
                const li = document.querySelector(`#states-list li[data-name="${originalName}"]`);
                if (li) {
                    const span = li.querySelector('.state-name');
                    if (span) span.textContent = liveValue;
                }
                // also update any datalist option visually (doesn't change engine)
                const opts = document.querySelectorAll('#state-list option');
                opts.forEach(opt => { if (opt.value === originalName) opt.value = liveValue; });
            } catch (e) {}
        }

        function liveUpdateStateTitle(name, liveTitle) {
            try {
                const li = document.querySelector(`#states-list li[data-name="${name}"]`);
                if (li) {
                    li.innerHTML = `${escapeHtml(liveTitle)} <span class="state-name">${name}</span>`;
                }
            } catch (e) {}
        }

        // Helpers to create input-change actions
        function describeElement(el) {
            try {
                if (!el) return 'Edit field';
                if (el.getAttribute) {
                    const a = el.getAttribute('aria-label') || el.getAttribute('data-i18n') || el.getAttribute('placeholder') || el.id || el.name;
                    if (a) return `Edit ${a}`;
                }
                if (el.tagName) return `Edit ${el.tagName.toLowerCase()}`;
            } catch (e) {}
            return 'Edit field';
        }
        function makeInputAction(el, prev, next) {
            return {
                description: { title: describeElement(el), detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(next)}` },
                undo: () => {
                    try {
                        if (el.type === 'checkbox' || el.type === 'radio') {
                            el.checked = prev;
                        } else if (el.isContentEditable) {
                            el.innerHTML = prev;
                        } else {
                            el.value = prev;
                        }
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                    } catch (e) {}
                },
                redo: () => {
                    try {
                        if (el.type === 'checkbox' || el.type === 'radio') {
                            el.checked = next;
                        } else if (el.isContentEditable) {
                            el.innerHTML = next;
                        } else {
                            el.value = next;
                        }
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                    } catch (e) {}
                }
            };
        }

        // Track focused input's initial value so we can push the change on blur/change
        let __program_lastFocused = null;
        document.addEventListener('focusin', (e) => {
            const t = e.target;
            if (!t) return;
            // Ignore Monaco editor and its children
            if (t.closest && t.closest('.monaco-editor')) return;
            if (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable || t.tagName === 'SELECT') {
                try {
                    if (t.type === 'checkbox' || t.type === 'radio') __program_lastFocused = { el: t, val: !!t.checked };
                    else if (t.isContentEditable) __program_lastFocused = { el: t, val: t.innerHTML };
                    else __program_lastFocused = { el: t, val: t.value };
                } catch (e) { __program_lastFocused = null; }
            } else {
                __program_lastFocused = null;
            }
        }, true);

        function commitFocusedChange(target) {
            // If a history navigation is about to occur, suppress committing the
            // focused change (clicking history causes blur -> commit otherwise)
            if (__suppressCommitOnBlur) { __suppressCommitOnBlur = false; __program_lastFocused = null; return; }
            if (!__program_lastFocused) return;
            const el = __program_lastFocused.el;
            let changed = false;
            try {
                let now;
                if (el.type === 'checkbox' || el.type === 'radio') now = !!el.checked;
                else if (el.isContentEditable) now = el.innerHTML;
                else now = el.value;
                const prev = __program_lastFocused.val;
                if (now !== prev) {
                    pushProgramAction(makeInputAction(el, prev, now));
                    changed = true;
                    // Do not trigger a full refresh on blur/change ‚Äî UI updates should be contextual.
                    // Refresh of the whole view will be performed only when undo/redo is used.
                }
            } catch (e) {}
            __program_lastFocused = null;
            if (changed && (!target || !target.closest || !target.closest('.monaco-editor'))) {
                scheduleStoryTextSync();
            }
        }

        // Commit on blur and on change events
        document.addEventListener('blur', (e) => { commitFocusedChange(e.target); }, true);
        document.addEventListener('change', (e) => { 
            // For selects and checkbox changes, commit immediately if not inside Monaco
            const t = e.target;
            if (t && t.closest && t.closest('.monaco-editor')) return;
            commitFocusedChange(t);
        }, true);

        // Keyboard shortcuts: Ctrl+Z / Ctrl+Y or Ctrl+Shift+Z
        document.addEventListener('keydown', (e) => {
            if (!(e.ctrlKey || e.metaKey)) return;
            // If focus is inside Monaco editor, don't interfere
            const active = document.activeElement;
            if (active && active.closest && active.closest('.monaco-editor')) return;
            if (e.key === 'z' || e.key === 'Z') {
                if (e.shiftKey) {
                    if (redoProgram()) e.preventDefault();
                } else {
                    if (undoProgram()) e.preventDefault();
                }
            } else if (e.key === 'y' || e.key === 'Y') {
                if (redoProgram()) e.preventDefault();
            }
        }, true);

        // Expose APIs for other code to push actions
        window.pushProgramAction = pushProgramAction;
        window.undoProgram = undoProgram;
        window.redoProgram = redoProgram;
        // Expose history for debugging and UI
        window.programHistory = programHistory;
        window.programHistoryIndex = () => historyIndex;

        function updateUndoDropdown() {
            try {
                const dropdown = document.getElementById('undo-dropdown');
                if (!dropdown) return;
                const prevInput = dropdown.querySelector('.dropdown-search input');
                const preservedQuery = prevInput ? (prevInput.value || '') : '';
                const queryToRestore = historyDropdownQuery || preservedQuery;

                dropdown.innerHTML = '';
                const category = document.createElement('div');
                category.className = 'menu-category';
                const titleEl = document.createElement('div');
                titleEl.className = 'menu-category-title';
                titleEl.textContent = languages[currentLanguage]?.history || 'History';
                category.appendChild(titleEl);

                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'menu-category-items indexed-list';
                category.appendChild(itemsContainer);
                dropdown.appendChild(category);

                const searchWrapper = document.createElement('div');
                searchWrapper.className = 'dropdown-search';
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.placeholder = (languages[currentLanguage]?.search) || 'Search...';
                searchInput.value = queryToRestore;
                searchInput.spellcheck = false;
                searchWrapper.appendChild(searchInput);
                itemsContainer.appendChild(searchWrapper);

                const list = document.createElement('div');
                list.id = 'history-list';
                list.className = 'indexed-rows';
                const scrollRegion = document.createElement('div');
                scrollRegion.className = 'indexed-scroll';
                scrollRegion.appendChild(list);
                itemsContainer.appendChild(scrollRegion);

                const entryButtons = [];
                if (programHistory.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'recent-empty';
                    empty.textContent = languages[currentLanguage]?.historyEmpty || 'No edits yet.';
                    list.appendChild(empty);
                } else {
                    for (let j = programHistory.length - 1; j >= 0; j--) {
                        const item = programHistory[j];
                        const indexDisplay = j + 1;
                        const isRedo = j >= historyIndex;
                        let title = '';
                        let detail = '';
                        if (item && typeof item.description === 'object') {
                            title = item.description.title || '';
                            detail = item.description.detail || '';
                        } else if (item && typeof item.description === 'string') {
                            const raw = item.description.trim();
                            const m = raw.match(/^(.*?)([.!?])\s+(.*)$/);
                            if (m) { title = m[1] + m[2]; detail = m[3]; }
                            else { title = raw; detail = ''; }
                        }
                        if (!title) title = 'Change ' + indexDisplay;

                        const btn = document.createElement('button');
                        btn.className = 'indexed-entry history-entry history-row' + (isRedo ? ' redo' : '');
                        if (!isRedo && j === historyIndex - 1) btn.classList.add('history-current');
                        btn.type = 'button';
                        btn.dataset.filterText = normalizeForMatching(`${title} ${detail || ''}`).toLowerCase();
                        btn.innerHTML = `
                            <div class="indexed-entry__content">
                                <div class="indexed-entry__heading">
                                    <span class="indexed-entry__index">${indexDisplay}.</span>
                                    <span class="indexed-entry__primary">${escapeHtml(title)}</span>
                                </div>
                                ${detail ? `<div class="indexed-entry__secondary">${escapeHtml(detail)}</div>` : ''}
                            </div>`;
                        btn.addEventListener('pointerdown', () => {
                            __suppressCommitOnBlur = true;
                            setTimeout(() => { __suppressCommitOnBlur = false; }, 400);
                        });
                        btn.addEventListener('click', () => {
                            navigateHistoryTo(j + 1);
                            const dd = document.getElementById('undo-dropdown');
                            if (dd) {
                                dd.style.display = '';
                                dd.dataset.visible = '';
                            }
                        });
                        list.appendChild(btn);
                        entryButtons.push(btn);
                    }
                }

                let noResults = null;
                if (entryButtons.length > 0) {
                    noResults = document.createElement('div');
                    noResults.className = 'recent-empty recent-empty--filtered';
                    noResults.textContent = languages[currentLanguage]?.historyNoMatches || 'No matching edits.';
                    noResults.style.display = 'none';
                    list.appendChild(noResults);
                }

                const performFilter = () => {
                    const raw = searchInput.value || '';
                    historyDropdownQuery = raw;
                    if (!entryButtons.length) {
                        if (noResults) noResults.style.display = 'none';
                        return;
                    }
                    const q = normalizeForMatching(raw).toLowerCase();
                    let visible = 0;
                    entryButtons.forEach(btn => {
                        const haystack = btn.dataset.filterText || '';
                        const match = q ? haystack.includes(q) : true;
                        btn.style.display = match ? 'flex' : 'none';
                        if (match) visible++;
                    });
                    if (noResults) noResults.style.display = visible === 0 ? 'block' : 'none';
                };
                searchInput.addEventListener('input', performFilter);
                if (searchInput.value) performFilter();

                applyDropdownHeightClamp(scrollRegion);
            } catch (e) { console.warn('updateUndoDropdown failed', e); }
        }

        function updateToolbarUndoButtons() {
            try {
                const toolbar = document.getElementById('global-toolbar');
                if (!toolbar) return;
                const undoBtn = toolbar.querySelector('[data-action="undo-btn"]');
                const redoBtn = toolbar.querySelector('[data-action="redo-btn"]');
                if (undoBtn) {
                    if (historyIndex === 0) { undoBtn.setAttribute('disabled', 'disabled'); undoBtn.classList.add('disabled'); }
                    else { undoBtn.removeAttribute('disabled'); undoBtn.classList.remove('disabled'); }
                }
                if (redoBtn) {
                    if (historyIndex >= programHistory.length) { redoBtn.setAttribute('disabled', 'disabled'); redoBtn.classList.add('disabled'); }
                    else { redoBtn.removeAttribute('disabled'); redoBtn.classList.remove('disabled'); }
                }
            } catch (e) {}
        }
        let currentTab = 'metadata';
        let selectedState = null;

        // Interval handle for live play-choice availability refreshing
        let playAvailabilityInterval = null;
        const availableProps = ['start_visited', 'always_available', 'dont_mark_visited'];

        function saveToLocalStorage() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            localStorage.setItem('ns2_content', content);
        }

        // Play-engine snapshot helpers (save/restore progress to a string)
        function savePlaySnapshot(engine) {
            try {
                const savePath = '/__snapshot.save';
                const pathPtr = allocateUTF8(savePath);
                Module._SaveProgress(engine, pathPtr);
                Module._free(pathPtr);
                const saveContent = Module.FS.readFile(savePath, { encoding: 'utf8' });
                return saveContent;
            } catch (e) { console.warn('savePlaySnapshot failed', e); return null; }
        }

        function restorePlaySnapshot(engine, snapshot) {
            try {
                if (!snapshot) return false;
                const savePath = '/__snapshot.save';
                Module.FS.writeFile(savePath, snapshot);
                const pathPtr = allocateUTF8(savePath);
                Module._LoadProgress(engine, pathPtr);
                Module._free(pathPtr);
                try { updatePlay(); } catch (e) {}
                return true;
            } catch (e) { console.warn('restorePlaySnapshot failed', e); return false; }
        }

        async function showUniformConfirm(config = {}) {
            try {
                const modal = window.__ns2ConfirmModal;
                if (modal && typeof modal.open === 'function') {
                    return modal.open(config || {});
                }
            } catch (e) {}
            const fallbackMessage = config && config.message
                ? config.message
                : (config && config.title) || (languages[currentLanguage]?.confirmDialogFallback || 'Proceed?');
            const result = typeof window.confirm === 'function' ? window.confirm(fallbackMessage) : true;
            return Promise.resolve(result);
        }

        async function resetEditorToBlank(options = {}) {
            const {
                skipStatus = false,
                skipFocus = false
            } = options;
            try { if (editorEngine) Module._DestroyEngine(editorEngine); } catch (e) {}
            try { editorEngine = Module._CreateEngine(); } catch (e) {
                console.error('Failed to create editor engine', e);
                return false;
            }
            try {
                const previous = localStorage.getItem('ns2_content');
                if (previous) localStorage.setItem('ns2_last_session_backup', previous);
                localStorage.removeItem('ns2_content');
            } catch (e) {}
            try { fsCurrentHandle = null; fsCurrentName = null; } catch (e) {}
            currentFileName = null;

            try {
                const untitled = languages[currentLanguage]?.untitled || 'Untitled';
                const defaultStateName = 'start';
                const defaultStateTitle = languages[currentLanguage]?.defaultStateTitle || 'Start';
                const defaultStateDescription = languages[currentLanguage]?.defaultStateDescription || 'Write your story here.';

                const titlePtr = allocateUTF8(untitled);
                Module._SetStoryTitle(editorEngine, titlePtr);
                Module._free(titlePtr);

                const storyDescPtr = allocateUTF8('');
                Module._SetStoryDescription(editorEngine, storyDescPtr);
                Module._free(storyDescPtr);

                const stateNamePtr = allocateUTF8(defaultStateName);
                Module._AddState(editorEngine, stateNamePtr);
                const stateTitlePtr = allocateUTF8(defaultStateTitle);
                Module._SetStateTitle(editorEngine, stateNamePtr, stateTitlePtr);
                Module._free(stateTitlePtr);
                const stateDescPtr = allocateUTF8(defaultStateDescription);
                Module._SetStateDescription(editorEngine, stateNamePtr, stateDescPtr);
                Module._free(stateDescPtr);
                Module._SetStartState(editorEngine, stateNamePtr);
                Module._free(stateNamePtr);
            } catch (e) {
                console.warn('Failed to build default story via API', e);
            }

            try {
                const txt = generateNS2Content();
                loadFromString(txt, { suppressStatus: true });
                markClean(txt, null);
                clearProgramHistory();
            } catch (e) {
                console.warn('Failed to load generated blank story', e);
                try { renderEditor(); } catch (ee) {}
            }

            if (!skipStatus) {
                setStatus(languages[currentLanguage]?.newStoryCreated || 'New story created');
            }
            if (!skipFocus) {
                setTimeout(() => {
                    try {
                        if (textEditor && textEditor.focus) { textEditor.focus(); return; }
                        const titleInput = document.getElementById('story-title');
                        if (titleInput) titleInput.focus();
                    } catch (e) {}
                }, 60);
            }
            updateFileIndicator();
            return true;
        }

        async function newStory() {
            const prompt = languages[currentLanguage]['createNewStoryConfirm'] || 'Create a new blank story? Unsaved changes will be lost.';
            const ok = await showUniformConfirm({
                icon: 'fas fa-file',
                eyebrow: languages[currentLanguage]['file'] || 'File',
                title: languages[currentLanguage]['newStory'] || 'New Story',
                message: prompt,
                warning: languages[currentLanguage]['unsavedWarning'] || 'Unsaved editor changes will be lost.',
                primaryLabel: languages[currentLanguage]['create'] || 'Create',
                secondaryLabel: languages[currentLanguage]['cancel'] || 'Cancel',
                destructive: true
            });
            if (!ok) return false;
            return await resetEditorToBlank({ skipStatus: false, skipFocus: false });
        }

        // Helper to load story content from a string (used by FS Access and Electron bridges)
        function loadFromString(content, options = {}) {
            const suppressStatus = !!options.suppressStatus;
            try {
                Module.FS.writeFile('/story.ns2', content);
                const pathPtr = allocateUTF8('/story.ns2');
                const loaded = Module._LoadFromFile(editorEngine, pathPtr);
                Module._free(pathPtr);
                if (loaded) {
                    saveToLocalStorage();
                    renderEditor();
                    if (!suppressStatus) {
                        setStatus(languages[currentLanguage]['storyLoadedSuccessfully'] || 'Story loaded successfully');
                    }
                    try { openTab('text'); } catch (e) {}
                    updateFileIndicator();
                    clearProgramHistory();
                    // After load, ensure clean state (text basis) if this is a direct open/save action
                    try { lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content; isDirtyText = false; updateFileIndicator(); } catch (e) {}
                } else {
                    setStatus((languages[currentLanguage]['failedToLoadStory'] || 'Failed to load story: {err}').replace('{err}', getLastError(editorEngine)), true);
                }
            } catch (e) {
                setStatus((languages[currentLanguage]['failedToLoadStory'] || 'Failed to load story: {err}').replace('{err}', e && e.message ? e.message : String(e)), true);
            }
        }

        // Return the current NS2 content as a string (used by Save actions and Electron bridge)
        function getCurrentContent() { return generateNS2Content(); }

        async function openTab(tabName) {
            document.querySelectorAll('.tab-button').forEach(tab => tab.classList.remove('active'));
            const button = Array.from(document.querySelectorAll('.tab-button')).find(b => b.textContent.toLowerCase() === tabName.toLowerCase());
            if (button) button.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            const tabContent = document.getElementById(`tab-${tabName}`);
            tabContent.classList.add('active');

            currentTab = tabName;

            updateGlobalToolbar(tabName);

            const toolbar = document.getElementById('global-toolbar');
            const toolbarHeight = toolbar.offsetHeight;
            document.querySelectorAll('.tab-content').forEach(c => {
                c.style.height = `calc(100vh - 70px)`;
            });

            // Clear graph container when switching away to prevent event bleed
            if (tabName !== 'graph') {
                const graphTab = document.getElementById('tab-graph');
                const graphContainer = document.getElementById('graph-container');
                if (graphContainer) {
                    graphContainer.innerHTML = '';
                }
                if (graphPanZoom) {
                    try {
                        graphPanZoom.dispose();  // Clean up panzoom instance
                    } catch (e) {
                    }
                    graphPanZoom = null;
                }
            } else {
                renderGraph();
            }
            if (tabName === 'text') {
                renderStoryView();
            }
            if (tabName === 'states') {
                renderStates();
            }
            if (tabName === 'variables') {
                renderVariables();
            }
            if (tabName === 'metadata') {
                populateStateDatalist();
            }

            // Play tab now hosts iframe; all play logic is inside reader.html
            // (no local initialization required).
        }
        
        // Open via legacy <input type="file"> (fallback)
        function loadFile() {
            const file = document.getElementById('file-input').files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                const content = e.target.result;
                // Files opened via file input cannot be written back; clear FS handle
                fsCurrentHandle = null; fsCurrentName = file && file.name ? file.name : null;
                loadFromString(content);
                try { currentFileName = fsCurrentName || null; markClean(content, null); } catch (err) {}
            };
            reader.readAsText(file);
        }

        // Prefer modern File System Access API when available
        async function openFile() {
            try {
                // In Electron, prefer the bridge; handle both returning result or self-loading
                if (window.electronAPI && typeof window.loadFile === 'function') {
                    const maybe = await window.loadFile();
                    // If Electron returns content, process here; otherwise its override should call loadFromString
                    if (maybe && typeof maybe === 'object' && typeof maybe.content === 'string') {
                        loadFromString(maybe.content);
                        markClean(maybe.content, null);
                        if (maybe.path) { try { electronCurrentPath = maybe.path; } catch(e){} }
                    }
                    return;
                }
                if (window.showOpenFilePicker) {
                    const [handle] = await window.showOpenFilePicker({
                        multiple: false,
                        types: [{ description: 'NS2 Story', accept: { 'text/plain': ['.ns2'] } }]
                    });
                    if (!handle) return;
                    const file = await handle.getFile();
                    const text = await file.text();
                    fsCurrentHandle = handle; fsCurrentName = file.name;
                    loadFromString(text);
                    currentFileName = fsCurrentName || null;
                    markClean(text, null);
                    setStatus((languages[currentLanguage]['storyLoadedSuccessfully'] || 'Story loaded successfully') + (fsCurrentName ? ` (${fsCurrentName})` : ''));
                } else {
                    // Fallback to hidden file input
                    const inp = document.getElementById('file-input');
                    if (inp) inp.click();
                }
            } catch (e) {
                setStatus((languages[currentLanguage]['failedToLoadStory'] || 'Failed to load story: {err}').replace('{err}', e && e.message ? e.message : String(e)), true);
            }
        }

        function allocateUTF8(str) {
            const size = Module.lengthBytesUTF8(str) + 1;
            const ptr = Module._malloc(size);
            Module.stringToUTF8(str, ptr, size);
            return ptr;
        }

        function getLastError(engine) {
            const ptr = Module._GetStoryLastError(engine);
            const err = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            return err;
        }

        function setStatus(message, isError = false) {
            const content = document.getElementById('status-content');
            content.innerHTML = (message || 'Ready').replace(/\n/g, '<br>');
            content.style.color = isError ? '#ff6b6b' : '#D4D4D4';
        }

        function renderStoryView() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            const container = document.getElementById('text-editor');

            // Collect state and variable tokens dynamically
            let stateTokens = [];
            const stateCount = Module._GetStateCount(editorEngine);
            for (let i = 0; i < stateCount; i++) {
                const statePtr = Module._GetStateName(editorEngine, i);
                stateTokens.push(Module.UTF8ToString(statePtr));
                Module._FreeString(statePtr);
            }

            let variableTokens = [];
            const varCount = Module._GetVariableCount(editorEngine);
            for (let i = 0; i < varCount; i++) {
                const varPtr = Module._GetVariableName(editorEngine, i);
                variableTokens.push(Module.UTF8ToString(varPtr));
                Module._FreeString(varPtr);
            }

            const functionTokens = ['set', 'reset', 'get', 'dice', 'min', 'max', 'abs', 'sqrt', 'chance', 'if', 'not', 'visited'];
            const operatorTokens = ['+', '-', '*', '/', '==', '!=', '>', '<', '>=', '<=', '=', 'and', 'or'];
            const constantTokens = ['true', 'false'];
            const typeTokens = ['string', 'int', 'float', 'bool'];

            const functionRegex = new RegExp('\\b(' + functionTokens.join('|') + ')\\b');
            const operatorRegex = new RegExp('(' + operatorTokens.map(op => op.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') + ')');
            const constantRegex = new RegExp('\\b(' + constantTokens.join('|') + ')\\b');
            const variableRegex = new RegExp('\\b(' + variableTokens.join('|') + ')\\b');
            const stateRegex = new RegExp('\\b(' + stateTokens.join('|') + ')\\b');
            const typeRegex = new RegExp('\\b(' + typeTokens.join('|') + ')\\b');
            const numberRegex = /[-+]?\d+(?:\.\d+)?/;
            const stringRegex = /"[^"]*"/;

            const commonExprRules = [
                [functionRegex, 'ns2.function.inside'],
                [operatorRegex, 'ns2.operator.inside'],
                [constantRegex, 'ns2.constant.inside'],
                [variableRegex, 'ns2.variable.inside'],
                [stateRegex, 'ns2.state.inside'],
                [typeRegex, 'ns2.type.inside'],
                [/[\(\)]/, 'ns2.roundbracket.inside'],
                [numberRegex, 'ns2.number.inside'],
                [stringRegex, 'ns2.string.inside']
            ];

            // Improved Monarch tokenizer matching the NS2 format described in the guide.
            const monarchDefinition = {
                defaultToken: '',
                tokenizer: {
                    root: [
                        // Top-level headings and sections
                        [/^(\s*)(Title\s*:)(.*)$/, ['', 'ns2.keyword', 'ns2.title']],
                        [/^(\s*)(Description\s*:)(.*)$/, ['', 'ns2.keyword', 'ns2.description']],
                        [/^(\s*)(Start\s*:)(.*)$/, ['', 'ns2.keyword', 'ns2.start']],
                        [/^\s*(Variables)\s*:\s*$/, 'ns2.section'],
                        [/^\s*(States)\s*:\s*$/, 'ns2.section'],

                        // State header (stateName:)
                        [/^([A-Za-z0-9_\-]+)(\s*)(:)(\s*)$/, ['ns2.state', '', 'ns2.punct', '']],

                        // Variable declarations: type name: initial [constraint]
                        [/^(\s*)(string|int|float|bool)(\s+)([A-Za-z0-9_]+)(\s*)(:)(.*)$/, ['', 'ns2.type', '', 'ns2.variable', '', 'ns2.punct', 'ns2.initial']],

                        // Choice line leading dash
                        [/^\s*\-\s+/, 'ns2.punct', '@choicetext'],

                        // Sub-keys under states (title:, description:, script:, requires:, actions:, properties:)
                        [/^(\s+)(title|description|script)(\s*:\s*)(.*)$/, ['', 'ns2.key', 'ns2.punct', 'ns2.string']],
                        [/^(\s+)(requires|actions|properties)(\s*:\s*)(\[.*\])?$/, ['', 'ns2.key', 'ns2.punct', 'ns2.squarebracket.inside']],

                        // Opening bracket starts a script/expression region handled by @script state
                        [/\[/, { token: 'ns2.squarebracket', next: '@script' }],
                        // numbers and strings in general
                        [/"[^"]*"/, 'ns2.string'],
                        [/\b(true|false)\b/, 'ns2.constant'],
                        [/[-+]?\d+(?:\.\d+)?\b/, 'ns2.number'],

                        // fallback: identifiers and punctuation
                        [/[:\[\]\(\)\-\>]/, 'ns2.punct'],
                        [/\w+/, '']
                    ],

                    // State for parsing choice text after the leading '- '
                    choicetext: [
                        // bracketed expressions at start ‚Äî capture open/inside/close so token arrays match groups
                        [/\s*(\[)([^\]]*)(\])/, ['ns2.squarebracket', 'ns2.expression', 'ns2.squarebracket']],
                        // arrow to target
                        [/\s*->\s*/, 'ns2.punct', '@target'],
                        // rest of line as plain text
                        [/.*$/, { token: 'ns2.choiceText', next: '@pop' }]
                    ],

                    target: [
                        [/\s*([A-Za-z0-9_\-]+)\s*/, { token: 'ns2.state', next: '@aftertarget' }]
                    ],

                    aftertarget: [
                        // optional bracketed effect or flags ‚Äî capture open/inside/close
                        [/\s*(\[)([^\]]*)(\])/, ['ns2.squarebracket', 'ns2.flag', 'ns2.squarebracket'], '@pop'],
                        [/.*$/, { token: '', next: '@pop' }]
                    ]
                    ,
                    // script state: everything inside [ ... ] is treated as script
                    script: [
                        [/[^\]]+/, 'ns2.script'],
                        [/\]/, { token: 'ns2.squarebracket', next: '@pop' }]
                    ]
                }
            };

            if (!textEditor) {
                require(['vs/editor/editor.main'], function () {
                        console.debug('[ns2] Monaco editor main loaded');
                        try {
                            console.debug('[ns2] registering language id=ns2');
                            monaco.languages.register({ id: 'ns2' });
                                console.debug('[ns2] setting Monarch tokens provider for ns2');
                                    if (typeof setNs2Monarch === 'function') setNs2Monarch(monarchDefinition);
                                    else monaco.languages.setMonarchTokensProvider('ns2', monarchDefinition);
                        } catch (err) {
                            console.error('[ns2] Error registering language or tokens provider', err);
                        }
                        try {
                            console.debug('[ns2] defining theme ns2-dark');
                            monaco.editor.defineTheme('ns2-dark', {
                        base: 'vs-dark',
                        inherit: true,
                        rules: [
                            // tokens emitted by the Monarch tokenizer
                            { token: 'ns2.keyword', foreground: 'c586c0' },
                            { token: 'ns2.title', foreground: 'c586c0' },
                            { token: 'ns2.description', foreground: 'c586c0' },
                            { token: 'ns2.start', foreground: '9cdcfe' },
                            { token: 'ns2.section', foreground: '4ec9b0' },
                            { token: 'ns2.state', foreground: 'c586c0' },
                            { token: 'ns2.type', foreground: '4ec9b0' },
                            { token: 'ns2.variable', foreground: '9cdcfe' },
                            { token: 'ns2.initial', foreground: 'b5cea8' },
                            { token: 'ns2.punct', foreground: 'd4d4d4' },
                            { token: 'ns2.key', foreground: '4ec9b0' },
                            { token: 'ns2.choiceText', foreground: 'dcdcaa' },
                            { token: 'ns2.string', foreground: 'ce9178' },
                            { token: 'ns2.number', foreground: 'b5cea8' },
                            { token: 'ns2.constant', foreground: '569cd6' },
                            { token: 'ns2.squarebracket.inside', foreground: '000000' },
                            { token: 'ns2.expression', foreground: '9cdcfe' },
                            { token: 'ns2.squarebracket', foreground: 'ffffff', background: '555555', fontStyle: 'bold' },
                            { token: 'ns2.squarebracket.inside', foreground: 'ffffff', background: '555555' },
                            { token: 'ns2.script', foreground: 'ffffff', background: '555555', fontStyle: 'bold' },
                            { token: 'ns2.flag', foreground: '569cd6' },
                            // legacy/compat tokens from earlier tokenizer (keep them mapped too)
                            { token: 'ns2.function.inside', foreground: 'dcdcaa' },
                            { token: 'ns2.operator.inside', foreground: 'd4d4d4' },
                            { token: 'ns2.constant.inside', foreground: '569cd6' },
                            { token: 'ns2.variable.inside', foreground: '9cdcfe' },
                            { token: 'ns2.state.inside', foreground: 'c586c0' },
                            { token: 'ns2.type.inside', foreground: '4ec9b0' },
                            { token: 'ns2.roundbracket.inside', foreground: 'ffd700' },
                            { token: 'ns2.number.inside', foreground: 'b5cea8' },
                            { token: 'ns2.string.inside', foreground: 'ce9178' },
                            { token: 'ns2.expression.inside', foreground: '9cdcfe' }
                        ],
                        colors: {
                           
                            'editor.background': '#1e1e1e'
                        }
                    });
                    textEditor = monaco.editor.create(container, {
                        value: content,
                        language: 'ns2',
                        theme: 'ns2-dark',
                        automaticLayout: true,
                        wordWrap: 'on'
                    });
                    attachTextEditorAutoApply();
                    try {
                        // Diagnostic: tokenize a small sample and log results
                        if (monaco && monaco.editor && typeof monaco.editor.tokenize === 'function') {
                            const sample = 'int health: 100 [0,100]\nintro:\n  title: Welcome\n  - Go north -> forest';
                            try {
                                const toks = monaco.editor.tokenize(sample, 'ns2');
                                console.debug('[ns2] tokenize sample result:', toks);
                            } catch (e) {
                                console.error('[ns2] tokenize sample failed', e);
                            }
                        }
                    } catch(e) {}
                    } catch (err) {
                        console.error('[ns2] Error defining theme or creating editor', err);
                    }
                });
            } else {
                if (typeof setNs2Monarch === 'function') setNs2Monarch(monarchDefinition);
                else monaco.languages.setMonarchTokensProvider('ns2', monarchDefinition);
                textEditor.setValue(content);
                attachTextEditorAutoApply();
            }
        }

        function attachTextEditorAutoApply() {
            if (!textEditor || textEditorAutoApplyAttached) return;
            textEditorAutoApplyAttached = true;
            textEditor.onDidChangeModelContent(() => {
                if (suppressTextEditorApply) return;
                if (textApplyTimer) clearTimeout(textApplyTimer);
                textApplyTimer = setTimeout(() => {
                    try {
                        applyTextChanges();
                    } catch (e) {}
                }, 800);
                // update bracket decorations live
                try { applyMonacoBracketDecorations(); } catch (e) {}
                try { recalcDirty(); } catch (e) {}
            });
            // initial decorations
            try { applyMonacoBracketDecorations(); } catch (e) {}
        }

        // Monaco decoration id holder for bracket regions
        let bracketDecorations = [];

        function applyMonacoBracketDecorations() {
            if (!textEditor) return;
            const model = textEditor.getModel();
            if (!model) return;
            const text = model.getValue();
            const ranges = [];
            // Find all bracketed ranges (including nested/simple)
            let match;
            const re = /\[([\s\S]*?)\]/g;
            while ((match = re.exec(text)) !== null) {
                const startIndex = match.index;
                const endIndex = re.lastIndex;
                const startPos = model.getPositionAt(startIndex);
                const endPos = model.getPositionAt(endIndex);
                ranges.push({ range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column), options: { inlineClassName: 'ns2-bracket-deco' } });
            }
            // Apply decorations
            bracketDecorations = textEditor.deltaDecorations(bracketDecorations, ranges);
        }

        // Apply decoration CSS (Visual Studio style aggressive black background)
        (function injectBracketDecorationStyle(){
            const id = 'ns2-bracket-style';
            if (document.getElementById(id)) return;
            const s = document.createElement('style');
            s.id = id;
            s.textContent = `
            .monaco-editor .ns2-bracket-deco { background-color: #222; color: #690 !important; font-weight:700; border:1px solid #555; box-shadow: inset 3px 5px 8px rgba(0,0,0,1); }
        `;
            document.head.appendChild(s);
        })();

        

        function applyTextChanges() {
            try { recalcDirty(); } catch (e) {}
            const text = textEditor.getValue();
            Module.FS.writeFile('/temp.ns2', text);
            const pathPtr = allocateUTF8('/temp.ns2');
            const loaded = Module._LoadFromFile(editorEngine, pathPtr);
            Module._free(pathPtr);
            if (loaded) {
                saveToLocalStorage();
                renderEditor();
                setStatus(languages[currentLanguage]['changesApplied'] || "Changes applied successfully");
                } else {
                setStatus((languages[currentLanguage]['invalidNS2Format'] || "Invalid NS2 format: {err}").replace('{err}', getLastError(editorEngine)));
            }
        }

        function syncTextEditorFromEngine() {
            if (!textEditor || !Module || !editorEngine) return;
            try {
                const nextContent = generateNS2Content();
                const current = textEditor.getValue();
                if (current === nextContent) return;
                const viewState = textEditor.saveViewState ? textEditor.saveViewState() : null;
                suppressTextEditorApply = true;
                textEditor.setValue(nextContent);
                suppressTextEditorApply = false;
                if (viewState && textEditor.restoreViewState) {
                    textEditor.restoreViewState(viewState);
                }
                recalcDirty();
            } catch (e) {
                suppressTextEditorApply = false;
                console.warn('syncTextEditorFromEngine failed', e);
            }
        }

        function scheduleStoryTextSync() {
            if (pendingStoryTextSync) return;
            pendingStoryTextSync = setTimeout(() => {
                pendingStoryTextSync = null;
                syncTextEditorFromEngine();
            }, 120);
        }

        function populateStateDatalist() {
            const stateList = document.getElementById('state-list');
            stateList.innerHTML = '';
            const count = Module._GetStateCount(editorEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetStateName(editorEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const option = document.createElement('option');
                option.value = name;
                stateList.appendChild(option);
            }
        }

        function populateTokenDatalist() {
            const tokenList = document.getElementById('token-list');
            tokenList.innerHTML = '';
            tokens.forEach(token => {
                const option = document.createElement('option');
                option.value = token;
                tokenList.appendChild(option);
            });
        }

        function renderVariables() {
            const list = document.getElementById('variables-list');
            list.innerHTML = '';
            const count = Module._GetVariableCount(editorEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetVariableName(editorEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const namePtr2 = allocateUTF8(name);
                const typePtr = Module._GetVariableType(editorEngine, namePtr2);
                const type = Module.UTF8ToString(typePtr);
                Module._FreeString(typePtr);
                const initialPtr = Module._GetVariableInitial(editorEngine, namePtr2);
                const initial = Module.UTF8ToString(initialPtr);
                Module._FreeString(initialPtr);
                const constraintPtr = Module._GetVariableConstraint(editorEngine, namePtr2);
                const constraint = Module.UTF8ToString(constraintPtr);
                Module._FreeString(constraintPtr);
                Module._free(namePtr2);
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><select onchange="updateVariable('${escapeHtml(name)}', 'type', this.value)"><option value="string">string</option><option value="int">int</option><option value="float">float</option><option value="bool">bool</option></select></td>
                    <td><input value="${escapeHtml(name)}" onchange="updateVariableName('${escapeHtml(name)}', this.value)" onblur="updateVariableName('${escapeHtml(name)}', this.value)"></td>
                    <td><input value="${escapeHtml(initial)}" onchange="updateVariable('${escapeHtml(name)}', 'initial', this.value)" onblur="updateVariable('${escapeHtml(name)}', 'initial', this.value)"></td>
                    <td><input value="${escapeHtml(constraint)}" onchange="updateVariable('${escapeHtml(name)}', 'constraint', this.value)" onblur="updateVariable('${escapeHtml(name)}', 'constraint', this.value)"></td>
                    <td><button class="icon-button" onclick="removeVariable('${escapeHtml(name)}')" data-i18n-title="deleteVariable" title="Delete Variable"><i class="fas fa-trash"></i></button></td>
                `;
                tr.querySelector('select').value = type || 'string';
                list.appendChild(tr);
            }
            filterVariables();
        }

        function generateUniqueVariableName() {
            const prefix = 'var';
            const existing = new Set();
            try {
                const count = Module._GetVariableCount(editorEngine);
                for (let i = 0; i < count; i++) {
                    const namePtr = Module._GetVariableName(editorEngine, i);
                    const name = Module.UTF8ToString(namePtr);
                    Module._FreeString(namePtr);
                    existing.add(name);
                }
            } catch (e) {}
            let idx = 1;
            while (existing.has(prefix + idx)) idx++;
            return prefix + idx;
        }

        function generateUniqueStateName() {
            const prefix = 'state';
            const existing = new Set();
            try {
                const count = Module._GetStateCount(editorEngine);
                for (let i = 0; i < count; i++) {
                    const namePtr = Module._GetStateName(editorEngine, i);
                    const name = Module.UTF8ToString(namePtr);
                    Module._FreeString(namePtr);
                    existing.add(name);
                }
            } catch (e) {}
            let idx = 1;
            while (existing.has(prefix + idx)) idx++;
            return prefix + idx;
        }

        function filterVariables() {
            const searchInput = document.getElementById('var-search');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const rows = document.querySelectorAll('#variables-list tr');
            rows.forEach(row => {
                try {
                    const nameCell = row.cells[1].querySelector('input').value || '';
                    const nameNorm = normalizeForMatching(nameCell).toLowerCase();
                    try { row.hidden = !nameNorm.includes(query); } catch (e) { row.style.display = nameNorm.includes(query) ? '' : 'none'; }
                } catch (e) { try { row.hidden = false; } catch (ee) { row.style.display = ''; } }
            });
        }

        function addVariable() {
            const name = generateUniqueVariableName();
            const namePtr = allocateUTF8(name);
            Module._AddVariable(editorEngine, allocateUTF8('string'), namePtr, allocateUTF8(''), allocateUTF8(''));
            Module._free(namePtr);
            renderVariables();
            saveToLocalStorage();
            updateTokens();
            populateTokenDatalist();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorAddingVariable'] || "Error adding variable: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['variableAdded'] || "Variable added successfully");
                // push undo/redo action for addVariable
                try {
                    const action = {
                        description: { title: `Add variable ${name}`, detail: `name: ${summarizeForHistory(name)}` },
                        undo: () => { removeVariable(name); },
                        redo: () => { const nPtr = allocateUTF8(name); Module._AddVariable(editorEngine, allocateUTF8('string'), nPtr, allocateUTF8(''), allocateUTF8('')); Module._free(nPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); }
                    };
                    pushProgramAction(action);
                    // Contextual update: update the corresponding variable row instead of full re-render
                    try {
                        const rows = Array.from(document.querySelectorAll('#variables-list tr'));
                        for (const tr of rows) {
                            const nameInp = tr.cells[1] && tr.cells[1].querySelector('input');
                            if (!nameInp) continue;
                            if (nameInp.value === name) {
                                if (field === 'type') {
                                    const sel = tr.querySelector('select'); if (sel) sel.value = value || 'string';
                                } else if (field === 'initial') {
                                    const inp = tr.cells[2] && tr.cells[2].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'constraint') {
                                    const inp = tr.cells[3] && tr.cells[3].querySelector('input'); if (inp) inp.value = value;
                                }
                                break;
                            }
                        }
                        try { updateTokens(); populateTokenDatalist(); } catch (e) {}
                    } catch (e) {}
                } catch (e) {}
            }
        }

        function updateVariable(name, field, value) {
            const namePtr = allocateUTF8(name);
            // capture previous value
            let prev = null;
            try {
                if (field === 'type') {
                    const prevPtr = Module._GetVariableType(editorEngine, namePtr);
                    prev = Module.UTF8ToString(prevPtr);
                    Module._FreeString(prevPtr);
                    const valuePtr = allocateUTF8(value);
                    Module._SetVariableType(editorEngine, namePtr, valuePtr);
                    Module._free(valuePtr);
                } else if (field === 'initial') {
                    const prevPtr = Module._GetVariableInitial(editorEngine, namePtr);
                    prev = Module.UTF8ToString(prevPtr);
                    Module._FreeString(prevPtr);
                    const valuePtr = allocateUTF8(value);
                    Module._SetVariableInitial(editorEngine, namePtr, valuePtr);
                    Module._free(valuePtr);
                } else if (field === 'constraint') {
                    const prevPtr = Module._GetVariableConstraint(editorEngine, namePtr);
                    prev = Module.UTF8ToString(prevPtr);
                    Module._FreeString(prevPtr);
                    const valuePtr = allocateUTF8(value);
                    Module._SetVariableConstraint(editorEngine, namePtr, valuePtr);
                    Module._free(valuePtr);
                }
            } catch (e) { console.warn('updateVariable capture failed', e); }
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingVariable'] || "Error updating variable: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update variable ${name}`, detail: `${field}: ${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateVariable(name, field, prev); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} },
                        redo: () => { try { updateVariable(name, field, value); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    try { refreshView(); } catch (e) {}
                } catch (e) {}
            }
        }

        function updateVariableName(oldName, newName) {
            if (newName === oldName) return;
            const oldPtr = allocateUTF8(oldName);
            const newPtr = allocateUTF8(newName);
            let type = 'string', initial = '', constraint = '';
            try {
                const typePtr = Module._GetVariableType(editorEngine, oldPtr);
                type = Module.UTF8ToString(typePtr); Module._FreeString(typePtr);
                const initialPtr = Module._GetVariableInitial(editorEngine, oldPtr);
                initial = Module.UTF8ToString(initialPtr); Module._FreeString(initialPtr);
                const constraintPtr = Module._GetVariableConstraint(editorEngine, oldPtr);
                constraint = Module.UTF8ToString(constraintPtr); Module._FreeString(constraintPtr);
            } catch (e) {}
            Module._AddVariable(editorEngine, allocateUTF8(type), newPtr, allocateUTF8(initial), allocateUTF8(constraint));
            Module._RemoveVariable(editorEngine, oldPtr);
            Module._free(oldPtr);
            Module._free(newPtr);
            // Contextual DOM updates: update the variable row name input and relevant datalists
            try {
                const rows = Array.from(document.querySelectorAll('#variables-list tr'));
                for (const tr of rows) {
                    const nameInp = tr.cells[1] && tr.cells[1].querySelector('input');
                    if (nameInp && nameInp.value === oldName) {
                        nameInp.value = newName;
                        break;
                    }
                }
                try { updateTokens(); populateTokenDatalist(); } catch (e) {}
            } catch (e) {}
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingVariableName'] || "Error updating variable name: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Rename variable ${oldName} -> ${newName}`, detail: `${summarizeForHistory(type)} ${summarizeForHistory(initial)}` },
                        undo: () => { try { const nPtr = allocateUTF8(oldName); Module._AddVariable(editorEngine, allocateUTF8(type), nPtr, allocateUTF8(initial), allocateUTF8(constraint)); const remPtr = allocateUTF8(newName); Module._RemoveVariable(editorEngine, remPtr); Module._free(remPtr); Module._free(nPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} },
                        redo: () => { try { updateVariableName(oldName, newName); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    try { refreshView(); } catch (e) {}
                } catch (e) {}
            }
        }

        function removeVariable(name) {
            const namePtr = allocateUTF8(name);
            // capture variable data
            let type = 'string', initial = '', constraint = '';
            try {
                const tPtr = Module._GetVariableType(editorEngine, namePtr); type = Module.UTF8ToString(tPtr); Module._FreeString(tPtr);
                const iPtr = Module._GetVariableInitial(editorEngine, namePtr); initial = Module.UTF8ToString(iPtr); Module._FreeString(iPtr);
                const cPtr = Module._GetVariableConstraint(editorEngine, namePtr); constraint = Module.UTF8ToString(cPtr); Module._FreeString(cPtr);
            } catch (e) {}

            Module._RemoveVariable(editorEngine, namePtr);
            Module._free(namePtr);
            renderVariables();
            saveToLocalStorage();
            updateTokens();
            populateTokenDatalist();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorRemovingVariable'] || "Error removing variable: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['variableRemoved'] || "Variable removed successfully");
                try {
                    const action = {
                        description: { title: `Remove variable ${name}`, detail: `${summarizeForHistory(type)} ${summarizeForHistory(initial)}` },
                        undo: () => { try { const nPtr = allocateUTF8(name); Module._AddVariable(editorEngine, allocateUTF8(type), nPtr, allocateUTF8(initial), allocateUTF8(constraint)); Module._free(nPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} },
                        redo: () => { try { const rPtr = allocateUTF8(name); Module._RemoveVariable(editorEngine, rPtr); Module._free(rPtr); renderVariables(); saveToLocalStorage(); updateTokens(); populateTokenDatalist(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    try { refreshView(); } catch (e) {}
                } catch (e) {}
            }
        }

        function renderStates() {
            const list = document.getElementById('states-list');
            list.innerHTML = '';
            const count = Module._GetStateCount(editorEngine);
            for (let i = 0; i < count; i++) {
                const namePtr = Module._GetStateName(editorEngine, i);
                const name = Module.UTF8ToString(namePtr);
                Module._FreeString(namePtr);
                const titlePtr = Module._GetStateTitle(editorEngine, allocateUTF8(name));
                const title = Module.UTF8ToString(titlePtr);
                Module._FreeString(titlePtr);
                const li = document.createElement('li');
                li.innerHTML = `${title} <span class="state-name">${name}</span>`;
                li.dataset.name = name;
                li.onclick = () => selectState(name);
                        list.appendChild(li);
                        // If playEngine exists, check whether this state can be visited from current play context
                        if (typeof playEngine !== 'undefined' && playEngine) {
                            const pNamePtr = allocateUTF8(name);
                            try {
                                const canVisit = Module._CanVisitState(playEngine, pNamePtr);
                                if (!canVisit) {
                                    li.classList.add('disabled');
                                    li.title = languages[currentLanguage]['cannotVisitState'] || 'State not visitable in current play session';
                                }
                            } catch (e) {
                                // ignore if function not available
                            }
                            Module._free(pNamePtr);
                        }
            }
            if (count > 0) {
                const firstNamePtr = Module._GetStateName(editorEngine, 0);
                const firstName = Module.UTF8ToString(firstNamePtr);
                Module._FreeString(firstNamePtr);
                // If a state was previously selected and still exists, keep it selected
                try {
                    if (selectedState) {
                        const exists = Array.from(list.querySelectorAll('li')).some(li => li.dataset.name === selectedState);
                        if (exists) {
                            selectState(selectedState);
                        } else {
                            selectState(firstName);
                        }
                    } else {
                        selectState(firstName);
                    }
                } catch (e) { selectState(firstName); }
            }
            populateStateDatalist();
            updateTokens();
            populateTokenDatalist();
        }

function selectState(name) {
    selectedState = name;
    document.querySelectorAll('#states-list li').forEach(li => li.classList.remove('selected'));
    const selectedLi = Array.from(document.querySelectorAll('#states-list li')).find(li => li.dataset.name === name);
    if (selectedLi) selectedLi.classList.add('selected');
    const panel = document.getElementById('state-details');
    panel.innerHTML = '';
    if (!name) return;
    const namePtr = allocateUTF8(name);
    const titlePtr = Module._GetStateTitle(editorEngine, namePtr);
    const title = Module.UTF8ToString(titlePtr);
    Module._FreeString(titlePtr);
    const descPtr = Module._GetStateDescription(editorEngine, namePtr);
    const desc = Module.UTF8ToString(descPtr);
    Module._FreeString(descPtr);
    const scriptPtr = Module._GetStateScript(editorEngine, namePtr);
    const script = Module.UTF8ToString(scriptPtr);
    Module._FreeString(scriptPtr);
    let requires = [];
    const reqCount = Module._GetStateRequiresCount(editorEngine, namePtr);
    for (let i = 0; i < reqCount; i++) {
        const reqPtr = Module._GetStateRequire(editorEngine, namePtr, i);
        requires.push(Module.UTF8ToString(reqPtr));
        Module._FreeString(reqPtr);
    }
    let actions = [];
    const actCount = Module._GetStateActionsCount(editorEngine, namePtr);
    for (let i = 0; i < actCount; i++) {
        const actPtr = Module._GetStateAction(editorEngine, namePtr, i);
        actions.push(Module.UTF8ToString(actPtr));
        Module._FreeString(actPtr);
    }
    let properties = [];
    const propCount = Module._GetStatePropertiesCount(editorEngine, namePtr);
    for (let i = 0; i < propCount; i++) {
        const propPtr = Module._GetStateProperty(editorEngine, namePtr, i);
        properties.push(Module.UTF8ToString(propPtr));
        Module._FreeString(propPtr);
    }
    Module._free(namePtr);
    const content = document.createElement('div');
    content.innerHTML = `
        <style>
            #state-script-textarea {
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 12px;
                line-height: 1.4;
                resize: none;
                min-height: 60px;
                overflow-y: auto;
            }
            #state-script-textarea:focus {
                border-color: #007bb0;
                box-shadow: 0 0 5px rgba(0, 122, 204, 0.5);
            }
        </style>
        <div class="grid-form">
                <label data-i18n="name:">Name:</label> <input value="${escapeHtml(name)}" data-live="true" oninput="liveUpdateStateName('${escapeHtml(name)}', this.value)" onchange="updateStateName('${escapeHtml(name)}', this.value)" onblur="updateStateName('${escapeHtml(name)}', this.value)">
                <label data-i18n="titleLabel:">Title:</label> <input value="${escapeHtml(title)}" data-live="true" oninput="liveUpdateStateTitle('${escapeHtml(name)}', this.value)" onchange="updateState('${escapeHtml(name)}', 'title', this.value); saveToLocalStorage()">
            <label data-i18n="desc:">Desc:</label> <textarea data-live="true" onchange="updateState('${escapeHtml(name)}', 'description', this.value); saveToLocalStorage()">${escapeHtml(desc)}</textarea>
            <label data-i18n="script:">Script:</label> <textarea id="state-script-textarea" list="token-list" onchange="updateState('${escapeHtml(name)}', 'script', this.value); saveToLocalStorage()">${escapeHtml(script)}</textarea>
            <label data-i18n="requires:">Requires:</label> <input list="token-list" value="${escapeHtml(requires.join('; '))}" onchange="updateStateList('${escapeHtml(name)}', 'requires', this.value); saveToLocalStorage()">
            <label data-i18n="actions:">Actions:</label> <input list="token-list" value="${escapeHtml(actions.join('; '))}" onchange="updateStateList('${escapeHtml(name)}', 'actions', this.value); saveToLocalStorage()">
            <label data-i18n="props:">Props:</label> <div class="props-container" id="props-checkboxes-${escapeHtml(name)}"></div>
        </div>
        <div class="choices-section">
                <div class="toolbar">
                <input type="text" id="choice-search" data-i18n-placeholder="searchChoices" oninput="filterChoices('${escapeHtml(name)}')">
                <button class="icon-button" onclick="addChoice('${escapeHtml(name)}')" data-i18n-title="addChoice" title="Add Choice"><i class="fas fa-plus"></i></button>
            </div>
            <div class="table-wrapper">
                <table>
                    <thead><tr><th data-i18n="text">Text</th><th data-i18n="cond">Cond</th><th data-i18n="target">Target</th><th data-i18n="effect">Effect</th><th data-i18n="hide">Hide</th><th></th></tr></thead>
                    <tbody id="choices-${escapeHtml(name)}"></tbody>
                </table>
            </div>
        </div>
    `;
    panel.appendChild(content);
    setLanguage(currentLanguage);  // to translate the new labels
    renderChoices(name);
    filterChoices(name);

    // (no overlays) highlighting restricted to Monaco editor only

    // Auto-resize and live-save the state description textarea (keep behavior similar to story description)
    try {
        const descTextarea = panel.querySelector('textarea:not(#state-script-textarea)');
        const scriptTextarea = panel.querySelector('#state-script-textarea');
        function autoResizeTextarea(el) {
            el.style.height = 'auto';
            el.style.height = (el.scrollHeight) + 'px';
        }
        if (descTextarea) {
            // apply initial size
            setTimeout(() => autoResizeTextarea(descTextarea), 0);
            descTextarea.addEventListener('input', function() {
                autoResizeTextarea(this);
                // update state description live (updateState already saves)
                try {
                    updateState(name, 'description', this.value);
                } catch (e) {
                    console.warn('Failed to update state description live', e);
                }
            });
        }
        if (scriptTextarea) {
            // apply initial size for script textarea
            setTimeout(() => autoResizeTextarea(scriptTextarea), 0);
            scriptTextarea.addEventListener('input', function() {
                autoResizeTextarea(this);
                // update state script live
                try {
                    updateState(name, 'script', this.value);
                } catch (e) {
                    console.warn('Failed to update state script live', e);
                }
            });
        }
    } catch (e) {
        console.warn('Auto-resize for state textareas failed', e);
    }

    // Render properties checkboxes
    const propsDiv = document.getElementById(`props-checkboxes-${escapeHtml(name)}`);
    availableProps.forEach(prop => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = prop;
        if (properties.includes(prop)) checkbox.checked = true;
        checkbox.onchange = () => {
            const checkedProps = availableProps.filter(p => {
                const cb = propsDiv.querySelector(`input[value="${p}"]`);
                return cb && cb.checked;
            }).join('; ');
            updateStateList(name, 'properties', checkedProps);
            saveToLocalStorage();
        };
        label.appendChild(checkbox);
        const propDisplay = prop.replace('_', ' ').toUpperCase();
        label.appendChild(document.createTextNode(` ${propDisplay}`));
        propsDiv.appendChild(label);
    });

    // Ensure textarea is styled consistently and focus first input
    const scriptTextarea = document.getElementById('state-script-textarea');
    if (scriptTextarea) {
        scriptTextarea.style.width = '100%';
        scriptTextarea.style.boxSizing = 'border-box';
    }
    
    // Focus the first input element (Name field) only if the panel doesn't already contain focus
    const firstInput = panel.querySelector('input');
    if (firstInput) {
        try {
            const active = document.activeElement;
            if (!panel.contains(active) || active === document.body) {
                firstInput.focus();
            }
        } catch (e) {
            try { firstInput.focus(); } catch (ee) {}
        }
    }

    // Sync selection with graph: highlight the node for the selected state
    try { highlightGraphNode(name); } catch (e) {}
}

        function filterChoices(stateName) {
            const raw = (document.getElementById(`choice-search`) && document.getElementById(`choice-search`).value) || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const rows = document.querySelectorAll(`#choices-${stateName} tr`);
            rows.forEach(row => {
                try {
                    const text = (row.cells[0].querySelector('input').value || '');
                    const textNorm = normalizeForMatching(text).toLowerCase();
                    try { row.hidden = !textNorm.includes(query); } catch (e) { row.style.display = textNorm.includes(query) ? '' : 'none'; }
                } catch (e) { try { row.hidden = false; } catch (ee) { row.style.display = ''; } }
            });
        }

        function setAsStart(name) {
            const namePtr = allocateUTF8(name);
            Module._SetStartState(editorEngine, namePtr);
            Module._free(namePtr);
            saveToLocalStorage();
            document.getElementById('start-state').value = name;
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorSettingStartState'] || "Error setting start state: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['startStateSet'] || "Start state set successfully");
            }
        }

        function jumpToState(name) {
            if (!name) return;
            try {
                const iframe = document.getElementById('play-iframe');
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.postMessage({ type: 'ns2-jump', state: name }, '*');
                }
                openTab('play');
            } catch(e) {
                setStatus((languages[currentLanguage]['errorJumpState'] || 'Error jumping to state: {err}').replace('{err}', e && e.message ? e.message : String(e)), true);
            }
        }

        function forceJumpToState(name) {
            if (!name) return;
            try {
                const iframe = document.getElementById('play-iframe');
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.postMessage({ type: 'ns2-forcejump', state: name }, '*');
                }
                openTab('play');
            } catch(e) {
                setStatus((languages[currentLanguage]['errorForceJump'] || 'Error force jumping to state: {err}').replace('{err}', e && e.message ? e.message : String(e)), true);
            }
        }

        function renderChoices(name) {
            const list = document.getElementById(`choices-${escapeHtml(name)}`);
            list.innerHTML = '';
            const namePtr = allocateUTF8(name);
            const count = Module._GetStateChoicesCount(editorEngine, namePtr);
            for (let i = 0; i < count; i++) {
                const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
                const text = Module.UTF8ToString(textPtr);
                Module._FreeString(textPtr);
                const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
                const cond = Module.UTF8ToString(condPtr);
                Module._FreeString(condPtr);
                const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
                const target = Module.UTF8ToString(targetPtr);
                Module._FreeString(targetPtr);
                const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
                const effect = Module.UTF8ToString(effectPtr);
                Module._FreeString(effectPtr);
                const hide = Module._GetStateChoiceHide(editorEngine, namePtr, i);
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input list="token-list" value="${escapeHtml(text)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'text', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'text', this.value)"></td>
                    <td><input list="token-list" value="${escapeHtml(cond)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'cond', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'cond', this.value)"></td>
                    <td><div class="target-group"><input list="state-list" value="${escapeHtml(target)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'target', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'target', this.value)"><button class="icon-button scope-button" onclick="scopeToState(this.previousSibling.value)" data-i18n-title="Jump to State" title="Go to State"><i class="fas fa-arrow-right"></i></button></div></td>
                    <td><input list="token-list" value="${escapeHtml(effect)}" onchange="updateChoice('${escapeHtml(name)}', ${i}, 'effect', this.value)" onblur="updateChoice('${escapeHtml(name)}', ${i}, 'effect', this.value)"></td>
                    <td class="hide-cell"><input type="checkbox" ${hide ? 'checked' : ''} onchange="updateChoice('${escapeHtml(name)}', ${i}, 'hide', this.checked)"></td>
                    <td><button class="icon-button" onclick="removeChoice('${escapeHtml(name)}', ${i})" data-i18n-title="deleteChoice" title="Delete Choice"><i class="fas fa-trash"></i></button></td>
                `;
                list.appendChild(tr);
                // (no overlays) highlighting restricted to Monaco editor only
                // Disable the "Go to State" button if the target state doesn't exist
                const scopeBtn = tr.querySelector('.scope-button');
                if (scopeBtn) {
                    const targetInput = tr.querySelector('.target-group input');
                    const targetVal = targetInput ? targetInput.value.trim() : '';
                    let targetExists = false;
                    if (targetVal) {
                        const sCount = Module._GetStateCount(editorEngine);
                        for (let si = 0; si < sCount; si++) {
                            const sPtr = Module._GetStateName(editorEngine, si);
                            const sName = Module.UTF8ToString(sPtr);
                            Module._FreeString(sPtr);
                            if (sName === targetVal) { targetExists = true; break; }
                        }
                    }
                    if (!targetVal || !targetExists) {
                        scopeBtn.setAttribute('disabled', 'disabled');
                        scopeBtn.classList.add('disabled');
                        scopeBtn.title = targetVal ? (languages[currentLanguage]['targetNotFound'] || 'Target state not found') : (languages[currentLanguage]['noTarget'] || 'No target state');
                    }
                }
            }
            Module._free(namePtr);
        }

        function filterStates() {
            const searchInput = document.getElementById('state-search');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            document.querySelectorAll('#states-list li').forEach(li => {
                try {
                    const txt = normalizeForMatching(li.textContent || '').toLowerCase();
                    try { li.hidden = !txt.includes(query); } catch (e) { li.style.display = txt.includes(query) ? 'block' : 'none'; }
                } catch (e) { try { li.hidden = false; } catch (ee) { li.style.display = 'block'; } }
            });
        }

        function scopeToState(name) {
            openTab('states');
            selectState(name);
        }

        function viewInGraph(name) {
            currentGraphState = name;
            openTab('graph');
        }

        function addState() {
            const name = generateUniqueStateName();
            try {
                Module._AddState(editorEngine, allocateUTF8(name));
                renderStates();
                selectState(name);
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus((languages[currentLanguage]['errorAddingState'] || "Error adding state: {err}").replace('{err}', err));
                } else {
                    setStatus(languages[currentLanguage]['stateAdded'] || "State added successfully");
                    // push undo/redo action for addState
                    try {
                        const action = {
                            description: { title: `Add state ${name}`, detail: `name: ${summarizeForHistory(name)}` },
                            undo: () => { removeState(name); },
                            redo: () => { const p = allocateUTF8(name); Module._AddState(editorEngine, p); Module._free(p); renderStates(); selectState(name); saveToLocalStorage(); }
                            };
                        pushProgramAction(action);
                    } catch (e) {}
                }
            } catch (e) { console.warn('addState failed', e); }
        }

        function playState(name) {
            openTab('play');
            if (typeof setPlayState === 'function') {
                setPlayState(name);
            } else {
                window.currentPlayState = name;
            }
        }
        function forcePlayState(name) {
            openTab('play');
            if (typeof setPlayState === 'function') {
                setPlayState(name, true); // true = force
            } else {
                window.currentPlayState = name;
                window.forcePlay = true;
            }
        }

        function updateStateName(oldName, newName) {
            if (newName === oldName || !newName) return;
            const oldPtr = allocateUTF8(oldName);
            const newPtr = allocateUTF8(newName);
            Module._AddState(editorEngine, newPtr);
            const titlePtr = Module._GetStateTitle(editorEngine, oldPtr);
            Module._SetStateTitle(editorEngine, newPtr, titlePtr);
            Module._FreeString(titlePtr);
            const descPtr = Module._GetStateDescription(editorEngine, oldPtr);
            Module._SetStateDescription(editorEngine, newPtr, descPtr);
            Module._FreeString(descPtr);
            const scriptPtr = Module._GetStateScript(editorEngine, oldPtr);
            Module._SetStateScript(editorEngine, newPtr, scriptPtr);
            Module._FreeString(scriptPtr);
            const reqCount = Module._GetStateRequiresCount(editorEngine, oldPtr);
            for (let i = 0; i < reqCount; i++) {
                const reqPtr = Module._GetStateRequire(editorEngine, oldPtr, i);
                Module._AddStateRequire(editorEngine, newPtr, reqPtr);
                Module._FreeString(reqPtr);
            }
            const actCount = Module._GetStateActionsCount(editorEngine, oldPtr);
            for (let i = 0; i < actCount; i++) {
                const actPtr = Module._GetStateAction(editorEngine, oldPtr, i);
                Module._AddStateAction(editorEngine, newPtr, actPtr);
                Module._FreeString(actPtr);
            }
            const propCount = Module._GetStatePropertiesCount(editorEngine, oldPtr);
            for (let i = 0; i < propCount; i++) {
                const propPtr = Module._GetStateProperty(editorEngine, oldPtr, i);
                Module._AddStateProperty(editorEngine, newPtr, propPtr);
                Module._FreeString(propPtr);
            }
            const choiceCount = Module._GetStateChoicesCount(editorEngine, oldPtr);
            for (let i = 0; i < choiceCount; i++) {
                Module._AddStateChoice(editorEngine, newPtr);
                const textPtr = Module._GetStateChoiceText(editorEngine, oldPtr, i);
                Module._SetStateChoiceText(editorEngine, newPtr, i, textPtr);
                Module._FreeString(textPtr);
                const condPtr = Module._GetStateChoiceCondition(editorEngine, oldPtr, i);
                Module._SetStateChoiceCondition(editorEngine, newPtr, i, condPtr);
                Module._FreeString(condPtr);
                const targetPtr = Module._GetStateChoiceTarget(editorEngine, oldPtr, i);
                Module._SetStateChoiceTarget(editorEngine, newPtr, i, targetPtr);
                Module._FreeString(targetPtr);
                const effectPtr = Module._GetStateChoiceEffect(editorEngine, oldPtr, i);
                Module._SetStateChoiceEffect(editorEngine, newPtr, i, effectPtr);
                Module._FreeString(effectPtr);
                const hide = Module._GetStateChoiceHide(editorEngine, oldPtr, i);
                Module._SetStateChoiceHide(editorEngine, newPtr, i, hide);
            }
            Module._RemoveState(editorEngine, oldPtr);
            Module._free(oldPtr);
            Module._free(newPtr);
            // Update DOM contextually: update list item, datalist options, choice targets and selection
            try {
                // Update selectedState reference
                if (selectedState === oldName) selectedState = newName;

                // Update the states list item text and data-name
                const li = document.querySelector(`#states-list li[data-name="${oldName}"]`);
                if (li) {
                    li.dataset.name = newName;
                    const span = li.querySelector('.state-name');
                    if (span) span.textContent = newName;
                }

                // Update datalist options for state-list
                const stateOptions = Array.from(document.querySelectorAll('#state-list option'));
                stateOptions.forEach(opt => { if (opt.value === oldName) opt.value = newName; });

                // Update any choice target inputs that reference the old name
                Array.from(document.querySelectorAll('input[list="state-list"]')).forEach(inp => {
                    if (inp.value === oldName) inp.value = newName;
                });

                // If the state-details panel is open for this state, update its name input
                const panel = document.getElementById('state-details');
                if (panel) {
                    const nameInput = panel.querySelector('input');
                    if (nameInput && nameInput.value === oldName) nameInput.value = newName;
                }

                // Update graph highlight if present
                try { highlightGraphNode(newName); } catch (e) {}
            } catch (e) {}
            saveToLocalStorage();
            const err = getLastError(editorEngine);
                if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingStateName'] || "Error updating state name: {err}").replace('{err}', err));
                }
            else {
                try {
                    const action = {
                        description: { title: `Rename state ${oldName} -> ${newName}`, detail: `${summarizeForHistory(newName)}` },
                        undo: () => { try { updateStateName(newName, oldName); renderStates(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateStateName(oldName, newName); renderStates(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    // refreshView may be expensive; do a targeted refresh of dependent UIs
                    try { updateTokens(); populateStateDatalist(); populateTokenDatalist(); } catch (e) {}
                } catch (e) {}
            }
        }

        function updateState(name, field, value) {
            const namePtr = allocateUTF8(name);
            let prev = '';
            try {
                if (field === 'title') {
                    const p = Module._GetStateTitle(editorEngine, namePtr); prev = Module.UTF8ToString(p); Module._FreeString(p);
                    const valuePtr = allocateUTF8(value); Module._SetStateTitle(editorEngine, namePtr, valuePtr); Module._free(valuePtr);
                } else if (field === 'description') {
                    const p = Module._GetStateDescription(editorEngine, namePtr); prev = Module.UTF8ToString(p); Module._FreeString(p);
                    const valuePtr = allocateUTF8(value); Module._SetStateDescription(editorEngine, namePtr, valuePtr); Module._free(valuePtr);
                } else if (field === 'script') {
                    const p = Module._GetStateScript(editorEngine, namePtr); prev = Module.UTF8ToString(p); Module._FreeString(p);
                    const valuePtr = allocateUTF8(value); Module._SetStateScript(editorEngine, namePtr, valuePtr); Module._free(valuePtr);
                }
            } catch (e) { console.warn('updateState capture failed', e); }
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingState'] || "Error updating state: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update state ${name}`, detail: `${field}: ${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateState(name, field, prev); renderStates(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateState(name, field, value); renderStates(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    // Contextual UI update: if title changed, update the corresponding list item title
                    try {
                        if (field === 'title') {
                            const li = document.querySelector(`#states-list li[data-name="${name}"]`);
                            if (li) {
                                // set innerHTML to title + span
                                li.innerHTML = `${escapeHtml(value)} <span class="state-name">${name}</span>`;
                            }
                        } else {
                            // For description/script updates, ensure the editor panel remains in sync
                            const panel = document.getElementById('state-details');
                            if (panel) {
                                // update the corresponding input/textarea if present
                                if (field === 'description') {
                                    const ta = panel.querySelector('textarea:not(#state-script-textarea)'); if (ta) ta.value = value;
                                } else if (field === 'script') {
                                    const st = panel.querySelector('#state-script-textarea'); if (st) st.value = value;
                                }
                            }
                        }
                    } catch (e) {}
                } catch (e) {}
            }
        }

        function updateStateList(name, field, value) {
            const namePtr = allocateUTF8(name);
            // capture previous list
            let prevList = '';
            try {
                const parts = [];
                let count = 0;
                if (field === 'requires') {
                    count = Module._GetStateRequiresCount(editorEngine, namePtr);
                    for (let i = 0; i < count; i++) { const p = Module._GetStateRequire(editorEngine, namePtr, i); parts.push(Module.UTF8ToString(p)); Module._FreeString(p); }
                } else if (field === 'actions') {
                    count = Module._GetStateActionsCount(editorEngine, namePtr);
                    for (let i = 0; i < count; i++) { const p = Module._GetStateAction(editorEngine, namePtr, i); parts.push(Module.UTF8ToString(p)); Module._FreeString(p); }
                } else if (field === 'properties') {
                    count = Module._GetStatePropertiesCount(editorEngine, namePtr);
                    for (let i = 0; i < count; i++) { const p = Module._GetStateProperty(editorEngine, namePtr, i); parts.push(Module.UTF8ToString(p)); Module._FreeString(p); }
                }
                prevList = parts.join(';');
            } catch (e) { console.warn('capture state list failed', e); }
            // Clear existing
            let count;
            if (field === 'requires') {
                count = Module._GetStateRequiresCount(editorEngine, namePtr);
                for (let i = count - 1; i >= 0; i--) {
                    Module._RemoveStateRequire(editorEngine, namePtr, i);
                }
            } else if (field === 'actions') {
                count = Module._GetStateActionsCount(editorEngine, namePtr);
                for (let i = count - 1; i >= 0; i--) {
                    Module._RemoveStateAction(editorEngine, namePtr, i);
                }
            } else if (field === 'properties') {
                count = Module._GetStatePropertiesCount(editorEngine, namePtr);
                for (let i = count - 1; i >= 0; i--) {
                    Module._RemoveStateProperty(editorEngine, namePtr, i);
                }
            }
            // Add new
            const items = value.split(';').map(s => s.trim()).filter(s => s);
            items.forEach(item => {
                const itemPtr = allocateUTF8(item);
                if (field === 'requires') {
                    Module._AddStateRequire(editorEngine, namePtr, itemPtr);
                } else if (field === 'actions') {
                    Module._AddStateAction(editorEngine, namePtr, itemPtr);
                } else if (field === 'properties') {
                    Module._AddStateProperty(editorEngine, namePtr, itemPtr);
                }
                Module._free(itemPtr);
            });
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingStateList'] || "Error updating state list: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update state list ${name} ${field}`, detail: `${summarizeForHistory(prevList)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateStateList(name, field, prevList); renderStates(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateStateList(name, field, value); renderStates(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
        }


        function addChoice(name) {
            const namePtr = allocateUTF8(name);
            Module._AddStateChoice(editorEngine, namePtr);
            // capture new choice data (likely empty defaults)
            const idx = Module._GetStateChoicesCount(editorEngine, namePtr) - 1;
            const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, idx);
            const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, idx);
            const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, idx);
            const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, idx);
            const hide = Module._GetStateChoiceHide(editorEngine, namePtr, idx);
            const text = Module.UTF8ToString(textPtr);
            const cond = Module.UTF8ToString(condPtr);
            const target = Module.UTF8ToString(targetPtr);
            const effect = Module.UTF8ToString(effectPtr);
            Module._FreeString(textPtr);
            Module._FreeString(condPtr);
            Module._FreeString(targetPtr);
            Module._FreeString(effectPtr);

            renderChoices(name);
            filterChoices(name);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorAddingChoice'] || "Error adding choice: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['choiceAdded'] || "Choice added successfully");
                try {
                    const action = {
                        description: { title: `Add choice ${name}`, detail: `text: ${summarizeForHistory(text)}` },
                        undo: () => { try { const p = allocateUTF8(name); const cIdx = Module._GetStateChoicesCount(editorEngine, p) - 1; if (cIdx >= 0) Module._RemoveStateChoice(editorEngine, p, cIdx); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { const p = allocateUTF8(name); Module._AddStateChoice(editorEngine, p); const newIdx = Module._GetStateChoicesCount(editorEngine, p) - 1; Module._SetStateChoiceText(editorEngine, p, newIdx, allocateUTF8(text)); Module._SetStateChoiceCondition(editorEngine, p, newIdx, allocateUTF8(cond)); Module._SetStateChoiceTarget(editorEngine, p, newIdx, allocateUTF8(target)); Module._SetStateChoiceEffect(editorEngine, p, newIdx, allocateUTF8(effect)); Module._SetStateChoiceHide(editorEngine, p, newIdx, hide); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
            Module._free(namePtr);
        }

        function updateChoice(name, i, field, value) {
            const namePtr = allocateUTF8(name);
            // capture previous value
            let prev = null;
            if (field === 'hide') {
                prev = Module._GetStateChoiceHide(editorEngine, namePtr, i);
                Module._SetStateChoiceHide(editorEngine, namePtr, i, value);
            } else if (field === 'text') {
                const prevPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceText(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            } else if (field === 'cond') {
                const prevPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceCondition(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            } else if (field === 'target') {
                const prevPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceTarget(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            } else if (field === 'effect') {
                const prevPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
                prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const valuePtr = allocateUTF8(value);
                Module._SetStateChoiceEffect(editorEngine, namePtr, i, valuePtr);
                Module._free(valuePtr);
            }
            Module._free(namePtr);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorUpdatingChoice'] || "Error updating choice: {err}").replace('{err}', err));
            } else {
                try {
                    const action = {
                        description: { title: `Update choice ${name}`, detail: `${field}: ${summarizeForHistory(prev)} -> ${summarizeForHistory(value)}` },
                        undo: () => { try { updateChoice(name, i, field, prev); renderChoices(name); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { updateChoice(name, i, field, value); renderChoices(name); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
        }

        function removeChoice(name, i) {
            const namePtr = allocateUTF8(name);
            // capture current choice
            const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
            const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
            const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
            const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
            const hide = Module._GetStateChoiceHide(editorEngine, namePtr, i);
            const text = Module.UTF8ToString(textPtr);
            const cond = Module.UTF8ToString(condPtr);
            const target = Module.UTF8ToString(targetPtr);
            const effect = Module.UTF8ToString(effectPtr);
            Module._FreeString(textPtr);
            Module._FreeString(condPtr);
            Module._FreeString(targetPtr);
            Module._FreeString(effectPtr);

            Module._RemoveStateChoice(editorEngine, namePtr, i);
            renderChoices(name);
            filterChoices(name);
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorRemovingChoice'] || "Error removing choice: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['choiceRemoved'] || "Choice removed successfully");
                try {
                    const action = {
                        description: { title: `Remove choice ${name}`, detail: `text: ${summarizeForHistory(text)}` },
                        undo: () => { try { const p = allocateUTF8(name); Module._AddStateChoice(editorEngine, p); const newIdx = Module._GetStateChoicesCount(editorEngine, p) - 1; Module._SetStateChoiceText(editorEngine, p, newIdx, allocateUTF8(text)); Module._SetStateChoiceCondition(editorEngine, p, newIdx, allocateUTF8(cond)); Module._SetStateChoiceTarget(editorEngine, p, newIdx, allocateUTF8(target)); Module._SetStateChoiceEffect(editorEngine, p, newIdx, allocateUTF8(effect)); Module._SetStateChoiceHide(editorEngine, p, newIdx, hide); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { const p = allocateUTF8(name); // find a matching choice index
                                    let found = -1; const count = Module._GetStateChoicesCount(editorEngine, p); for (let k = 0; k < count; k++) { const tPtr = Module._GetStateChoiceText(editorEngine, p, k); const t = Module.UTF8ToString(tPtr); Module._FreeString(tPtr); if (t === text) { found = k; break; } } if (found >= 0) Module._RemoveStateChoice(editorEngine, p, found); Module._free(p); renderChoices(name); filterChoices(name); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
            Module._free(namePtr);
        }

        function removeState(name) {
            const namePtr = allocateUTF8(name);
            // capture whole state
            const state = { title: '', description: '', script: '', requires: [], actions: [], properties: [], choices: [] };
            try {
                const tPtr = Module._GetStateTitle(editorEngine, namePtr); state.title = Module.UTF8ToString(tPtr); Module._FreeString(tPtr);
                const dPtr = Module._GetStateDescription(editorEngine, namePtr); state.description = Module.UTF8ToString(dPtr); Module._FreeString(dPtr);
                const sPtr = Module._GetStateScript(editorEngine, namePtr); state.script = Module.UTF8ToString(sPtr); Module._FreeString(sPtr);
                const reqCount = Module._GetStateRequiresCount(editorEngine, namePtr);
                for (let i = 0; i < reqCount; i++) { const rPtr = Module._GetStateRequire(editorEngine, namePtr, i); state.requires.push(Module.UTF8ToString(rPtr)); Module._FreeString(rPtr); }
                const actCount = Module._GetStateActionsCount(editorEngine, namePtr);
                for (let i = 0; i < actCount; i++) { const aPtr = Module._GetStateAction(editorEngine, namePtr, i); state.actions.push(Module.UTF8ToString(aPtr)); Module._FreeString(aPtr); }
                const propCount = Module._GetStatePropertiesCount(editorEngine, namePtr);
                for (let i = 0; i < propCount; i++) { const pPtr = Module._GetStateProperty(editorEngine, namePtr, i); state.properties.push(Module.UTF8ToString(pPtr)); Module._FreeString(pPtr); }
                const choiceCount = Module._GetStateChoicesCount(editorEngine, namePtr);
                for (let i = 0; i < choiceCount; i++) {
                    const textPtr = Module._GetStateChoiceText(editorEngine, namePtr, i);
                    const condPtr = Module._GetStateChoiceCondition(editorEngine, namePtr, i);
                    const targetPtr = Module._GetStateChoiceTarget(editorEngine, namePtr, i);
                    const effectPtr = Module._GetStateChoiceEffect(editorEngine, namePtr, i);
                    const hide = Module._GetStateChoiceHide(editorEngine, namePtr, i);
                    state.choices.push({ text: Module.UTF8ToString(textPtr), cond: Module.UTF8ToString(condPtr), target: Module.UTF8ToString(targetPtr), effect: Module.UTF8ToString(effectPtr), hide });
                    Module._FreeString(textPtr); Module._FreeString(condPtr); Module._FreeString(targetPtr); Module._FreeString(effectPtr);
                }
            } catch (e) { console.warn('capture state failed', e); }

            Module._RemoveState(editorEngine, namePtr);
            renderStates();
            document.getElementById('state-details').innerHTML = '';
            saveToLocalStorage();
            const err = getLastError(editorEngine);
            if (err) {
                setStatus((languages[currentLanguage]['errorRemovingState'] || "Error removing state: {err}").replace('{err}', err));
            } else {
                setStatus(languages[currentLanguage]['stateRemoved'] || "State removed successfully");
                try {
                    const action = {
                        description: { title: `Remove state ${name}`, detail: `${summarizeForHistory(state.title)}` },
                        undo: () => {
                            try {
                                const nPtr = allocateUTF8(name);
                                Module._AddState(editorEngine, nPtr);
                                const tp = allocateUTF8(state.title); Module._SetStateTitle(editorEngine, nPtr, tp); Module._free(tp);
                                const dp = allocateUTF8(state.description); Module._SetStateDescription(editorEngine, nPtr, dp); Module._free(dp);
                                const sp = allocateUTF8(state.script); Module._SetStateScript(editorEngine, nPtr, sp); Module._free(sp);
                                state.requires.forEach(it => { Module._AddStateRequire(editorEngine, nPtr, allocateUTF8(it)); });
                                state.actions.forEach(it => { Module._AddStateAction(editorEngine, nPtr, allocateUTF8(it)); });
                                state.properties.forEach(it => { Module._AddStateProperty(editorEngine, nPtr, allocateUTF8(it)); });
                                state.choices.forEach(ch => { Module._AddStateChoice(editorEngine, nPtr); const idx = Module._GetStateChoicesCount(editorEngine, nPtr) - 1; Module._SetStateChoiceText(editorEngine, nPtr, idx, allocateUTF8(ch.text)); Module._SetStateChoiceCondition(editorEngine, nPtr, idx, allocateUTF8(ch.cond)); Module._SetStateChoiceTarget(editorEngine, nPtr, idx, allocateUTF8(ch.target)); Module._SetStateChoiceEffect(editorEngine, nPtr, idx, allocateUTF8(ch.effect)); Module._SetStateChoiceHide(editorEngine, nPtr, idx, ch.hide); });
                                Module._free(nPtr);
                                renderStates();
                                saveToLocalStorage();
                            } catch (e) { console.warn('undo remove state failed', e); }
                        },
                        redo: () => {
                            try { const p = allocateUTF8(name); Module._RemoveState(editorEngine, p); Module._free(p); renderStates(); saveToLocalStorage(); } catch (e) { console.warn('redo remove state failed', e); }
                        }
                    };
                    pushProgramAction(action);
                } catch (e) {}
            }
            Module._free(namePtr);
        }

        // Simplified save logic: use electronCurrentPath or fsCurrentHandle; otherwise trigger Save As
        async function saveFile() {
            const content = generateNS2Content();
            try {
                // Electron environment
                if (window.electronAPI && typeof window.electronAPI.saveFile === 'function') {
                    if (electronCurrentPath) {
                        const res = await window.electronAPI.saveFile(content, electronCurrentPath);
                        if (res && res.error) throw new Error(res.error);
                        setStatus(languages[currentLanguage]['storySaved'] || 'Story saved');
                        lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content; isDirtyText = false; updateFileIndicator();
                        return true;
                    }
                } else if (fsCurrentHandle && typeof fsCurrentHandle.createWritable === 'function') {
                    // Browser File System Access
                    const writable = await fsCurrentHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    setStatus((languages[currentLanguage]['storySaved'] || 'Story saved') + (fsCurrentName ? ` (${fsCurrentName})` : ''));
                    lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content; isDirtyText = false; updateFileIndicator();
                    return true;
                }
            } catch (err) {
                console.warn('Save failed (will attempt Save As)', err);
            }
            return await saveFileAs(content);
        }

        async function saveFileAs(existingContent) {
            const content = existingContent != null ? existingContent : generateNS2Content();
            // Electron Save As
            if (window.electronAPI && typeof window.electronAPI.saveAs === 'function') {
                try {
                    const res = await window.electronAPI.saveAs(content, electronCurrentPath);
                    if (res && res.error) {
                        setStatus((languages[currentLanguage]['errorSavingStory'] || 'Error saving story: {err}').replace('{err}', res.error), true);
                        return false;
                    }
                    if (res && res.path) {
                        electronCurrentPath = res.path;
                        try {
                            if (window.electronFile && typeof window.electronFile.setActive === 'function') {
                                window.electronFile.setActive(electronCurrentPath);
                            }
                        } catch (e) {}
                        setStatus(languages[currentLanguage]['storySaved'] || 'Story saved');
                        lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content; isDirtyText = false; updateFileIndicator();
                        return true;
                    }
                } catch(e) {
                    console.warn('Electron saveAs failed', e);
                }
            }
            // Browser File System Access Save As
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: fsCurrentName || 'story.ns2',
                        types: [{ description: 'NS2 Story', accept: { 'text/plain': ['.ns2'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    fsCurrentHandle = handle;
                    try { const file = await handle.getFile(); fsCurrentName = file && file.name ? file.name : (fsCurrentName || 'story.ns2'); } catch(e){}
                    setStatus((languages[currentLanguage]['storySaved'] || 'Story saved') + (fsCurrentName ? ` (${fsCurrentName})` : ''));
                    lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content; isDirtyText = false; updateFileIndicator();
                    return true;
                } catch(e) {
                    setStatus((languages[currentLanguage]['errorSavingStory'] || 'Error saving story: {err}').replace('{err}', e && e.message ? e.message : String(e)), true);
                    return false;
                }
            }
            // Fallback: download
            try {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = fsCurrentName || 'story.ns2'; a.click(); URL.revokeObjectURL(url);
                setStatus(languages[currentLanguage]['storySaved'] || 'Story saved');
                lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content; isDirtyText = false; updateFileIndicator();
                return true;
            } catch(e) {
                setStatus((languages[currentLanguage]['errorSavingStory'] || 'Error saving story: {err}').replace('{err}', e && e.message ? e.message : String(e)), true);
                return false;
            }
        }

        function generateNS2Content() {
            const ptr = Module._GenerateNS2Content(editorEngine);
            const content = Module.UTF8ToString(ptr);
            Module._FreeString(ptr);
            return content;
        }

        async function initModule() {
            if (!Module) {
                if (typeof NSE2Module === 'undefined') {
                    throw new Error('NSE2Module not defined. Please make sure NSE2.js is loaded and compiled with -s EXPORT_NAME="NSE2Module" -s MODULARIZE=1');
                }
                Module = await NSE2Module();
            }
        }

        // startPlayEngine moved to play.js

        // restartStory moved to play.js

        // saveProgress moved to play.js

        // loadProgress moved to play.js

        // updatePlay moved to play.js

        function filterPlayChoices() {
            const searchInput = document.getElementById('choice-search-play');
            if (!searchInput) return;
            const raw = searchInput.value || '';
            const query = normalizeForMatching(raw).toLowerCase();
            const buttons = document.querySelectorAll('#play-choices button');
            buttons.forEach(btn => {
                try {
                    const txt = normalizeForMatching(btn.textContent || '').toLowerCase();
                    try { btn.hidden = !txt.includes(query); } catch (e) { btn.style.display = txt.includes(query) ? 'block' : 'none'; }
                } catch (e) { try { btn.hidden = false; } catch (ee) { btn.style.display = 'block'; } }
            });
        }

        // filterPlayVars moved to play.js

        // refreshPlayChoiceAvailability moved to play.js

        // setVariableValue moved to play.js

        function buildGraph() {
            let adj = {};
            let radj = {};
            const count = Module._GetStateCount(editorEngine);
            for (let si = 0; si < count; si++) {
                const fromPtr = Module._GetStateName(editorEngine, si);
                const from = Module.UTF8ToString(fromPtr);
                Module._FreeString(fromPtr);
                adj[from] = [];
                radj[from] = [];
                const fromPtr2 = allocateUTF8(from);
                const choiceCount = Module._GetStateChoicesCount(editorEngine, fromPtr2);
                for (let ci = 0; ci < choiceCount; ci++) {
                    const targetPtr = Module._GetStateChoiceTarget(editorEngine, fromPtr2, ci);
                    const target = Module.UTF8ToString(targetPtr);
                    Module._FreeString(targetPtr);
                    const labelPtr = Module._GetStateChoiceText(editorEngine, fromPtr2, ci);
                    const label = Module.UTF8ToString(labelPtr);
                    Module._FreeString(labelPtr);
                    if (target) {
                        adj[from].push({ to: target, label: label || '' });
                        if (!radj[target]) radj[target] = [];
                        radj[target].push({ from: from, label: label || '' });
                    }
                }
                Module._free(fromPtr2);
            }
            return { adj, radj };
        }

        function getNeighbors(start, depth) {
            const { adj, radj } = buildGraph();
            let nodes = new Set();
            let queue = [{ node: start, d: 0 }];
            nodes.add(start);
            while (queue.length) {
                let { node, d } = queue.shift();
                if (d >= depth) continue;
                (adj[node] || []).forEach(({ to }) => {
                    if (!nodes.has(to)) {
                        nodes.add(to);
                        queue.push({ node: to, d: d + 1 });
                    }
                });
                (radj[node] || []).forEach(({ from }) => {
                    if (!nodes.has(from)) {
                        nodes.add(from);
                        queue.push({ node: from, d: d + 1 });
                    }
                });
            }
            return nodes;
        }

        function generateGraphDef(start = null) {
            const { adj, radj } = buildGraph();
            let graphDef = 'flowchart TD\n';
            let nodes = start ? getNeighbors(start, 2) : new Set(Object.keys(adj));
            if (nodes.size === 0) {
                graphDef += '    A["No states defined"]';
                return graphDef;
            }

            // Map original state names to safe mermaid node IDs (avoid spaces/reserved words)
            const idMap = {};
            let idCounter = 1;
            function makeId(name) {
                if (idMap[name]) return idMap[name];
                const id = 'n' + (idCounter++);
                idMap[name] = id;
                return id;
            }

            function escLabel(s) {
                if (!s && s !== 0) return '';
                return String(s).replace(/\|/g, '&#124;').replace(/"/g, '\\"').replace(/\n/g, ' ');
            }

            // Emit node definitions using safe IDs, but show the real title as label
            for (let name of nodes) {
                const namePtr = allocateUTF8(name);
                const sTitlePtr = Module._GetStateTitle(editorEngine, namePtr);
                const sTitle = Module.UTF8ToString(sTitlePtr);
                Module._FreeString(sTitlePtr);
                Module._free(namePtr);
                const id = makeId(name);
                // embed an internal-name marker in the label so we can map rendered nodes back to internal state names
                const marker = '@@ID@@' + name;
                graphDef += `    ${id}["${escLabel(sTitle || name)}"]\n`;
            }

            // expose reverse mapping id -> state name for fallback resolution
            window.graphIdToStateName = {};
            Object.keys(idMap).forEach(k => {
                window.graphIdToStateName[idMap[k]] = k;
            });

            // Emit edges using mapped IDs and sanitized labels
            for (let from of nodes) {
                (adj[from] || []).forEach(({ to, label }) => {
                    if (nodes.has(to)) {
                        const fromId = makeId(from);
                        const toId = makeId(to);
                        graphDef += `    ${fromId} -->|${escLabel(label)}| ${toId}\n`;
                    }
                });
            }

            if (start) {
                const startId = idMap[start] || makeId(start);
                graphDef += `    style ${startId} fill:#007bb0,stroke:#007bb0,stroke-width:2px\n`;
            }
            return graphDef;
        }

        function renderMermaid(graphDef) {
            const container = document.getElementById('graph-container');
            container.innerHTML = '';
            mermaid.render('graphDiv', graphDef).then(({ svg }) => {
                // Inject SVG-internal styles so rules apply inside the generated <svg>
                const injectStyle = `
                    <defs>
                        <linearGradient id="ueGradient" x1="0%" x2="0%" y1="0%" y2="100%">
                            <stop offset="0%" stop-color="#1b6b8a" stop-opacity="1"/>
                            <stop offset="60%" stop-color="#0f394a" stop-opacity="1"/>
                            <stop offset="100%" stop-color="#0b2b36" stop-opacity="1"/>
                        </linearGradient>
                        <filter id="ueDrop" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="0" dy="8" stdDeviation="16" flood-color="#000" flood-opacity="0.45"/>
                        </filter>
                    </defs>
                    <style>
                        /* Apply UE-like gradient + shadow to node bodies */
                        .node rect { fill: url(#ueGradient) !important; stroke: rgba(0,0,0,0.6) !important; stroke-width: 1.5px !important; filter: url(#ueDrop) !important; rx:8; ry:8; }
                        /* Slightly brighter stroke for hovered/selected states */
                        .node:hover rect, .node.graph-hover rect { stroke: #33c3ff !important; stroke-width: 2px !important; }
                        .node.graph-selected rect { stroke: #ffd166 !important; stroke-width: 2.5px !important; }
                        /* Node title styling */
                        .node text { fill: #FFFFFF !important; font-weight:700 !important; font-family: 'Segoe UI', Roboto, sans-serif !important; font-size:12px !important; text-shadow: 0 2px 6px rgba(0,0,0,0.6); }
                        /* Edge appearance */
                        .edgePath .path { stroke: #99e6ff !important; stroke-width: 2.5px !important; stroke-linecap: round !important; }
                        /* Make labels legible */
                        .edgeLabel, .edgeLabel text { fill: #e6fbff !important; }
                    </style>
                `;
                // Insert style right after opening <svg ...>
                const svgWithStyle = svg.replace(/<svg([^>]*)>/i, `<svg$1>${injectStyle}`);
                container.innerHTML = svgWithStyle;
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    svgElement.removeAttribute('width');
                    svgElement.removeAttribute('height');
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                    svgElement.style.maxWidth = 'none';
                    const ns = 'http://www.w3.org/2000/svg';
                    const contentG = svgElement.querySelector('g');
                    // No overlay/pins ‚Äî we style existing Mermaid nodes with SVG-local defs/styles above
                    graphPanZoom = panzoom(contentG, { 
                        maxZoom: 5, 
                        minZoom: 0.1, 
                        bounds: false
                    });
                    const bbox = contentG.getBBox();
                    const containerRect = container.getBoundingClientRect();
                    const scale = Math.min(containerRect.width / bbox.width, containerRect.height / bbox.height) * 0.8;
                    // Set initial zoom and center
                    if (typeof graphPanZoom.zoomAbs === 'function') graphPanZoom.zoomAbs(0, 0, scale);
                    const offsetX = (containerRect.width / 2) - (bbox.width * scale / 2) - (bbox.x * scale);
                    const offsetY = (containerRect.height / 2) - (bbox.height * scale / 2) - (bbox.y * scale);
                    if (typeof graphPanZoom.moveTo === 'function') graphPanZoom.moveTo(offsetX, offsetY);
                    // Track current scale and add safe zoomIn/zoomOut helpers in case panzoom lacks them
                    try {
                        graphCurrentScale = scale || 1;
                        // Provide consistent zoomIn/zoomOut methods that use zoomAbs
                        graphPanZoom._zoomDelta = function(delta) {
                            // delta is multiplicative factor (e.g. 0.1 -> +10%)
                            const factor = 1 + (delta || 0.1);
                            graphCurrentScale = Math.max(Math.min(graphCurrentScale * factor, 5), 0.1);
                            if (typeof graphPanZoom.zoomAbs === 'function') graphPanZoom.zoomAbs(0, 0, graphCurrentScale);
                        };
                        graphPanZoom.zoomIn = function(delta) { graphPanZoom._zoomDelta(delta || 0.1); };
                        graphPanZoom.zoomOut = function(delta) { graphPanZoom._zoomDelta(-(delta || 0.1)); };
                    } catch (e) {}
                    const nodes = svgElement.querySelectorAll('.node');
                    nodes.forEach(node => {
                        const labelElement = node.querySelector('text');
                        if (labelElement) {
                            // Add a blueprint-style header band and input/output pins
                            try {
                                const ns = 'http://www.w3.org/2000/svg';
                                // Try to use the node's primary shape bbox (rect/polygon) so header aligns correctly
                                let baseShape = node.querySelector('rect, polygon, path, ellipse');
                                let shapeBBox = null;
                                try {
                                    if (baseShape) shapeBBox = baseShape.getBBox();
                                } catch (e) { shapeBBox = null; }
                                // Fallback to group's bbox
                                let nodeBBox = null;
                                try { nodeBBox = node.getBBox(); } catch (e) { nodeBBox = null; }
                                const refBBox = shapeBBox || nodeBBox || { x: 0, y: 0, width: 120, height: 48 };
                                const headerH = Math.max(18, Math.min(32, refBBox.height * 0.22));

                                // Avoid duplicating when re-rendering: create an overlay group painted last
                                if (!node.querySelector('.bp-overlay')) {
                                    const overlay = document.createElementNS(ns, 'g');
                                    overlay.setAttribute('class', 'bp-overlay');
                                    overlay.style.pointerEvents = 'none';

                                    // Header rect appended into overlay so it is rendered on top
                                    const headerRect = document.createElementNS(ns, 'rect');
                                    headerRect.setAttribute('class', 'bp-header');
                                    headerRect.setAttribute('x', String(refBBox.x));
                                    headerRect.setAttribute('y', String(refBBox.y));
                                    headerRect.setAttribute('width', String(Math.max(8, refBBox.width)));
                                    headerRect.setAttribute('height', String(Math.max(6, headerH)));
                                    headerRect.setAttribute('rx', '6');
                                    headerRect.setAttribute('ry', '6');
                                    // inline styles to ensure visibility even if external CSS fails
                                    headerRect.setAttribute('fill', '#0b66a1');
                                    headerRect.setAttribute('stroke', 'rgba(0,0,0,0.4)');
                                    headerRect.setAttribute('stroke-width', '1');
                                    overlay.appendChild(headerRect);

                                    // Pins: left (input) and right (output)
                                    const pinRadius = Math.max(4, Math.min(7, headerH * 0.36));
                                    const cy = refBBox.y + (headerH / 2);
                                    const leftCx = refBBox.x - (pinRadius + 2);
                                    const rightCx = refBBox.x + refBBox.width + (pinRadius + 2);

                                    const leftPin = document.createElementNS(ns, 'circle');
                                    leftPin.setAttribute('class', 'bp-pin in');
                                    leftPin.setAttribute('cx', String(leftCx));
                                    leftPin.setAttribute('cy', String(cy));
                                    leftPin.setAttribute('r', String(pinRadius));
                                    leftPin.setAttribute('fill', '#7ed6ff');
                                    leftPin.setAttribute('stroke', '#00a3d1');
                                    leftPin.setAttribute('stroke-width', '1');
                                    overlay.appendChild(leftPin);

                                    const rightPin = document.createElementNS(ns, 'circle');
                                    rightPin.setAttribute('class', 'bp-pin out');
                                    rightPin.setAttribute('cx', String(rightCx));
                                    rightPin.setAttribute('cy', String(cy));
                                    rightPin.setAttribute('r', String(pinRadius));
                                    rightPin.setAttribute('fill', '#ffd166');
                                    rightPin.setAttribute('stroke', '#ff9f1c');
                                    rightPin.setAttribute('stroke-width', '1');
                                    overlay.appendChild(rightPin);

                                    // Append overlay as last child of node so it paints on top
                                    node.appendChild(overlay);
                                }
                            } catch (e) {
                                // if SVG bbox access fails (browser quirk), ignore and continue
                            }
                            // Determine internal state name from the node's id via window.graphIdToStateName mapping
                            const fullId = node.id || node.getAttribute('id') || '';
                            
                            
                            // Mermaid adds a prefix like 'flowchart-' to node IDs
                            // Extract the base ID (e.g., 'n4' from 'flowchart-n4-3')
                            let baseId = fullId;
                            if (fullId.includes('-')) {
                                // Try to extract n<number> pattern
                                const match = fullId.match(/n\d+/);
                                if (match) {
                                    baseId = match[0];
                                }
                            }
                            
                            
                            let internalName = null;
                            if (baseId && window.graphIdToStateName && window.graphIdToStateName[baseId]) {
                                internalName = window.graphIdToStateName[baseId];
                            } else {
                                // Fallback: try to match the visible label text to a state title or name
                                const labelText = (labelElement.textContent || '').trim();
                                
                                if (labelText) {
                                    try {
                                        const stateCount = Module._GetStateCount(editorEngine);
                                        for (let si = 0; si < stateCount; si++) {
                                            const sNamePtr = Module._GetStateName(editorEngine, si);
                                            const sName = Module.UTF8ToString(sNamePtr);
                                            Module._FreeString(sNamePtr);
                                            const sTitlePtr = Module._GetStateTitle(editorEngine, allocateUTF8(sName));
                                            const sTitle = Module.UTF8ToString(sTitlePtr);
                                            Module._FreeString(sTitlePtr);
                                            if (sTitle === labelText || sName === labelText) {
                                                internalName = sName;
                                                break;
                                            }
                                        }
                                    } catch (e) {
                                    }
                                }
                                // Last resort: use the raw label text as-is
                                if (!internalName) {
                                    internalName = labelText || '';
                                    
                                }
                            }
                            node.setAttribute('data-state', internalName);

                            // Ensure pointer events and visual cursor on SVG nodes and children
                            try {
                                node.style.pointerEvents = 'auto';
                                node.style.cursor = 'pointer';
                                Array.from(node.querySelectorAll('*')).forEach(el => { try { el.style.pointerEvents = 'auto'; el.style.cursor = 'pointer'; } catch (e) {} });
                            } catch (e) {}

                            // Debug mapping
                            

                            // Only attempt to fetch state description/title if we have a likely internal name
                            let desc = '';
                            try {
                                if (internalName) {
                                    // verify state exists by searching for internalName among state names
                                    let found = false;
                                    const sc = Module._GetStateCount(editorEngine);
                                    for (let s = 0; s < sc; s++) {
                                        const nPtr = Module._GetStateName(editorEngine, s);
                                        const n = Module.UTF8ToString(nPtr);
                                        Module._FreeString(nPtr);
                                        if (n === internalName) { found = true; break; }
                                    }
                                    if (found) {
                                        const namePtr = allocateUTF8(internalName);
                                        const descPtr = Module._GetStateDescription(editorEngine, namePtr);
                                        desc = Module.UTF8ToString(descPtr);
                                        Module._FreeString(descPtr);
                                        Module._free(namePtr);
                                    }
                                }
                            } catch (e) {
                                console.warn('[renderMermaid] error fetching state description:', e);
                            }
                            const title = document.createElementNS(ns, 'title');
                            title.textContent = (desc && desc.slice) ? desc.slice(0, 200) : '';
                            node.appendChild(title);

                            // Helper to open state
                            const openStateFromNode = (ev) => {
                                try { ev && ev.stopPropagation(); } catch (e) {}
                                if (internalName) {
                                    scopeToState(internalName);
                                    openTab('states');
                                }
                            };

                            // Helper to show context menu
                            const showContextFromNode = (ev) => {
                                if (document.getElementById('tab-graph').classList.contains('active')) {
                                    try { ev && ev.preventDefault(); } catch (e) {}
                                    graphSelectedState = internalName;
                                    showGraphContextMenu((ev && ev.pageX) || 0, (ev && ev.pageY) || 0);
                                }
                            };

                            // Attach listeners in capture phase for robustness
                            try {
                                node.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); }, { passive: true, capture: true });
                                node.addEventListener('click', openStateFromNode, true);
                                node.addEventListener('contextmenu', showContextFromNode, true);
                            } catch (e) {
                                // fallback
                                node.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); });
                                node.addEventListener('click', openStateFromNode);
                                node.addEventListener('contextmenu', showContextFromNode);
                            }

                            // Also attach to inner shape/text to ensure events fire when those elements capture them
                            const innerShape = node.querySelector('rect, polygon, circle, ellipse, path');
                            if (innerShape) {
                                try { innerShape.style.cursor = 'pointer'; innerShape.style.pointerEvents = 'auto'; } catch (e) {}
                                innerShape.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); }, true);
                                innerShape.addEventListener('click', openStateFromNode, true);
                                innerShape.addEventListener('contextmenu', showContextFromNode, true);
                            }
                            if (labelElement) {
                                try { labelElement.style.cursor = 'pointer'; labelElement.style.pointerEvents = 'none'; } catch (e) {}
                                labelElement.addEventListener('pointerdown', (ev) => { if (ev.button === 0) openStateFromNode(ev); }, true);
                                labelElement.addEventListener('click', openStateFromNode, true);
                                labelElement.addEventListener('contextmenu', showContextFromNode, true);
                            }

                            // Hover visual
                            node.addEventListener('pointerenter', () => { node.classList.add('graph-hover'); }, true);
                            node.addEventListener('pointerleave', () => { node.classList.remove('graph-hover'); }, true);

                            // Insert small Font Awesome icon overlay (foreignObject) at top-left of node
                            try {
                                const nodeBBox = node.getBBox();
                                const fo = document.createElementNS(ns, 'foreignObject');
                                fo.setAttribute('x', String(nodeBBox.x + 6));
                                fo.setAttribute('y', String(nodeBBox.y + 6));
                                fo.setAttribute('width', '18');
                                fo.setAttribute('height', '18');
                                fo.setAttribute('class', 'graph-icon-fo');
                                fo.innerHTML = `<div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"width:18px;height:18px;display:flex;align-items:center;justify-content:center;pointer-events:none\"><i class=\"fas fa-book\" style=\"font-size:13px;color:#fff;font-family:'Font Awesome 6 Free';font-weight:900;\"></i></div>`;
                                node.appendChild(fo);
                            } catch (e) {}
                        }
                    });

                    // Diagnostics: log how many nodes and overlays were created (dev only)
                    try { console.debug('[renderMermaid] nodes:', nodes.length, 'bp-overlays:', svgElement.querySelectorAll('.bp-overlay').length); } catch(e) {}

                    // Fallback: container-level click handler to catch clicks that don't reach node elements
                    try {
                        // remove previous handler if present
                        if (container._graphClickHandler) container.removeEventListener('click', container._graphClickHandler, true);
                        container._graphClickHandler = function(e) {
                            try {
                                const node = e.target && e.target.closest && e.target.closest('.node');
                                if (node) {
                                    const st = node.getAttribute('data-state') || node.dataset.state;
                                    if (st) {
                                        // primary button only
                                        if (e.button === 0 || e.type === 'click') {
                                            e.stopPropagation();
                                            scopeToState(st);
                                            openTab('states');
                                        }
                                    }
                                }
                            } catch (err) {}
                        };
                        container.addEventListener('click', container._graphClickHandler, true);
                        // remove previous pointer handlers if present
                        if (container._graphPointerDown) {
                            container.removeEventListener('pointerdown', container._graphPointerDown, true);
                            container.removeEventListener('pointermove', container._graphPointerMove, true);
                            container.removeEventListener('pointerup', container._graphPointerUp, true);
                            container.removeEventListener('contextmenu', container._graphContext, true);
                        }

                        // pointer tracking to distinguish click vs drag (so pan/zoom still works)
                        container._graphPointerTracker = {};
                        container._graphPointerDown = function(e) {
                            try {
                                if (!e.isPrimary) return;
                                container._graphPointerTracker.pointerId = e.pointerId;
                                container._graphPointerTracker.startX = e.clientX;
                                container._graphPointerTracker.startY = e.clientY;
                                container._graphPointerTracker.moved = false;
                                container._graphPointerTracker.downTarget = (e.target && e.target.closest) ? e.target.closest('.node') : null;
                            } catch (err) {}
                        };
                        container._graphPointerMove = function(e) {
                            try {
                                const t = container._graphPointerTracker;
                                if (!t || typeof t.startX !== 'number') return;
                                const dx = e.clientX - t.startX;
                                const dy = e.clientY - t.startY;
                                if (Math.hypot(dx, dy) > 6) t.moved = true;
                            } catch (err) {}
                        };
                        container._graphPointerUp = function(e) {
                            try {
                                const t = container._graphPointerTracker;
                                if (!t) return;
                                // only primary
                                if (e.button !== 0) return;
                                const clickedNode = (e.target && e.target.closest) ? e.target.closest('.node') : null;
                                // prefer the node where pointerdown started
                                const node = t.downTarget || clickedNode;
                                if (node && !t.moved) {
                                    const st = node.getAttribute('data-state') || node.dataset.state;
                                    if (st) {
                                        try { e.stopPropagation(); } catch (er) {}
                                        scopeToState(st);
                                        openTab('states');
                                    }
                                }
                                // reset tracker
                                container._graphPointerTracker = {};
                            } catch (err) {}
                        };

                        container._graphContext = function(e) {
                            try {
                                // find node under cursor at event position
                                const el = document.elementFromPoint(e.clientX, e.clientY);
                                const node = el && el.closest ? el.closest('.node') : null;
                                if (node) {
                                    e.preventDefault();
                                    // Try attribute first
                                    let st = node.getAttribute('data-state') || node.dataset.state || null;
                                    // If not set or empty, try to resolve via node id -> mapping
                                    if (!st) {
                                        try {
                                            const fullId = node.id || node.getAttribute('id') || '';
                                            let baseId = fullId;
                                            if (fullId && fullId.includes('-')) {
                                                const match = fullId.match(/n\d+/);
                                                if (match) baseId = match[0];
                                            }
                                            if (baseId && window.graphIdToStateName && window.graphIdToStateName[baseId]) {
                                                st = window.graphIdToStateName[baseId];
                                            }
                                        } catch (e) {
                                        
                                        }
                                    }

                                    // If still not resolved, try matching visible label text to state titles/names (case-insensitive)
                                    if (!st) {
                                        try {
                                            const labelEl = node.querySelector && node.querySelector('text');
                                            const labelText = labelEl ? (labelEl.textContent || '').trim().toLowerCase() : '';
                                            if (labelText) {
                                                const sc = Module._GetStateCount(editorEngine);
                                                for (let si = 0; si < sc; si++) {
                                                    const nPtr = Module._GetStateName(editorEngine, si);
                                                    const n = Module.UTF8ToString(nPtr);
                                                    Module._FreeString(nPtr);
                                                    const tPtr = Module._GetStateTitle(editorEngine, allocateUTF8(n));
                                                    const t = Module.UTF8ToString(tPtr);
                                                    Module._FreeString(tPtr);
                                                    if ((n && n.toLowerCase().trim() === labelText) || (t && t.toLowerCase().trim() === labelText)) {
                                                        st = n;
                                                        break;
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                        
                                        }
                                    }

                                    
                                    graphSelectedState = st || null;
                                    showGraphContextMenu(e.pageX, e.pageY);
                                } else {
                                    
                                }
                            } catch (err) {
                                console.error('[graph context] error:', err);
                            }
                        };

                        container.addEventListener('pointerdown', container._graphPointerDown, true);
                        container.addEventListener('pointermove', container._graphPointerMove, true);
                        container.addEventListener('pointerup', container._graphPointerUp, true);
                        container.addEventListener('contextmenu', container._graphContext, true);
                    } catch (e) {}
                    // If a specific graph state was requested, highlight it now (ensure UI centers on it)
                            try {
                                if (typeof highlightGraphNode === 'function' && currentGraphState) {
                                    // schedule on next tick so DOM/SVG is fully ready
                                    setTimeout(() => {
                                        try { highlightGraphNode(currentGraphState); } catch (e) { }
                                    }, 30);
                                }
                            } catch (e) {}
                }
            }).catch(e => {
                const container = document.getElementById('graph-container');
                container.innerHTML = '<div style="color: #D4D4D4; text-align: center; padding: 20px;">Error rendering graph: ' + e.message + '</div>';
                setStatus("Error rendering graph: " + e.message, true);
            });
        }

        function renderGraph() {
            const count = Module._GetStateCount(editorEngine);
            const graphDef = generateGraphDef(currentGraphState);
            renderMermaid(graphDef);
        }

        function resetGraph() {
            currentGraphState = null;
            renderGraph();
        }

        function zoomIn() {
            if (graphPanZoom) {
                graphPanZoom.zoomIn(0.1);
            }
        }

        function zoomOut() {
            if (graphPanZoom) {
                graphPanZoom.zoomOut(0.1);
            }
        }

        function centerGraph() {
            if (graphPanZoom) {
                const container = document.getElementById('graph-container');
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    const contentG = svgElement.querySelector('g');
                    const bbox = contentG.getBBox();
                    const containerRect = container.getBoundingClientRect();
                    const scale = Math.min(containerRect.width / bbox.width, containerRect.height / bbox.height) * 0.8;
                    graphPanZoom.zoomAbs(0, 0, scale);
                    const offsetX = (containerRect.width / 2) - (bbox.width * scale / 2) - (bbox.x * scale);
                    const offsetY = (containerRect.height / 2) - (bbox.height * scale / 2) - (bbox.y * scale);
                    graphPanZoom.moveTo(offsetX, offsetY);
                }
            }
        }

        // Highlight a graph node corresponding to a state name, and center it in view
        function highlightGraphNode(stateName) {
            const container = document.getElementById('graph-container');
            if (!container) return;
            const svgElement = container.querySelector('svg');
            if (!svgElement) return;
            // remove previous selection
            svgElement.querySelectorAll('.node.graph-selected').forEach(n => n.classList.remove('graph-selected'));
            if (!stateName) return;
            // find node by data-state
            const node = svgElement.querySelector(`.node[data-state="${CSS.escape(stateName)}"]`) || svgElement.querySelector(`.node[data-state='${stateName}']`);
            if (!node) return;
            node.classList.add('graph-selected');
            // try to center the node
            try {
                const contentG = svgElement.querySelector('g');
                const bbox = node.getBBox();
                const containerRect = container.getBoundingClientRect();
                const scale = Math.min(containerRect.width / bbox.width, containerRect.height / bbox.height) * 0.6;
                if (graphPanZoom && typeof graphPanZoom.zoomAbs === 'function') graphPanZoom.zoomAbs(0, 0, scale);
                const offsetX = (containerRect.width / 2) - (bbox.width * scale / 2) - (bbox.x * scale);
                const offsetY = (containerRect.height / 2) - (bbox.height * scale / 2) - (bbox.y * scale);
                if (graphPanZoom && typeof graphPanZoom.moveTo === 'function') graphPanZoom.moveTo(offsetX, offsetY);
            } catch (e) {}
        }
        function setupContextMenu() {
            // Global contextmenu handler with tab check
            document.addEventListener('contextmenu', (e) => {
                const activeTab = document.querySelector('.tab-content.active');
                const target = e.target;
                if (activeTab && activeTab.contains(target)) {
                    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                        e.preventDefault();
                        currentInput = target;
                        showContextMenu(e.pageX, e.pageY);
                    }
                } else if (target.closest('#graph-container') && document.getElementById('tab-graph').classList.contains('active')) {
                    // Graph-specific: let it bubble so container handler can process it
                    // Do NOT preventDefault here; let the container._graphContext handler do it
                    
                }
                // Otherwise, allow default inspect
            }, true); // Use capture phase for higher priority
            document.addEventListener('click', hideContextMenu);
            document.addEventListener('click', hideGraphContextMenu);
            // Close context/graph menus on Escape key (capture phase)
            document.addEventListener('keydown', (e) => {
                try {
                    if (e.key === 'Escape' || e.key === 'Esc') {
                        const cm = document.getElementById('context-menu');
                        const gm = document.getElementById('graph-context-menu');
                        let closed = false;
                        if (cm && cm.style && cm.style.display && cm.style.display !== 'none') { hideContextMenu(); closed = true; }
                        if (gm && gm.style && gm.style.display && gm.style.display !== 'none') { hideGraphContextMenu(); closed = true; }
                        if (closed) { e.stopPropagation(); e.preventDefault(); }
                    }
                } catch (ex) {}
            }, true);
            document.getElementById('context-menu').addEventListener('click', (e) => e.stopPropagation());
            const ctxSearch = document.getElementById('context-search');
            if (ctxSearch) {
                try { ctxSearch.addEventListener('focus', (e) => e.stopPropagation()); } catch (e) {}
                try { ctxSearch.addEventListener('mousedown', (e) => e.stopPropagation()); } catch (e) {}
                try { ctxSearch.addEventListener('click', (e) => e.stopPropagation()); } catch (e) {}
                // Ensure input events reach filterContextMenu even if inline handlers fail
                try { ctxSearch.addEventListener('input', filterContextMenu); } catch (e) {}
            }

            // Global input listener for debugging and to catch dropdown search inputs
            // input event listener (no debug logging)
            document.addEventListener('input', (e) => {
                try {
                    const t = e.target;
                    if (!t) return;
                    // previously logged debug events here; removed for production
                } catch (ex) {}
            }, true);
        }

        // Centralized shortcut map and helpers to ensure keyboard triggers exact button actions
        const SHORTCUTS = {
            'Ctrl+S': { action: 'file-save' },
            'Ctrl+O': { action: 'file-open' },
            'Ctrl+N': { action: 'file-new' },
            'Ctrl+P': { action: 'play-start' },
            'Ctrl+L': { action: 'play-loadprogress' },
            'Ctrl+Shift+L': { action: 'play-saveprogress' },
            'Ctrl+R': { action: 'play-restart' },
            // Tab switching
            'Ctrl+1': { fn: () => openTab('text') },
            'Ctrl+2': { fn: () => openTab('metadata') },
            'Ctrl+3': { fn: () => openTab('variables') },
            'Ctrl+4': { fn: () => openTab('states') },
            'Ctrl+5': { fn: () => openTab('graph') },
            'Ctrl+6': { fn: () => openTab('play') },
        };

        function normalizeKeyEvent(e){
            const parts = [];
            if(e.ctrlKey || e.metaKey) parts.push('Ctrl');
            if(e.shiftKey) parts.push('Shift');
            if(e.altKey) parts.push('Alt');
            const k = e.key.length === 1 ? e.key.toUpperCase() : e.key;
            parts.push(k);
            return parts.join('+');
        }

        // Basic cooldown to prevent repeated dialogs from auto-repeat or duplicate listeners
        const __actionCooldown = Object.create(null);
        function clickAction(actionName){
            try{
                const now = Date.now();
                const last = __actionCooldown[actionName] || 0;
                if (now - last < 800) return true; // treat as handled; suppress duplicates
                const btn = document.querySelector(`[data-action="${actionName}"]`);
                if(btn && !btn.disabled){
                    __actionCooldown[actionName] = now;
                    btn.click();
                    return true;
                }
            }catch(e){}
            return false;
        }

        function applyShortcutHints(){
            const hints = {
                'file-save': 'Ctrl+S',
                'file-open': 'Ctrl+O',
                'file-new': 'Ctrl+N',
                'play-start': 'Ctrl+P',
                'play-loadprogress': 'Ctrl+L',
                'play-saveprogress': 'Ctrl+Shift+L',
                'play-restart': 'Ctrl+R',
                'undo-btn': 'Ctrl+Z',
                'redo-btn': 'Ctrl+Y',
            };
            Object.entries(hints).forEach(([action, combo])=>{
                try{
                    const el = document.querySelector(`[data-action="${action}"]`);
                    if(!el) return;
                    const t = el.title || '';
                    if(!t.includes('(' + combo + ')')) el.title = t ? `${t} (${combo})` : combo;
                }catch(e){}
            });
        }

        let __kbInstalled = false;
        let __kbHandler = null;
        function setupKeyboardShortcuts() {
            if (__kbInstalled && __kbHandler) return; // ensure single attachment across re-renders
            __kbHandler = (e) => {
                // Do not override Monaco typing for undo/redo; those are handled separately above
                const active = document.activeElement;
                const inMonaco = !!(active && active.closest && active.closest('.monaco-editor'));

                // Graph navigation (non-modifier)
                try {
                    const activeTabBtn = document.querySelector('.tab-button.active');
                    const activeTab = activeTabBtn ? (activeTabBtn.textContent||'').toLowerCase() : '';
                    if (activeTab === 'graph' && !(e.ctrlKey||e.metaKey||e.altKey)) {
                        switch (e.key) {
                            case '=':
                            case '+': e.preventDefault(); zoomIn(); return;
                            case '-': e.preventDefault(); zoomOut(); return;
                            case '0': e.preventDefault(); centerGraph(); return;
                            case 'ArrowLeft': e.preventDefault(); if (graphPanZoom) graphPanZoom.moveBy(-20, 0); return;
                            case 'ArrowRight': e.preventDefault(); if (graphPanZoom) graphPanZoom.moveBy(20, 0); return;
                            case 'ArrowUp': e.preventDefault(); if (graphPanZoom) graphPanZoom.moveBy(0, -20); return;
                            case 'ArrowDown': e.preventDefault(); if (graphPanZoom) graphPanZoom.moveBy(0, 20); return;
                        }
                    }
                } catch (ex) {}

                // Handle mapped shortcuts
                const keySig = normalizeKeyEvent(e);
                if ((e.ctrlKey || e.metaKey) || e.altKey) {
                    // Tab numbers
                    if ((e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey && e.key >= '1' && e.key <= '6') {
                        e.preventDefault();
                        const tabs = ['text', 'metadata', 'variables', 'states', 'graph', 'play'];
                        openTab(tabs[parseInt(e.key) - 1]);
                        return;
                    }

                    const handler = SHORTCUTS[keySig];
                    if (handler) {
                        e.preventDefault();
                        if (handler.action) {
                            if (clickAction(handler.action)) return;
                        }
                        if (typeof handler.fn === 'function') {
                            const ok = handler.fn();
                            if (ok !== false) return;
                        }
                    }
                }
            };
            document.addEventListener('keydown', __kbHandler);
            __kbInstalled = true;
        }

        function showContextMenu(x, y) {
            const menu = document.getElementById('context-menu');
            const list = document.getElementById('token-menu-list');
            list.innerHTML = '';
            try { console.log('[ns2] showContextMenu', { x: x, y: y, hasInput: !!currentInput }); } catch(e) {}

            // Copy, Cut, Paste first, always visible with icons
                const copyLi = document.createElement('li');
                copyLi.className = 'menu-item';
                const copyLabel = languages[currentLanguage] && languages[currentLanguage]['Copy'] ? languages[currentLanguage]['Copy'] : 'Copy';
                copyLi.innerHTML = `<i class="fas fa-copy" style="margin-right: 8px;"></i> <span class="token">${copyLabel}</span>`;
            copyLi.onclick = () => {
                currentInput.select();
                document.execCommand('copy');
                hideContextMenu();
            };
            list.appendChild(copyLi);

            const cutLi = document.createElement('li');
            cutLi.className = 'menu-item';
            const cutLabel = languages[currentLanguage] && languages[currentLanguage]['Cut'] ? languages[currentLanguage]['Cut'] : 'Cut';
            cutLi.innerHTML = `<i class="fas fa-cut" style="margin-right: 8px;"></i> <span class="token">${cutLabel}</span>`;
            cutLi.onclick = () => {
                currentInput.select();
                document.execCommand('cut');
                hideContextMenu();
            };
            list.appendChild(cutLi);

            const pasteLi = document.createElement('li');
            pasteLi.className = 'menu-item';
            const pasteLabel = languages[currentLanguage] && languages[currentLanguage]['Paste'] ? languages[currentLanguage]['Paste'] : 'Paste';
            pasteLi.innerHTML = `<i class="fas fa-paste" style="margin-right: 8px;"></i> <span class="token">${pasteLabel}</span>`;
            pasteLi.onclick = () => {
                navigator.clipboard.readText().then(text => {
                    insertTextAtCursor(currentInput, text);
                    hideContextMenu();
                });
            };
            list.appendChild(pasteLi);

            const separator = document.createElement('li');
            separator.className = 'menu-separator';
            separator.setAttribute('aria-hidden', 'true');
            separator.style.borderTop = '1px solid #3C3C3C';
            separator.style.padding = '0';
            separator.style.margin = '5px 0';
            separator.style.pointerEvents = 'none';
            list.appendChild(separator);

            // Then tokens, grouped by category for easier discovery
            const categorized = {
                'Functions': [],
                'Operators': [],
                'Constants': [],
                'States': [],
                'Variables': [],
                'Other': []
            };

            tokens.forEach(token => {
                if (functionTokens.includes(token)) categorized['Functions'].push(token);
                else if (operatorTokens.includes(token)) categorized['Operators'].push(token);
                else if (constantTokens.includes(token)) categorized['Constants'].push(token);
                else if (stateTokens.includes(token)) categorized['States'].push(token);
                else if (variableTokens.includes(token)) categorized['Variables'].push(token);
                else categorized['Other'].push(token);
            });

            // Sort each category alphabetically (natural order) and render with headers
            Object.keys(categorized).forEach(cat => {
                const items = Array.from(new Set(categorized[cat])).sort((a,b) => a.localeCompare(b, undefined, {numeric:true, sensitivity:'base'}));
                if (!items.length) return;

                // category header
                const header = document.createElement('li');
                header.className = 'menu-category';
                header.textContent = cat;
                list.appendChild(header);

                items.forEach(token => {
                    const li = document.createElement('li');
                    li.className = 'menu-item';
                    const tokenSpan = document.createElement('span'); tokenSpan.className = 'token'; tokenSpan.textContent = token;
                    const exampleSpan = document.createElement('span'); exampleSpan.className = 'example'; exampleSpan.textContent = tokenExamples[token] || '';
                    li.appendChild(tokenSpan);
                    li.appendChild(exampleSpan);
                    li.onclick = () => insertTextAtCursor(currentInput, token);
                    list.appendChild(li);
                });

                // separator between categories
                const sep = document.createElement('li');
                sep.className = 'menu-separator';
                sep.setAttribute('aria-hidden', 'true');
                sep.style.borderTop = '1px solid #3C3C3C';
                sep.style.padding = '0';
                sep.style.margin = '6px 0';
                sep.style.pointerEvents = 'none';
                list.appendChild(sep);
            });

            document.getElementById('context-search').value = '';
            filterContextMenu();
            // Place menu and clamp to viewport so it never clips offscreen
            menu.style.visibility = 'hidden';
            menu.style.display = 'flex';
            // allow layout to occur then measure
            requestAnimationFrame(() => {
                const rect = menu.getBoundingClientRect();
                const margin = 8;
                let left = x;
                let top = y;
                // clamp horizontally
                if (left + rect.width > window.innerWidth - margin) left = Math.max(margin, window.innerWidth - rect.width - margin);
                if (left < margin) left = margin;
                // clamp vertically; prefer below cursor, otherwise place above
                if (top + rect.height > window.innerHeight - margin) {
                    // try placing above cursor
                    if (y - rect.height > margin) top = Math.max(margin, y - rect.height);
                    else top = Math.max(margin, window.innerHeight - rect.height - margin);
                }
                if (top < margin) top = margin;
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                menu.style.visibility = 'visible';
            });
        }

        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }

        function filterContextMenu() {
                    const raw = (document.getElementById('context-search') && document.getElementById('context-search').value) || '';
                    const query = normalizeForMatching(raw).toLowerCase();
                    // debug logging removed

                    // Prefer explicit menu-item markers, but fall back to any LI (excluding categories/separators)
                    let items = Array.from(document.querySelectorAll('#token-menu-list li.menu-item'));
                    if (!items.length) {
                        items = Array.from(document.querySelectorAll('#token-menu-list li')).filter(li => {
                            if (li.classList && (li.classList.contains('menu-category') || li.classList.contains('menu-separator'))) return false;
                            return true;
                        });
                    }

                    // debug logging removed

                    items.forEach((li, idx) => {
                        try {
                            // Collect a few sensible text sources so this works across different menu renderers
                            let tokenTextRaw = '';
                            const tokenEl = li.querySelector && (li.querySelector('.token') || li.querySelector('.example') || li.querySelector('button') || li.querySelector('span'));
                            if (tokenEl && tokenEl.textContent) tokenTextRaw = tokenEl.textContent;
                            else if (li.dataset && li.dataset.name) tokenTextRaw = li.dataset.name;
                            else tokenTextRaw = li.textContent || '';

                            const tokenText = normalizeForMatching(tokenTextRaw).toLowerCase();
                            const ok = (query === '' || tokenText.includes(query));
                            // Use the boolean `hidden` attribute rather than inline display toggles.
                            // This is more reliable and works with the CSS rule we added above.
                            try { li.hidden = !ok; } catch (e) { li.style.display = ok ? '' : 'none'; }
                            // log first few items for diagnostics
                            // debug logging removed
                        } catch (e) { try { ns2Debug({ err: 'item-check-failed', idx: idx }); } catch(e) {} }
                    });

                    // Now adjust category headers and separators based on whether their items are visible
                    const headers = Array.from(document.querySelectorAll('#token-menu-list li.menu-category'));
                    headers.forEach(header => {
                        let anyVisible = false;
                        let node = header.nextElementSibling;
                        while (node) {
                            if (node.classList && node.classList.contains('menu-category')) break; // next category
                            // skip over separators
                            if (node.classList && node.classList.contains('menu-separator')) { node = node.nextElementSibling; continue; }
                            // If an element is not hidden (or doesn't have hidden true), consider it visible
                            if (!(node.hidden === true) && (node.style ? node.style.display !== 'none' : true)) { anyVisible = true; break; }
                            node = node.nextElementSibling;
                        }
                        try { header.hidden = !anyVisible; } catch(e) { header.style.display = anyVisible ? 'block' : 'none'; }
                        // find separator after this category and show/hide it accordingly
                        let sep = header.nextElementSibling;
                        while (sep) {
                            if (sep.classList && sep.classList.contains('menu-separator')) { try { sep.hidden = !anyVisible; } catch(e) { sep.style.display = anyVisible ? 'block' : 'none'; } break; }
                            if (sep.classList && sep.classList.contains('menu-category')) break;
                            sep = sep.nextElementSibling;
                        }
                    });
        }

        function insertTextAtCursor(input, text) {
            const start = input.selectionStart;
            const end = input.selectionEnd;
            input.value = input.value.substring(0, start) + text + input.value.substring(end);
            input.selectionStart = input.selectionEnd = start + text.length;
            input.focus();
            hideContextMenu();
            input.dispatchEvent(new Event('change'));
        }

        function showGraphContextMenu(x, y) {
            const menu = document.getElementById('graph-context-menu');
            menu.className = '';
            menu.innerHTML = '';

            function resolveGraphSelectedState() {
                if (!graphSelectedState) return null;
                try {
                    const sc = Module._GetStateCount(editorEngine);
                    const needle = String(graphSelectedState).trim();
                    for (let si = 0; si < sc; si++) {
                        const nPtr = Module._GetStateName(editorEngine, si);
                        const n = Module.UTF8ToString(nPtr);
                        Module._FreeString(nPtr);
                        if (n === needle) return n;
                        // compare titles as fallback
                        try {
                            const tPtr = Module._GetStateTitle(editorEngine, allocateUTF8(n));
                            const t = Module.UTF8ToString(tPtr);
                            Module._FreeString(tPtr);
                            if (t === needle) return n;
                        } catch (e) {}
                    }
                } catch (e) {
                }
                return null;
            }

            const resolved = resolveGraphSelectedState();

            const options = [
                { icon: 'fas fa-eye', label: languages[currentLanguage]['View in States'] || 'View in States', action: () => { if (resolved) scopeToState(resolved); } },
                { icon: 'fas fa-expand', label: languages[currentLanguage]['View in Graph'] || 'View in Graph', action: () => { if (resolved) { currentGraphState = resolved; viewInGraph(resolved); } } },
                { icon: 'fas fa-star', label: languages[currentLanguage]['Set as Start'] || 'Set as Start', action: () => { if (resolved) setAsStart(resolved); } },
                { icon: 'fas fa-play', label: languages[currentLanguage]['Play State'] || 'Play State', action: () => { if (resolved) playState(resolved); } },
                { icon: 'fas fa-forward', label: languages[currentLanguage]['Force Play State'] || 'Force Play State', action: () => { if (resolved) forcePlayState(resolved); } },
                { icon: 'fas fa-trash', label: languages[currentLanguage]['Delete State'] || 'Delete State', action: () => { if (resolved) deleteState(resolved); } },
            ];

            const inner = document.createElement('div');
            inner.className = 'button-container';
            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.onclick = (e) => { e.stopPropagation(); menu.style.display = 'none'; opt.action(); };
                btn.innerHTML = `<i class="${opt.icon}" style="margin-right:8px;"></i> ${opt.label}`;
                if (!resolved) {
                    btn.setAttribute('disabled', 'disabled');
                    btn.classList.add('disabled');
                }
                inner.appendChild(btn);
            });
            menu.appendChild(inner);
            // Clamp graph context menu to viewport similarly to token menu
            menu.style.visibility = 'hidden';
            menu.style.display = 'block';
            requestAnimationFrame(() => {
                const rect = menu.getBoundingClientRect();
                const margin = 8;
                let left = x;
                let top = y;
                if (left + rect.width > window.innerWidth - margin) left = Math.max(margin, window.innerWidth - rect.width - margin);
                if (left < margin) left = margin;
                if (top + rect.height > window.innerHeight - margin) {
                    if (y - rect.height > margin) top = Math.max(margin, y - rect.height);
                    else top = Math.max(margin, window.innerHeight - rect.height - margin);
                }
                if (top < margin) top = margin;
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                menu.style.visibility = 'visible';
            });
        }

        function hideGraphContextMenu() {
            document.getElementById('graph-context-menu').style.display = 'none';
        }

        function viewStateFromGraph() {
                if (graphSelectedState) {
                    scopeToState(graphSelectedState);
                }
            hideGraphContextMenu();
        }

        async function deleteState(name) {
            if (!name) return;
            const message = (languages[currentLanguage]['confirmDeleteState'] || 'Delete state "{name}"?').replace('{name}', name);
            const ok = await showUniformConfirm({
                icon: 'fas fa-trash-alt',
                eyebrow: languages[currentLanguage]['states'] || 'States',
                title: languages[currentLanguage]['deleteState'] || 'Delete State',
                message,
                warning: languages[currentLanguage]['unsavedWarning'] || 'Unsaved editor changes will be lost.',
                primaryLabel: languages[currentLanguage]['delete'] || 'Delete',
                secondaryLabel: languages[currentLanguage]['cancel'] || 'Cancel',
                destructive: true
            });
            if (!ok) return;
            removeState(name);
            // Refresh graph view
            try {
                if (graphSelectedState === name) graphSelectedState = null;
                renderGraph();
            } catch (e) {}
        }

        function updateTokens() {
            stateTokens = [];
            const stateCount = Module._GetStateCount(editorEngine);
            for (let i = 0; i < stateCount; i++) {
                const namePtr = Module._GetStateName(editorEngine, i);
                stateTokens.push(Module.UTF8ToString(namePtr));
                Module._FreeString(namePtr);
            }
            variableTokens = [];
            const varCount = Module._GetVariableCount(editorEngine);
            for (let i = 0; i < varCount; i++) {
                const namePtr = Module._GetVariableName(editorEngine, i);
                variableTokens.push(Module.UTF8ToString(namePtr));
                Module._FreeString(namePtr);
            }
            tokens = [...stateTokens, ...variableTokens, ...functionTokens, ...operatorTokens, ...constantTokens];
            tokens = [...new Set(tokens)].sort();
            // Re-register Monarch provider when state list changes so state names highlight consistently
            try {
                if (window.monaco && typeof setNs2Monarch === 'function') setNs2Monarch(monarchDefinition);
            } catch (e) {}
        }

        function renderEditor() {
            const titlePtr = Module._GetStoryTitle(editorEngine);
            const currentTitle = Module.UTF8ToString(titlePtr);
            document.getElementById('story-title').value = currentTitle;
            // keep toolbar title in sync (if toolbar exists)
            const tb = document.getElementById('toolbar-story-title');
            if(tb) tb.textContent = currentTitle || (languages[currentLanguage]['untitled'] || 'Untitled');
            Module._FreeString(titlePtr);
            // keep header/window title synced to story title
            try { updateFileIndicator(); } catch (e) {}
            document.getElementById('story-title').onchange = function() {
                const prevPtr = Module._GetStoryTitle(editorEngine);
                const prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const newVal = this.value;
                Module._SetStoryTitle(editorEngine, allocateUTF8(newVal));
                // update toolbar copy
                try{ const el = document.getElementById('toolbar-story-title'); if(el) el.textContent = newVal || (languages[currentLanguage]['untitled'] || 'Untitled'); }catch(e){}
                try { updateFileIndicator(); } catch (e) {}
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus("Error setting story title: " + err, true);
                } else {
                    try {
                        const action = {
                            description: { title: `Set story title`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(newVal)}` },
                            undo: () => { try { Module._SetStoryTitle(editorEngine, allocateUTF8(prev)); renderEditor(); saveToLocalStorage(); } catch (e) {} },
                            redo: () => { try { Module._SetStoryTitle(editorEngine, allocateUTF8(newVal)); renderEditor(); saveToLocalStorage(); } catch (e) {} }
                        };
                        pushProgramAction(action);
                    } catch (e) {}
                }
            };

            const descPtr = Module._GetStoryDescription(editorEngine);
            const storyDescEl = document.getElementById('story-description');
            storyDescEl.value = Module.UTF8ToString(descPtr);
            Module._FreeString(descPtr);
            function autoResizeTextarea(el) {
                el.style.height = 'auto';
                el.style.height = (el.scrollHeight) + 'px';
            }
            // Apply immediately and on input to auto-save and expand
            // track last saved description to push a single history entry on blur
            let lastSavedDesc = storyDescEl.value;
            storyDescEl.addEventListener('input', function() {
                autoResizeTextarea(this);
                Module._SetStoryDescription(editorEngine, allocateUTF8(this.value));
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus("Error setting story description: " + err, true);
                }
            });
            storyDescEl.addEventListener('blur', function() {
                const prev = lastSavedDesc;
                const newVal = this.value;
                if (prev === newVal) return;
                try {
                    const action = {
                        description: { title: `Edit story description`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(newVal)}` },
                        undo: () => { try { Module._SetStoryDescription(editorEngine, allocateUTF8(prev)); renderEditor(); saveToLocalStorage(); } catch (e) {} },
                        redo: () => { try { Module._SetStoryDescription(editorEngine, allocateUTF8(newVal)); renderEditor(); saveToLocalStorage(); } catch (e) {} }
                    };
                    pushProgramAction(action);
                    lastSavedDesc = newVal;
                } catch (e) {}
            });
            // initial resize
            setTimeout(() => autoResizeTextarea(storyDescEl), 0);
            const startPtr = Module._GetStartState(editorEngine);
            document.getElementById('start-state').value = Module.UTF8ToString(startPtr);
            Module._FreeString(startPtr);
            document.getElementById('start-state').onchange = function() {
                const prevPtr = Module._GetStartState(editorEngine);
                const prev = Module.UTF8ToString(prevPtr);
                Module._FreeString(prevPtr);
                const newVal = this.value;
                Module._SetStartState(editorEngine, allocateUTF8(newVal));
                saveToLocalStorage();
                const err = getLastError(editorEngine);
                if (err) {
                    setStatus("Error setting start state: " + err, true);
                } else {
                    try {
                        const action = {
                            description: { title: `Set start state`, detail: `${summarizeForHistory(prev)} -> ${summarizeForHistory(newVal)}` },
                            undo: () => { try { Module._SetStartState(editorEngine, allocateUTF8(prev)); renderEditor(); saveToLocalStorage(); } catch (e) {} },
                            redo: () => { try { Module._SetStartState(editorEngine, allocateUTF8(newVal)); renderEditor(); saveToLocalStorage(); } catch (e) {} }
                        };
                        pushProgramAction(action);
                        // Contextual update: if this state's choices panel is visible, update the specific row
                        try {
                            const panelTbody = document.getElementById(`choices-${name}`);
                            if (panelTbody && panelTbody.rows && panelTbody.rows[i]) {
                                const row = panelTbody.rows[i];
                                if (field === 'text') {
                                    const inp = row.cells[0].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'cond') {
                                    const inp = row.cells[1].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'target') {
                                    const inp = row.cells[2].querySelector('.target-group input'); if (inp) inp.value = value;
                                } else if (field === 'effect') {
                                    const inp = row.cells[3].querySelector('input'); if (inp) inp.value = value;
                                } else if (field === 'hide') {
                                    const cb = row.cells[4] && row.cells[4].querySelector('input[type="checkbox"]'); if (cb) cb.checked = !!value;
                                }
                            }
                        } catch (e) {}
                    } catch (e) {}
                }
            };
            updateTokens();
            populateStateDatalist();
            populateTokenDatalist();
            renderVariables();
            renderStates();
            document.getElementById('editor').style.display = 'block';
            setupContextMenu();
            setupKeyboardShortcuts();
            setupStatusWindow();
            setStatus("Editor ready");
        }

        function openHelp(page) {
            try {
                if (!page) return;
                try {
                    const dd = document.getElementById('help-dropdown');
                    if (dd) dd.style.display = 'none';
                } catch (e) {}
                if (typeof currentTab === 'string' && currentTab !== 'help') {
                    __lastNonHelpTab = currentTab;
                }
                __currentHelpPage = page;
                const iframe = document.getElementById('help-iframe');
                if (iframe) {
                    // Ensure embedded pages show their .tab-content sections
                    const activateContent = () => {
                        try {
                            const doc = iframe.contentDocument || (iframe.contentWindow && iframe.contentWindow.document);
                            if (!doc) return;
                            doc.querySelectorAll('.tab-content').forEach(el => {
                                try { el.classList.add('active'); } catch (e) {}
                            });
                            // Hide page-local header/back links and inline utility buttons; we surface controls in the main toolbar
                            try { doc.querySelectorAll('.header, .back-link').forEach(el => el && (el.style.display = 'none')); } catch (e) {}
                            try {
                                const guide = doc.getElementById('guide-content');
                                if (guide) {
                                    const prev = guide.previousElementSibling;
                                    if (prev && prev.querySelector && prev.querySelector('button')) prev.style.display = 'none';
                                }
                            } catch (e) {}
                            // Force scrolling: override global page CSS from style.css (body {height:100vh})
                            try {
                                const style = doc.createElement('style');
                                style.textContent = `html, body { height: auto !important; min-height: 0 !important; overflow-y: auto !important; }
                                                      .tab-content { display: block !important; opacity: 1 !important; height: auto !important; overflow: visible !important; }`;
                                doc.head && doc.head.appendChild(style);
                            } catch (e) {}
                        } catch (e) {}
                    };
                    try { iframe.removeEventListener('load', activateContent); } catch (e) {}
                    try { iframe.addEventListener('load', activateContent); } catch (e) {}
                    iframe.src = page + '.html';
                }
                openTab('help');
            } catch (e) { console.warn('openHelp failed', e); }
        }

        function closeHelp() {
            try {
                const iframe = document.getElementById('help-iframe');
                if (iframe) iframe.src = 'about:blank';
            } catch (e) {}
            try { openTab(__lastNonHelpTab || 'metadata'); } catch (e) {}
        }

        // Copy utilities for embedded help pages
        function copyHelpRaw() {
            try {
                const iframe = document.getElementById('help-iframe');
                if (!iframe) return;
                const doc = iframe.contentDocument || (iframe.contentWindow && iframe.contentWindow.document);
                if (!doc) return;
                const node = doc.getElementById('guide-content') || doc.body;
                const text = (node && (node.innerText || node.textContent)) || '';
                navigator.clipboard.writeText(text.trim());
            } catch (e) { console.warn('copyHelpRaw failed', e); }
        }

        function __basicHtmlToMarkdown(node, level = 0) {
            if (!node) return '';
            if (node.nodeType === 3) return node.textContent;
            if (node.nodeType !== 1) return '';
            const tag = node.tagName.toLowerCase();
            const joinKids = () => Array.from(node.childNodes).map(ch => __basicHtmlToMarkdown(ch, level)).join('');
            switch (tag) {
                case 'h1': return '# ' + joinKids().trim() + '\n\n';
                case 'h2': return '## ' + joinKids().trim() + '\n\n';
                case 'h3': return '### ' + joinKids().trim() + '\n\n';
                case 'p':  return joinKids().trim() + '\n\n';
                case 'strong': return '**' + joinKids() + '**';
                case 'em': return '*' + joinKids() + '*';
                case 'code': return '`' + joinKids() + '`';
                case 'pre': return '```\n' + (node.textContent || '') + '\n```\n\n';
                case 'ul': {
                    const items = Array.from(node.querySelectorAll(':scope > li')).map(li => __basicHtmlToMarkdown(li, level));
                    return items.join('') + '\n';
                }
                case 'li': {
                    const parts = [];
                    const subUls = [];
                    node.childNodes.forEach(child => {
                        if (child.nodeType === 1 && child.tagName && child.tagName.toLowerCase() === 'ul') {
                            subUls.push(__basicHtmlToMarkdown(child, level + 1));
                        } else {
                            parts.push(__basicHtmlToMarkdown(child, level).trim());
                        }
                    });
                    const indent = '  '.repeat(level);
                    return indent + '- ' + parts.join(' ') + '\n' + (subUls.length ? subUls.join('\n') : '');
                }
                default: return joinKids();
            }
        }

        function copyHelpMarkdown() {
            try {
                const iframe = document.getElementById('help-iframe');
                if (!iframe) return;
                const win = iframe.contentWindow;
                const doc = iframe.contentDocument || (win && win.document);
                if (!doc) return;
                const node = doc.getElementById('guide-content') || doc.body;
                if (!node) return;
                let md = '';
                if (win && typeof win.htmlToMarkdown === 'function') {
                    try { md = win.htmlToMarkdown(node); } catch (e) { md = __basicHtmlToMarkdown(node); }
                } else {
                    md = __basicHtmlToMarkdown(node);
                }
                navigator.clipboard.writeText((md || '').trim());
            } catch (e) { console.warn('copyHelpMarkdown failed', e); }
        }

        function updateGlobalToolbar(tabName) {
            const toolbar = document.getElementById('global-toolbar');
            toolbar.innerHTML = '';
            toolbar.style.display = 'flex';

            function makeBtn(html, title, onclick, extraClass) {
                const b = document.createElement('button');
                b.className = 'icon-button' + (extraClass ? ' ' + extraClass : '');
                if (onclick) b.onclick = onclick;
                b.title = title || '';
                b.innerHTML = html;
                return b;
            }

            function addGroupLabel(group, labelText) {
                const label = document.createElement('div');
                label.className = 'group-label';
                label.textContent = labelText;
                group.appendChild(label);
            }

            // Help mode: minimal toolbar with back/close and page actions
            if (tabName === 'help') {
                const helpGroup = document.createElement('div');
                helpGroup.className = 'toolbar-group group-help';
                addGroupLabel(helpGroup, 'HELP');

                const titleText = (__helpTitles[__currentHelpPage] || 'Help');
                const backBtn = makeBtn('<i class="fas fa-arrow-left"></i>', 'Back', () => closeHelp());
                helpGroup.appendChild(backBtn);

                // Page-specific actions (Copy Raw / Copy Markdown), shown when content exists
                const copyRawBtn = makeBtn('<i class="fas fa-copy"></i>', 'Copy Raw', () => { try { copyHelpRaw(); } catch (e) {} });
                helpGroup.appendChild(copyRawBtn);
                const copyMdBtn = makeBtn('<i class="fas fa-file-alt"></i>', 'Copy as Markdown', () => { try { copyHelpMarkdown(); } catch (e) {} });
                helpGroup.appendChild(copyMdBtn);

                // Title label (non-clickable)
                const titleEl = document.createElement('div');
                titleEl.className = 'group-label';
                titleEl.textContent = titleText;
                helpGroup.appendChild(titleEl);

                toolbar.appendChild(helpGroup);
                return; // Skip normal toolbar when viewing help
            }

            // FILE group (global)
            const fileGroup = document.createElement('div'); fileGroup.className = 'toolbar-group group-file'; fileGroup.id = 'toolbar-file-group';
            // (toolbar story title moved to header menubar for layout: logo -> editor -> | -> story -> buttons)

            const newBtn = makeBtn('<i class="fas fa-file"></i>', languages[currentLanguage]['newStory'] || 'New Story', () => { try { window.newStory(); } catch(e) { try { newStory(); } catch(ee) {} } });
            newBtn.dataset.action = 'file-new';
            fileGroup.appendChild(newBtn);

            const openBtn = makeBtn('<i class="fas fa-folder-open"></i>', languages[currentLanguage]['loadStory'] || 'Load Story', () => { try { window.openFile(); } catch(e) { try { openFile(); } catch(ee) { try { const inp = document.getElementById('file-input'); if (inp) inp.click(); } catch(eee) {} } } });
            openBtn.dataset.action = 'file-open';
            fileGroup.appendChild(openBtn);

            if (window.electronAPI && typeof window.electronAPI.getRecentStories === 'function') {
                const recentBtn = makeBtn('<i class="fas fa-history"></i>', languages[currentLanguage]['recentStories'] || 'Recent Stories', (ev) => {
                    ev.preventDefault();
                    toggleRecentDropdown(recentBtn);
                });
                recentBtn.dataset.action = 'file-recent';
                fileGroup.appendChild(recentBtn);
            }

            const saveBtn = makeBtn('<i class="fas fa-save"></i>', languages[currentLanguage]['saveStory'] || 'Save Story', () => { try { window.saveFile(); } catch(e) { try { saveFile(); } catch(ee) {} } });
            saveBtn.dataset.action = 'file-save';
            fileGroup.appendChild(saveBtn);

            const saveAsBtn = makeBtn('<i class="fas fa-file-export"></i>', languages[currentLanguage]['saveStoryAs'] || 'Save Story As‚Ä¶', () => {
                try { window.saveFileAs(); }
                catch (err) { try { saveFileAs(); } catch (ee) {} }
            });
            saveAsBtn.dataset.action = 'file-save-as';
            fileGroup.appendChild(saveAsBtn);
            addGroupLabel(fileGroup, 'FILE');
            toolbar.appendChild(fileGroup);

            // Create a container for contextual groups (states, variables, graph)
            const contextContainer = document.createElement('div'); contextContainer.className = 'toolbar-context-container';
            // Append file group first, then contextual groups, then play/tools to enforce ordering
            toolbar.appendChild(contextContainer);

            // PLAY group (global) - Play + Restart send messages to reader iframe
            const playGroup = document.createElement('div'); playGroup.className = 'toolbar-group';
            const playBtn = makeBtn('<i class="fas fa-play"></i>', languages[currentLanguage]['Play Current Story'] || 'Play Current Story', () => {
                try {
                    const iframe = document.getElementById('play-iframe');
                    if (iframe && iframe.contentWindow) {
                        const content = generateNS2Content();
                        iframe.contentWindow.postMessage({ type: 'ns2-play', content }, '*');
                    }
                } catch(e) {}
                openTab('play');
            });
            playBtn.dataset.action = 'play-start';
            playGroup.appendChild(playBtn);
            const restartBtn = makeBtn('<i class="fas fa-redo"></i>', languages[currentLanguage]['Restart'] || 'Restart', () => {
                try {
                    const iframe = document.getElementById('play-iframe');
                    if (iframe && iframe.contentWindow) {
                        iframe.contentWindow.postMessage({ type: 'ns2-restart' }, '*');
                    }
                } catch(e) {}
                openTab('play');
            });
            restartBtn.dataset.action = 'play-restart';
            playGroup.appendChild(restartBtn);
            addGroupLabel(playGroup, 'PLAY');
            

            // Tab-specific: VARIABLES group (only on variables tab)
            if (tabName === 'variables') {
                const variablesGroup = document.createElement('div'); variablesGroup.className = 'toolbar-group toolbar-context';
                const addVarBtn = makeBtn('<i class="fas fa-plus"></i>', languages[currentLanguage]['addVariable'] || 'Add Variable', addVariable);
                addVarBtn.dataset.action = 'var-add';
                variablesGroup.appendChild(addVarBtn);
                addGroupLabel(variablesGroup, 'VARIABLES');
                contextContainer.appendChild(variablesGroup);
            }

            // Tab-specific: STATES group (only on states tab)
            if (tabName === 'states') {
                const statesGroup = document.createElement('div'); statesGroup.className = 'toolbar-group toolbar-context';
                const addStateBtn = makeBtn('<i class="fas fa-plus"></i>', languages[currentLanguage]['addState'] || 'Add State', addState);
                addStateBtn.dataset.action = 'state-add';
                statesGroup.appendChild(addStateBtn);
                const deleteBtn = makeBtn('<i class="fas fa-trash"></i>', languages[currentLanguage]['Delete State'] || 'Delete State', () => { if (selectedState) removeState(selectedState); });
                deleteBtn.dataset.action = 'state-delete';
                statesGroup.appendChild(deleteBtn);
                const startBtn = makeBtn('<i class="fas fa-flag"></i>', languages[currentLanguage]['Set as Start'] || 'Set as Start', () => { if (selectedState) setAsStart(selectedState); });
                startBtn.dataset.action = 'state-setstart';
                statesGroup.appendChild(startBtn);
                const jumpBtn = makeBtn('<i class="fas fa-play"></i>', languages[currentLanguage]['Jump to State'] || 'Jump to State', () => { if (selectedState) { jumpToState(selectedState); openTab('play'); } });
                jumpBtn.dataset.action = 'state-jump';
                try {
                    if (typeof playEngine !== 'undefined' && playEngine && selectedState) {
                        const sPtr = allocateUTF8(selectedState);
                        const canVisit = Module._CanVisitState(playEngine, sPtr);
                        Module._free(sPtr);
                        if (!canVisit) {
                            jumpBtn.setAttribute('disabled', 'disabled');
                            jumpBtn.classList.add('disabled');
                            jumpBtn.title = languages[currentLanguage]['cannotVisitState'] || 'State not visitable in current play session';
                        }
                    } else if (!selectedState) {
                        jumpBtn.setAttribute('disabled', 'disabled');
                        jumpBtn.classList.add('disabled');
                    }
                } catch (e) {
                    // ignore if API not present
                }
                statesGroup.appendChild(jumpBtn);
                const forceBtn = makeBtn('<i class="fas fa-forward"></i>', languages[currentLanguage]['Force Jump'] || 'Force Jump', () => { if (selectedState) { forceJumpToState(selectedState); openTab('play'); } }, 'force-visit');
                forceBtn.dataset.action = 'state-forcejump';
                statesGroup.appendChild(forceBtn);
                const graphBtn = makeBtn('<i class="fas fa-project-diagram"></i>', languages[currentLanguage]['View in Graph'] || 'View in Graph', () => { if (selectedState) viewInGraph(selectedState); });
                graphBtn.dataset.action = 'state-viewgraph';
                statesGroup.appendChild(graphBtn);
                addGroupLabel(statesGroup, 'STATES');
                contextContainer.appendChild(statesGroup);
            }

            // Tab-specific: GRAPH group (only on graph tab)
            if (tabName === 'graph') {
                const graphGroup = document.createElement('div'); graphGroup.className = 'toolbar-group toolbar-context';
                const resetGraphBtn = makeBtn('<i class="fas fa-sync"></i>', languages[currentLanguage]['Reset Graph'] || 'Reset Graph', resetGraph);
                resetGraphBtn.dataset.action = 'graph-reset';
                graphGroup.appendChild(resetGraphBtn);
                const zoomInBtn = makeBtn('<i class="fas fa-search-plus"></i>', languages[currentLanguage]['Zoom In'] || 'Zoom In', zoomIn);
                zoomInBtn.dataset.action = 'graph-zoomin';
                graphGroup.appendChild(zoomInBtn);
                const zoomOutBtn = makeBtn('<i class="fas fa-search-minus"></i>', languages[currentLanguage]['Zoom Out'] || 'Zoom Out', zoomOut);
                zoomOutBtn.dataset.action = 'graph-zoomout';
                graphGroup.appendChild(zoomOutBtn);
                const centerBtn = makeBtn('<i class="fas fa-crosshairs"></i>', languages[currentLanguage]['Center Graph'] || 'Center Graph', centerGraph);
                centerBtn.dataset.action = 'graph-center';
                graphGroup.appendChild(centerBtn);
                addGroupLabel(graphGroup, 'GRAPH');
                contextContainer.appendChild(graphGroup);
            }

            // TOOLS group (language + help + view toggles merged)
            const toolsGroup = document.createElement('div'); toolsGroup.className = 'toolbar-group';
            // Undo / Redo (program-level) - do not interfere with Monaco's own undo
            const undoBtn = makeBtn('<i class="fas fa-undo"></i>', 'Undo', () => { undoProgram(); });
            undoBtn.dataset.action = 'undo-btn';
            try { if (historyIndex === 0) { undoBtn.setAttribute('disabled', 'disabled'); undoBtn.classList.add('disabled'); } } catch (e) {}
            toolsGroup.appendChild(undoBtn);
            const redoBtn = makeBtn('<i class="fas fa-redo"></i>', 'Redo', () => { redoProgram(); });
            redoBtn.dataset.action = 'redo-btn';
            try { if (historyIndex >= programHistory.length) { redoBtn.setAttribute('disabled', 'disabled'); redoBtn.classList.add('disabled'); } } catch (e) {}
            toolsGroup.appendChild(redoBtn);
            // small caret button to open the undo/redo history dropdown (placed to the right of redo)
            const undoMenuBtn = makeBtn('<i class="fas fa-caret-down"></i>', 'Undo/Redo History', null, 'small-caret');
            undoMenuBtn.onclick = () => { toggleDropdown('undo-dropdown', undoMenuBtn); };
            toolsGroup.appendChild(undoMenuBtn);
            // Toggle status button (moved from VIEW group into TOOLS)
            const toggleStatusBtn = makeBtn('<i class="fas fa-window-maximize"></i>', languages[currentLanguage]['toggleStatus'] || 'Toggle Status Window', null);
            toggleStatusBtn.onclick = () => { toggleDropdown('status-window', toggleStatusBtn); };
            toolsGroup.appendChild(toggleStatusBtn);
            const langBtn = makeBtn('<i class="fas fa-globe"></i>', languages[currentLanguage]['language'] || 'Language', null);
            langBtn.onclick = () => { toggleDropdown('language-dropdown', langBtn); };
            toolsGroup.appendChild(langBtn);
            const helpBtn = makeBtn('<i class="fas fa-question-circle"></i>', languages[currentLanguage]['help'] || 'Help', null);
            helpBtn.onclick = () => { toggleDropdown('help-dropdown', helpBtn); };
            toolsGroup.appendChild(helpBtn);
            addGroupLabel(toolsGroup, 'TOOLS');
            // Ensure playGroup is inserted before tools so the final order is: FILE -> CONTEXT -> PLAY -> TOOLS
            try { if (typeof playGroup !== 'undefined') toolbar.appendChild(playGroup); } catch (e) {}
            toolbar.appendChild(toolsGroup);

            toolbar.style.pointerEvents = 'auto';
            try { updateToolbarUndoButtons(); } catch (e) {}
            // Ensure toolbar overflow is arranged (move groups into overflow if they don't fit)
            try { arrangeToolbarOverflow(); } catch (e) {}
            // Apply visible shortcut hints on buttons
            try { applyShortcutHints(); } catch(e) {}
        }

        // Arrange toolbar groups into an overflow menu when they don't fit
        function arrangeToolbarOverflow() {
            const toolbar = document.getElementById('global-toolbar');
            if (!toolbar) return;
            // create overflow holder if missing
            let overflow = toolbar.querySelector('.toolbar-overflow');
            if (!overflow) {
                overflow = document.createElement('div');
                overflow.className = 'toolbar-overflow toolbar-group';
                overflow.id = 'toolbar-overflow';
                const overflowBtn = document.createElement('button');
                overflowBtn.className = 'icon-button overflow-btn';
                overflowBtn.innerHTML = '<i class="fas fa-ellipsis-h"></i>';
                overflowBtn.title = 'More';
                overflowBtn.onclick = (e) => {
                    const menu = overflow.querySelector('.overflow-menu');
                    if (!menu) return;
                    menu.style.display = (menu.style.display === 'block') ? '' : 'block';
                };
                const menu = document.createElement('div');
                menu.className = 'overflow-menu';
                overflow.appendChild(overflowBtn);
                overflow.appendChild(menu);
                toolbar.appendChild(overflow);
            }
            const menu = overflow.querySelector('.overflow-menu');
            // move any previously overflowed groups back to toolbar before measuring
            while (menu && menu.firstChild) {
                const g = menu.firstChild;
                toolbar.insertBefore(g, overflow);
            }

            // compute available space (reserve overflow button width)
            const toolbarWidth = toolbar.clientWidth;
            const overflowBtnWidth = overflow.offsetWidth || 40;
            let used = 0;
            const children = Array.from(toolbar.children).filter(c => c !== overflow);
            // measure from left to right, move groups that overflow into the overflow menu
            for (const ch of children) {
                // ensure element is visible for measurement
                ch.style.display = '';
                const w = ch.offsetWidth;
                if (used + w + overflowBtnWidth > toolbarWidth) {
                    // move this and all following into overflow
                    const following = Array.from(toolbar.children).filter(c => c !== overflow).slice(children.indexOf(ch));
                    following.forEach(f => { try { menu.appendChild(f); } catch (e) {} });
                    break;
                }
                used += w;
            }
            // hide overflow if empty
            if (menu && menu.children.length === 0) overflow.style.display = 'none'; else overflow.style.display = '';
        }

        // Close overflow menus on resize or click outside
        window.addEventListener('resize', () => { try { arrangeToolbarOverflow(); } catch (e) {} });
        document.addEventListener('click', (e) => {
            const of = document.getElementById('toolbar-overflow');
            if (!of) return;
            const menu = of.querySelector('.overflow-menu');
            if (!menu) return;
            if (!of.contains(e.target)) menu.style.display = '';
        });

        // Toggle an existing dropdown container (positions it under the anchor)
        function toggleDropdown(dropdownId, anchorEl) {
            const dd = document.getElementById(dropdownId);
            if (!dd || !anchorEl) return;
            if (dd.dataset.visible === '1') {
                dd.style.display = '';
                dd.dataset.visible = '';
                return;
            }
            // Close other open dropdowns first
            document.querySelectorAll('.dropdown-menu').forEach(d => {
                if (d.id !== dropdownId && d.dataset.visible === '1') {
                    d.style.display = '';
                    d.dataset.visible = '';
                }
            });

            // If this is the undo dropdown, refresh its contents
            try { if (dropdownId === 'undo-dropdown') updateUndoDropdown(); } catch (e) {}
            
            // Reset dropdown styles before measuring
            dd.style.position = 'fixed';
            dd.style.left = '0';
            dd.style.top = '0';
            dd.style.display = 'block';
            dd.style.opacity = '0';
            dd.style.transform = 'translateY(-8px) scale(0.98)';
            dd.style.zIndex = 110;
            dd.style.visibility = 'hidden';
            dd.dataset.visible = '1';

            // Animate into place and keep dropdown within viewport bounds.
            requestAnimationFrame(() => {
                // Get fresh button position
                const rect = anchorEl.getBoundingClientRect();
                
                // Set minimum width and measure dropdown
                dd.style.minWidth = Math.max(rect.width, 200) + 'px';
                const b = dd.getBoundingClientRect();
                
                // Calculate position - align left edge, or right if would go off right
                let left = rect.left;
                if (left + b.width > window.innerWidth - 8) {
                    left = rect.right - b.width;
                }
                left = Math.max(8, left);
                
                // Adjust if dropdown would go off bottom edge
                if (top + b.height > window.innerHeight - 8) {
                    top = Math.max(8, rect.top - b.height - 4);
                }
                
                // Apply position and show
                dd.style.left = left + 'px';
                dd.style.top = top + 'px';
                dd.style.visibility = 'visible';
                dd.style.transition = 'opacity 160ms ease, transform 160ms ease';
                dd.style.opacity = '1';
                dd.style.transform = 'translateY(0) scale(1)';
                dd.style.background = 'linear-gradient(0deg, rgba(17,17,17,0.96) 0%, rgba(30,30,30,0.96) 100%)';
                dd.style.backdropFilter = 'blur(8px)';
                dd.style.boxShadow = '0 8px 32px rgba(0,0,0,0.3)';
                dd.style.border = '1px solid rgba(60,60,60,0.8)';
            });

            function outsideClick(e) {
                if (!dd.contains(e.target) && !anchorEl.contains(e.target)) {
                    dd.style.display = '';
                    dd.dataset.visible = '';
                    document.removeEventListener('click', outsideClick);
                }
            }
            setTimeout(() => document.addEventListener('click', outsideClick), 0);
        }

        // Override dropdown positioning with standardized VS Code-like behavior
        function toggleDropdown(dropdownId, anchorEl) {
            const dd = document.getElementById(dropdownId);
            if (!dd || !anchorEl) return;
            if (dd.dataset.visible === '1') { dd.style.display=''; dd.dataset.visible=''; return; }
            document.querySelectorAll('.dropdown-menu').forEach(other => {
                if (other !== dd && other.dataset.visible === '1') { other.style.display=''; other.dataset.visible=''; }
            });
            try { if (dropdownId === 'undo-dropdown') updateUndoDropdown(); } catch(_) {}
            dd.style.position='fixed'; dd.style.left='0px'; dd.style.top='0px'; dd.style.display='block'; dd.style.opacity='0'; dd.style.transform='translateY(-4px)'; dd.style.visibility='hidden'; dd.style.zIndex=110; dd.dataset.visible='1';
            requestAnimationFrame(() => {
                const rect = anchorEl.getBoundingClientRect();
                if (!dd.classList.contains('keep-width')) dd.style.minWidth = rect.width + 'px';
                const b = dd.getBoundingClientRect();
                let left = rect.left; let top = rect.bottom + 4;
                if (left + b.width > window.innerWidth - 8) left = window.innerWidth - b.width - 8; if (left < 8) left = 8;
                if (top + b.height > window.innerHeight - 8) top = rect.top - b.height - 4; if (top < 8) top = 8;
                dd.style.left = left + 'px'; dd.style.top = top + 'px'; dd.style.visibility='visible'; dd.style.transition='opacity 120ms ease, transform 120ms ease'; dd.style.opacity='1'; dd.style.transform='translateY(0)';
            });
            const outsideClick = (e) => { if (!dd.contains(e.target) && !anchorEl.contains(e.target)) { dd.style.display=''; dd.dataset.visible=''; document.removeEventListener('mousedown', outsideClick); } };
            setTimeout(() => document.addEventListener('mousedown', outsideClick), 0);
        }

        function setupStatusWindow() {
            // Status window is now a dropdown anchored to the toolbar; no dragging needed.
            const windowElement = document.getElementById('status-window');
            if (windowElement) {
                windowElement.style.display = '';
                windowElement.dataset.visible = '';
            }
            const copyBtn = document.getElementById('status-copy');
                if (!dd || !anchorEl) return;

                // If already visible: close and return
                if (dd.dataset.visible === '1') {
                    dd.style.display = '';
                    dd.dataset.visible = '';
                    return;
                }

                // Close any other open dropdowns
                document.querySelectorAll('.dropdown-menu').forEach(d => {
                    if (d !== dd && d.dataset.visible === '1') {
                        d.style.display = '';
                        d.dataset.visible = '';
                    }
                });

                // Refresh dynamic content for specific menus
                try { if (dropdownId === 'undo-dropdown') updateUndoDropdown(); } catch (_) {}

                // Prepare for measurement (fixed positioning like VS Code)
                dd.style.position = 'fixed';
                dd.style.left = '0px';
                dd.style.top = '0px';
                dd.style.display = 'block';
                dd.style.opacity = '0';
                dd.style.transform = 'translateY(-4px)';
                dd.style.zIndex = 110;
                dd.style.visibility = 'hidden';
                dd.dataset.visible = '1';

                requestAnimationFrame(() => {
                    const rect = anchorEl.getBoundingClientRect();

                    // Standard VS Code-like alignment: top-left corner below the button
                    // Minimum width equals button width (unless menu already wider from CSS)
                    if (!dd.style.width && !dd.classList.contains('keep-width')) {
                        dd.style.minWidth = rect.width + 'px';
                    }

                    const b = dd.getBoundingClientRect();
                    let left = rect.left;
                    let top = rect.bottom + 4; // small vertical gap

                    // Clamp horizontally: ensure fully visible
                    if (left + b.width > window.innerWidth - 8) {
                        left = window.innerWidth - b.width - 8; // shift left to fit
                    }
                    if (left < 8) left = 8;

                    // If not enough space below, open above the button
                    if (top + b.height > window.innerHeight - 8) {
                        top = rect.top - b.height - 4; // open upward
                    }
                    if (top < 8) top = 8; // clamp top

                    // Apply final position & animate in
                    dd.style.left = left + 'px';
                    dd.style.top = top + 'px';
                    dd.style.visibility = 'visible';
                    dd.style.transition = 'opacity 120ms ease, transform 120ms ease';
                    dd.style.opacity = '1';
                    dd.style.transform = 'translateY(0)';
                });
                document.onmousemove = null;
            }

        (function initGenericConfirmModal(){
            if (window.__ns2ConfirmModalInitialized) return;
            const root = document.getElementById('ns2-generic-modal');
            if (!root) { window.__ns2ConfirmModal = null; return; }
            const iconEl = root.querySelector('[data-modal-icon]');
            const eyebrowEl = root.querySelector('[data-modal-eyebrow]');
            const titleEl = root.querySelector('[data-modal-title]');
            const messageEl = root.querySelector('[data-modal-message]');
            const warningEl = root.querySelector('[data-modal-warning]');
            const warningTextEl = root.querySelector('[data-modal-warning-text]');
            const metaEl = root.querySelector('[data-modal-meta]');
            const primaryBtn = root.querySelector('[data-modal-primary]');
            const primaryLabelEl = root.querySelector('[data-modal-primary-label]');
            const secondaryBtn = root.querySelector('[data-modal-secondary]');
            const secondaryLabelEl = root.querySelector('[data-modal-secondary-label]');
            const actionsEl = root.querySelector('[data-modal-actions]') || root.querySelector('.ns2-modal__actions');
            const closeTargets = root.querySelectorAll('[data-modal-close]');
            const backdrop = root.querySelector('.ns2-modal__backdrop');
            let resolver = null;
            let previousActive = null;
            let extraButtons = [];
            let primaryReturnValue = true;
            let secondaryReturnValue = false;

            const cleanupExtraButtons = () => {
                if (!extraButtons || extraButtons.length === 0) return;
                extraButtons.forEach((btn) => {
                    try { btn.remove(); } catch (e) {}
                });
                extraButtons = [];
            };

            const hide = () => {
                cleanupExtraButtons();
                root.classList.remove('is-visible');
                root.setAttribute('aria-hidden', 'true');
                root.removeEventListener('keydown', handleKeyDown, true);
                if (previousActive && typeof previousActive.focus === 'function') {
                    try { previousActive.focus(); } catch (e) {}
                }
            };

            const finish = (result) => {
                if (!resolver) return;
                cleanupExtraButtons();
                const resolveFn = resolver;
                resolver = null;
                hide();
                resolveFn(result);
            };

            const handleKeyDown = (ev) => {
                if (ev.key === 'Escape') {
                    ev.preventDefault();
                    finish(false);
                }
            };

            const applyMeta = (items) => {
                if (!metaEl) return;
                metaEl.innerHTML = '';
                if (!Array.isArray(items) || items.length === 0) {
                    metaEl.style.display = 'none';
                    return;
                }
                items.forEach(item => {
                    const row = document.createElement('div');
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'label';
                    labelSpan.textContent = item && item.label ? item.label : '';
                    const valueSpan = document.createElement('span');
                    valueSpan.textContent = item && item.value ? item.value : '';
                    row.appendChild(labelSpan);
                    row.appendChild(valueSpan);
                    metaEl.appendChild(row);
                });
                metaEl.style.display = '';
            };

            const open = (config = {}) => {
                const {
                    icon = 'fas fa-wave-square',
                    eyebrow = languages[currentLanguage]?.confirmDialogEyebrow || 'Confirm',
                    title = languages[currentLanguage]?.confirmDialogTitle || 'Please confirm',
                    message = '',
                    warning = '',
                    meta = null,
                    primaryLabel = languages[currentLanguage]?.confirmDialogPrimary || 'Continue',
                    secondaryLabel = languages[currentLanguage]?.confirmDialogSecondary || 'Cancel',
                    primaryValue = true,
                    secondaryValue = false,
                    hideSecondary = false,
                    destructive = false,
                    extraActions = []
                } = config || {};

                primaryReturnValue = (typeof primaryValue === 'undefined') ? true : primaryValue;
                secondaryReturnValue = (typeof secondaryValue === 'undefined') ? false : secondaryValue;

                cleanupExtraButtons();

                if (iconEl) iconEl.className = icon || 'fas fa-wave-square';
                if (eyebrowEl) eyebrowEl.textContent = eyebrow;
                if (titleEl) titleEl.textContent = title;
                if (messageEl) messageEl.textContent = message || '';

                if (warningEl) {
                    if (warning) {
                        warningEl.style.display = 'flex';
                        if (warningTextEl) warningTextEl.textContent = warning;
                    } else {
                        warningEl.style.display = 'none';
                        if (warningTextEl) warningTextEl.textContent = '';
                    }
                }

                applyMeta(meta);

                if (primaryBtn) {
                    primaryBtn.classList.toggle('danger', !!destructive);
                }
                if (primaryLabelEl) primaryLabelEl.textContent = primaryLabel || '';

                if (secondaryBtn) {
                    const shouldHide = hideSecondary || !secondaryLabel;
                    secondaryBtn.style.display = shouldHide ? 'none' : '';
                    if (secondaryLabelEl) secondaryLabelEl.textContent = secondaryLabel || '';
                }

                if (actionsEl && Array.isArray(extraActions) && extraActions.length > 0) {
                    extraActions.forEach(action => {
                        const btn = document.createElement('button');
                        const classes = [];
                        if (action.classes && typeof action.classes === 'string') {
                            classes.push(action.classes);
                        } else {
                            const variant = action.variant || 'ghost';
                            if (variant === 'primary') {
                                classes.push('primary');
                            } else {
                                classes.push('ghost');
                            }
                            if (variant === 'danger') {
                                classes.push('danger');
                            }
                        }
                        btn.className = classes.join(' ').trim() || 'ghost';
                        btn.type = 'button';
                        if (action.title) btn.title = action.title;
                        const iconName = action.icon || '';
                        if (iconName) {
                            const iconNode = document.createElement('i');
                            iconNode.className = iconName;
                            btn.appendChild(iconNode);
                        }
                        const labelSpan = document.createElement('span');
                        labelSpan.textContent = action.label || '';
                        btn.appendChild(labelSpan);
                        const actionValue = (typeof action.value === 'undefined') ? true : action.value;
                        btn.addEventListener('click', () => finish(actionValue));
                        try {
                            actionsEl.insertBefore(btn, (secondaryBtn && secondaryBtn.parentNode === actionsEl) ? secondaryBtn : null);
                        } catch (e) {
                            actionsEl.appendChild(btn);
                        }
                        extraButtons.push(btn);
                    });
                }

                root.classList.add('is-visible');
                root.setAttribute('aria-hidden', 'false');
                previousActive = document.activeElement;
                root.addEventListener('keydown', handleKeyDown, true);

                return new Promise((resolve) => {
                    resolver = resolve;
                    setTimeout(() => {
                        try {
                            (primaryBtn || root).focus();
                        } catch (e) {}
                    }, 20);
                });
            };

            primaryBtn?.addEventListener('click', () => finish(primaryReturnValue));
            secondaryBtn?.addEventListener('click', () => finish(secondaryReturnValue));
            closeTargets.forEach(btn => btn.addEventListener('click', (ev) => { ev.preventDefault(); finish(false); }));
            backdrop?.addEventListener('click', (ev) => { ev.preventDefault(); finish(false); });

            window.__ns2ConfirmModal = { open, close: () => finish(false) };
            window.__ns2ConfirmModalInitialized = true;
        })();

        // Toolbar mouse tracking removed ‚Äî toolbar is now static in the header next to Language/Help

        (async () => {
            if (editorBootstrapped) return;
            editorBootstrapped = true;
            await loadLanguages();
            await initModule();
            await resetEditorToBlank({ skipStatus: true, skipFocus: true });
            openTab('metadata');
            updateGlobalToolbar('metadata');
            installStorageSyncBridge();
        })();
        </script>

        <script>
        (function(){
            if(!window || !window.document) return;
            if(!window.electronAPI) return; // only run inside Electron where preload exposes electronAPI
            console.info('Electron bridge detected ‚Äî enabling disk I/O overrides');

            // use global electronCurrentPath declared earlier

            const updateElectronWatcher = (filePath) => {
                if (window.electronFile && typeof window.electronFile.setActive === 'function') {
                    try { window.electronFile.setActive(filePath || null); } catch (e) { console.warn('Failed to update electron watcher', e); }
                }
            };

            const applyElectronOpenResult = (res) => {
                if (!res) return null;
                if (res.error) {
                    console.error('openFile error', res.error);
                    const failMsg = (languages[currentLanguage]?.failedToLoadStory || 'Failed to load story: {err}').replace('{err}', res.error);
                    setStatus(failMsg, true);
                    return null;
                }
                electronCurrentPath = res.path || null;
                updateElectronWatcher(electronCurrentPath);
                if (typeof window.loadFromString === 'function') {
                    window.loadFromString(res.content);
                } else if (typeof window.openFromString === 'function') {
                    window.openFromString(res.content);
                } else {
                    const ta = document.querySelector('textarea#file-content') || document.querySelector('textarea.story-text');
                    if (ta) {
                        ta.value = res.content;
                        ta.dispatchEvent(new Event('input'));
                    } else {
                        console.warn('No handler available for story content');
                    }
                }
                refreshRecentStories();
                return res;
            };

            const nowFn = () => { try { return performance.now(); } catch (e) { return Date.now(); } };
            let suppressDiskReloadUntil = 0;
            const suppressDiskReload = () => { suppressDiskReloadUntil = nowFn() + 1800; };
            const shouldIgnoreDiskReload = () => nowFn() < suppressDiskReloadUntil;

            const reloadFromPayload = (payload) => {
                if (!payload || typeof payload.content !== 'string') return;
                try {
                    if (typeof window.loadFromString === 'function') {
                        window.loadFromString(payload.content);
                        markClean(payload.content, electronCurrentPath ? getBaseName(electronCurrentPath) : null);
                    } else if (typeof window.openFromString === 'function') {
                        window.openFromString(payload.content);
                    } else {
                        console.warn('Received file change event but no loader available');
                        return;
                    }
                    setStatus('Story reloaded from disk');
                } catch (err) {
                    console.error('Failed to apply disk change', err);
                }
            };

            const diskChangeModal = (() => {
                const root = document.getElementById('external-change-modal');
                if (!root) return null;
                const nameEl = root.querySelector('[data-change-name]');
                const timeEl = root.querySelector('[data-change-timestamp]');
                const msgEl = root.querySelector('[data-change-message]');
                const warnEl = root.querySelector('[data-change-warning]');
                const reloadBtn = root.querySelector('[data-change-reload]');
                const ignoreBtn = root.querySelector('[data-change-ignore]');
                const closeTargets = root.querySelectorAll('[data-change-close]');
                let resolver = null;
                let previousActive = null;

                const hide = () => {
                    root.classList.remove('is-visible');
                    root.setAttribute('aria-hidden', 'true');
                    root.removeEventListener('keydown', handleKeyDown, true);
                    if (previousActive && typeof previousActive.focus === 'function') {
                        try { previousActive.focus(); } catch (e) {}
                    }
                };

                const finish = (val) => {
                    if (!resolver) return;
                    const resolve = resolver;
                    resolver = null;
                    hide();
                    resolve(!!val);
                };

                const handleKeyDown = (ev) => {
                    if (ev.key === 'Escape') {
                        ev.preventDefault();
                        finish(false);
                    }
                };

                const open = ({ fileName, timestamp, dirty, message }) => {
                    if (nameEl) nameEl.textContent = fileName || 'Untitled';
                    if (timeEl) timeEl.textContent = timestamp || 'Just now';
                    if (msgEl) msgEl.textContent = message || 'This story changed outside the editor.';
                    if (warnEl) warnEl.style.display = dirty ? 'flex' : 'none';
                    root.classList.add('is-visible');
                    root.setAttribute('aria-hidden', 'false');
                    previousActive = document.activeElement;
                    root.addEventListener('keydown', handleKeyDown, true);
                    return new Promise((resolve) => {
                        resolver = resolve;
                        setTimeout(() => { try { reloadBtn?.focus(); } catch (e) {} }, 15);
                    });
                };

                reloadBtn?.addEventListener('click', () => finish(true));
                ignoreBtn?.addEventListener('click', () => finish(false));
                closeTargets.forEach(btn => btn.addEventListener('click', (ev) => { ev.preventDefault(); finish(false); }));

                return { open, cancel: () => finish(false) };
            })();

            const formatDiskTimestamp = (isoString) => {
                if (!isoString) return 'Just now';
                try {
                    const dt = new Date(isoString);
                    if (!isNaN(dt.getTime())) {
                        return dt.toLocaleString([], { weekday: 'short', hour: '2-digit', minute: '2-digit', month: 'short', day: 'numeric' });
                    }
                } catch (e) {}
                return isoString;
            };

            const showExternalChangePrompt = (payload) => {
                const displayName = payload?.path ? getBaseName(payload.path) : (languages[currentLanguage]?.untitled || 'Untitled');
                const baseMessage = languages[currentLanguage]?.externalChangePrompt || 'The file has changed on disk. Reload it now?';
                if (!diskChangeModal) {
                    return showUniformConfirm({
                        icon: 'fas fa-wave-square',
                        eyebrow: languages[currentLanguage]?.file || 'File',
                        title: languages[currentLanguage]?.reloadStory || 'Reload Story',
                        message: baseMessage,
                        warning: isDirtyText ? (languages[currentLanguage]?.unsavedWarning || 'Unsaved editor changes will be lost.') : '',
                        primaryLabel: languages[currentLanguage]?.reload || 'Reload',
                        secondaryLabel: languages[currentLanguage]?.cancel || 'Cancel',
                        destructive: true,
                        meta: [
                            {
                                label: languages[currentLanguage]?.file || 'File',
                                value: displayName
                            }
                        ]
                    });
                }
                return diskChangeModal.open({
                    fileName: displayName,
                    timestamp: formatDiskTimestamp(payload?.mtime),
                    dirty: !!isDirtyText,
                    message: baseMessage
                });
            };

            if (window.electronFile && typeof window.electronFile.onFileContentChanged === 'function') {
                try {
                    window.electronFile.onFileContentChanged(async (payload) => {
                        if (!payload || shouldIgnoreDiskReload()) return;
                        const shouldReload = await showExternalChangePrompt(payload);
                        if (shouldReload) reloadFromPayload(payload); else setStatus('Ignored external file change');
                    });
                } catch (err) {
                    console.warn('Failed to attach disk change listener', err);
                }
            }

            async function electronOpenFile(targetPath){
                try{
                    const res = targetPath
                        ? await window.electronAPI.openRecentStory(targetPath)
                        : await window.electronAPI.openFile();
                    return applyElectronOpenResult(res);
                }catch(err){ console.error('electronOpenFile', err); return null; }
            }

            async function openRecentStoryDirect(filePath){
                if (!filePath) return false;
                const result = await electronOpenFile(filePath);
                return !!(result && !result.error);
            }

            async function electronSaveFile(content){
                try{
                    // When possible, ask the page for the current content
                    if(!content){ if(typeof window.getCurrentContent === 'function') content = await window.getCurrentContent(); else {
                        const ta = document.querySelector('textarea#file-content') || document.querySelector('textarea.story-text'); if(ta) content = ta.value;
                    }}
                    if(content == null) { console.warn('No content available to save'); return; }

                    if(electronCurrentPath){
                        const res = await window.electronAPI.saveFile(content, electronCurrentPath);
                        if(res && res.error) {
                            console.error('saveFile error', res.error);
                        } else if (res) {
                            suppressDiskReload();
                            // Mark clean after successful save
                            try {
                                lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content;
                                isDirtyText = false;
                                updateFileIndicator();
                            } catch(e){}
                        }
                        return res;
                    }
                    // no current path ‚Äî open Save As
                    const res = await window.electronAPI.saveAs(content, electronCurrentPath);
                    if(res && res.error) console.error('saveAs error', res.error);
                    if(res && res.path){
                        electronCurrentPath = res.path;
                        updateElectronWatcher(electronCurrentPath);
                        suppressDiskReload();
                        try {
                            lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content;
                            isDirtyText = false;
                            updateFileIndicator();
                        } catch(e){}
                    }
                    return res;
                }catch(err){ console.error('electronSaveFile', err); }
            }

            async function electronSaveAs(content){
                try{
                    if(!content){ if(typeof window.getCurrentContent === 'function') content = await window.getCurrentContent(); else {
                        const ta = document.querySelector('textarea#file-content') || document.querySelector('textarea.story-text'); if(ta) content = ta.value;
                    }}
                    if(content == null) { console.warn('No content available to save'); return; }
                    const res = await window.electronAPI.saveAs(content, electronCurrentPath);
                    if(res && res.path){
                        electronCurrentPath = res.path;
                        updateElectronWatcher(electronCurrentPath);
                        suppressDiskReload();
                        // Mark clean after Save As and remember new path
                        try {
                            lastSavedText = (textEditor && textEditor.getValue) ? textEditor.getValue() : content;
                            isDirtyText = false;
                            updateFileIndicator();
                        } catch(e){}
                    }
                    if(res && res.error) console.error('saveAs error', res.error);
                    return res;
                }catch(err){ console.error('electronSaveAs', err); }
            }

            const closePromptState = { busy: false };

            const formatSaveFailure = (msg) => {
                const template = languages[currentLanguage]?.saveFailed || 'Failed to save story: {err}';
                return template.replace('{err}', msg || 'Unknown error');
            };

            const saveCancelledMessage = () => languages[currentLanguage]?.saveCancelled || 'Save canceled. Story remains open.';

            async function attemptSaveBeforeClose(mode) {
                try {
                    const result = mode === 'save-as' ? await electronSaveAs() : await electronSaveFile();
                    if (!result) {
                        setStatus(saveCancelledMessage());
                        return false;
                    }
                    if (result.error) {
                        setStatus(formatSaveFailure(result.error), true);
                        return false;
                    }
                    return true;
                } catch (err) {
                    const message = err && err.message ? err.message : String(err);
                    setStatus(formatSaveFailure(message), true);
                    return false;
                }
            }

            async function resolveCloseRequest(allow) {
                if (!window.electronAPI || typeof window.electronAPI.resolveCloseRequest !== 'function') {
                    if (allow) console.warn('resolveCloseRequest bridge missing; cannot finalize close request');
                    return;
                }
                try {
                    await window.electronAPI.resolveCloseRequest({ allow: !!allow });
                } catch (err) {
                    console.warn('Failed to resolve close request', err);
                }
            }

            async function showUnsavedClosePrompt() {
                const config = {
                    icon: 'fas fa-exclamation-triangle',
                    eyebrow: languages[currentLanguage]?.file || 'File',
                    title: languages[currentLanguage]?.unsavedChanges || 'Unsaved changes detected',
                    message: languages[currentLanguage]?.unsavedClosePrompt || 'You have unsaved changes. Choose an option before closing.',
                    warning: languages[currentLanguage]?.unsavedWarning || 'Unsaved editor changes will be lost if you exit without saving.',
                    primaryLabel: languages[currentLanguage]?.save || 'Save',
                    secondaryLabel: languages[currentLanguage]?.cancel || 'Cancel',
                    primaryValue: 'save',
                    secondaryValue: 'cancel',
                    extraActions: [
                        {
                            label: languages[currentLanguage]?.saveAs || 'Save As',
                            icon: 'fas fa-file-export',
                            value: 'save-as'
                        },
                        {
                            label: languages[currentLanguage]?.exit || 'Exit',
                            icon: 'fas fa-sign-out-alt',
                            value: 'exit',
                            variant: 'danger'
                        }
                    ]
                };
                const selection = await showUniformConfirm(config);
                if (selection === true) return 'exit';
                if (selection === false) return 'cancel';
                return selection;
            }

            async function handleCloseRequest() {
                if (!isDirtyText) {
                    await resolveCloseRequest(true);
                    return;
                }
                const choice = await showUnsavedClosePrompt();
                switch (choice) {
                    case 'save': {
                        const ok = await attemptSaveBeforeClose('save');
                        await resolveCloseRequest(!!ok);
                        return;
                    }
                    case 'save-as': {
                        const ok = await attemptSaveBeforeClose('save-as');
                        await resolveCloseRequest(!!ok);
                        return;
                    }
                    case 'exit':
                        await resolveCloseRequest(true);
                        return;
                    default:
                        await resolveCloseRequest(false);
                        return;
                }
            }

            function installCloseRequestPrompt() {
                if (!window.electronWindowEvents || typeof window.electronWindowEvents.onCloseRequest !== 'function') {
                    console.warn('Electron close-request bridge unavailable; close confirmation disabled');
                    return;
                }
                window.electronWindowEvents.onCloseRequest(() => {
                    if (closePromptState.busy) return;
                    closePromptState.busy = true;
                    Promise.resolve(handleCloseRequest())
                        .finally(() => { closePromptState.busy = false; });
                });
            }

            // Override existing web functions only when present; otherwise, add minimal wrappers
            try{
                // Also wrap newStory to clear the current electron path when starting fresh
                if(typeof window.newStory === 'function'){
                    const origNew = window.newStory;
                    window.newStory = function(){
                        try {
                            electronCurrentPath = null;
                            updateElectronWatcher(null);
                        } catch (e) {}
                        return origNew.apply(this, arguments);
                    };
                }

                if(typeof window.loadFile === 'function'){
                    const webLoad = window.loadFile;
                    window.loadFile = function(){ return electronOpenFile.apply(this, arguments); };
                    window.webLoadFile = webLoad;
                } else {
                    window.loadFile = function(){ return electronOpenFile.apply(this, arguments); };
                }

                if(typeof window.saveFile === 'function'){
                    const webSave = window.saveFile;
                    window.saveFile = function(){ return electronSaveFile(); };
                    window.webSaveFile = webSave;
                } else {
                    window.saveFile = electronSaveFile;
                }

                // Optional: expose saveAs
                window.saveFileAs = window.saveFileAs || electronSaveAs;

                window.__openRecentStoryFromElectron = openRecentStoryDirect;

                // Intercept file input clicks (if the page uses a native <input type="file">)
                const fileInput = document.getElementById('file-input') || document.querySelector('input[type=file]');
                if(fileInput){
                    fileInput.addEventListener('click', function(ev){
                        if(window.electronAPI){ ev.preventDefault(); electronOpenFile(); }
                    });
                }

                // Intentionally do not inject any 'Save As' UI; Save As remains available via programmatic APIs only.
            }catch(e){ console.error('Error installing electron overrides', e); }

            installCloseRequestPrompt();
            refreshRecentStories();

        })();
        </script>
</body>
</html>